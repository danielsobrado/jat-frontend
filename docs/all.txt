Files:
File: src/App.tsx
// src/App.tsx
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation, Outlet } from 'react-router-dom';
import { useAuth } from './context/AuthContext'; // <<< Use the hook
import PageLayout from './components/Layout/PageLayout';
import TestPage from './pages/TestPage';
import BatchPage from './pages/BatchPage';
import BatchJobsPage from './pages/BatchJobsPage';
import HistoryPage from './pages/HistoryPage';
import SettingsPage from './pages/SettingsPage';
import RagInfoPage from './pages/RagInfoPage';
import LoginPage from './pages/LoginPage';
import UserManagementPage from './pages/UserManagementPage'; // <<< Import Admin Pages
import RoleManagementPage from './pages/RoleManagementPage';   // <<< Import Admin Pages
import './App.css';
import { Spin } from 'antd'; // For loading indicator
import ChatPage from './pages/ChatPage';

// Assuming these components exist in the specified path
import LangGraphListPage from './langgraph/pages/LangGraphListPage'; 
import LangGraphViewPage from './langgraph/pages/LangGraphViewPage';
import LangGraphCreatePage from './langgraph/pages/LangGraphCreatePage';

// --- Protected Route Component ---
interface ProtectedRouteProps {
    isAllowed: boolean;
    redirectPath?: string;
    children?: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
    isAllowed,
    redirectPath = '/login',
    children,
}) => {
    const location = useLocation();

    if (!isAllowed) {
        // Redirect them to the /login page, but save the current location they were
        // trying to go to when they were redirected. This allows us to send them
        // along to that page after they login, which is a nicer user experience
        // than dropping them off on the home page.
        return <Navigate to={redirectPath} state={{ from: location }} replace />;
    }

    return children ? <>{children}</> : <Outlet />; // Render children or Outlet
};
// --- End Protected Route Component ---

function App() {
  const {
    isAuthenticated,
    loading,
    authEnabled,
    checkPermission, // Get checkPermission from context
    apiClient,       // Get apiClient from context
    logout,          // Get logout from context
    handleLoginSuccess: contextLoginSuccess // Rename for clarity
  } = useAuth();

  // RAG enabled status (can also be moved to context if needed globally)
  const [ragEnabled, setRagEnabled] = useState<boolean | null>(null);
  const [ragStatusFetched, setRagStatusFetched] = useState(false);
  
  useEffect(() => {
    const fetchRagStatus = async () => {
       try {
            const config = await apiClient.getConfig();
            
            // Log the full config for debugging, pretty-printed
            console.log("[DEBUG] Full config response from apiClient.getConfig():", JSON.stringify(config, null, 2));
            
            // Determine RAG status solely from the correct nested property
            const isRagEnabled = !!config?.database?.ragEnabled;
            
            console.log('[App.tsx] RAG enabled status determined:', isRagEnabled, 'Value from config.database.ragEnabled:', config?.database?.ragEnabled);
            
            setRagEnabled(isRagEnabled);
       } catch (e) { 
          console.error("Failed to get RAG status from API, defaulting to false.", e); 
          setRagEnabled(false); // Ensure it defaults to false on API error
       } finally {
          setRagStatusFetched(true);
       }
    };
    fetchRagStatus();
  }, [apiClient]);

  // Use a dummy handleLoginSuccess if context doesn't provide one directly
  const handleLoginSuccess = () => {
      console.log("Login successful callback in App.tsx");
      contextLoginSuccess();
  };

  // Use the logout function from context
  const handleLogout = () => {
      logout();
  };

  if (loading || authEnabled === null || !ragStatusFetched) { // Wait for context loading & RAG status
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Spin size="large" />
      </div>
    );
  }

  return (
    <Router>
      <Routes>
        {/* Public Login Route */}
        <Route
          path="/login"
          element={
            isAuthenticated && authEnabled ? ( // Redirect only if auth is enabled AND logged in
              <Navigate to="/" replace />
            ) : (
              <LoginPage apiClient={apiClient} onLoginSuccess={handleLoginSuccess} />
            )
          }
        />

        {/* Protected Application Routes */}
        <Route
          element={
            <ProtectedRoute isAllowed={!authEnabled || isAuthenticated}>
                <PageLayout ragEnabled={!!ragEnabled} onLogout={handleLogout} />
             </ProtectedRoute>
          }
        >
              <Route index element={<Navigate to="/test" replace />} />
              {/* Apply permission checks inline or via a wrapper component */}
              <Route path="/test" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('classify:item')}><TestPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/batch" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('classify:batch')}><BatchPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/batch/jobs" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('classify:batch')}><BatchJobsPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/history" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('history:view')}><HistoryPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/rag-info" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('rag:view')}><RagInfoPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/chat" element={
                <ProtectedRoute isAllowed={!authEnabled || checkPermission('chat:use')}> {/* Example permission */}
                  <ChatPage />
                </ProtectedRoute>
              } />
              <Route path="/settings" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('config:view')}><SettingsPage apiClient={apiClient} /></ProtectedRoute>} />

              {/* Admin Routes */}
              <Route path="/admin/users" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('users:manage')}><UserManagementPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/admin/roles" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('roles:manage')}><RoleManagementPage apiClient={apiClient} /></ProtectedRoute>} />

              {/* LangGraph Routes */}
              <Route path="/langgraph" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('langgraph:view')}><LangGraphListPage /></ProtectedRoute>} />
              <Route path="/langgraph/view/:graphId" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('langgraph:view')}><LangGraphViewPage /></ProtectedRoute>} />
              <Route path="/langgraph/create" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('langgraph:create')}><LangGraphCreatePage /></ProtectedRoute>} />

              <Route path="*" element={<Navigate to="/test" replace />} />
        </Route>
      </Routes>
    </Router>
  );
}

export default App;

File: src/index.css
/* Import sidebar styles - moved to top to fix warning */
@import url('./components/Sidebar/left-sidebar.css');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-synthesis: none;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  html {
    @apply antialiased;
  }

  body {
    @apply min-h-screen bg-secondary-50 text-secondary-900;
    margin: 0;
    padding: 0;
  }

  #root {
    @apply min-h-screen;
  }
}

@layer components {
  /* Button variants */
  .btn {
    @apply inline-flex items-center justify-center px-4 py-2.5 border border-transparent text-sm font-medium rounded-card shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2;
  }

  .btn-primary {
    @apply bg-primary-600 text-white hover:bg-primary-700 focus:ring-primary-500;
  }

  .btn-secondary {
    @apply bg-white text-secondary-700 border-secondary-300 hover:bg-secondary-50 focus:ring-primary-500;
  }

  /* Input styles */
  .input {
    @apply block w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm;
    @apply focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent;
    @apply disabled:bg-secondary-100 disabled:text-secondary-500 disabled:cursor-not-allowed;
  }

  .label {
    @apply block text-sm font-medium text-secondary-700 mb-1;
  }

  /* Card component */
  .card {
    @apply bg-white shadow-card rounded-card p-8 w-full;
    @apply hover:shadow-card-hover transition-shadow;
  }

  /* Page container */
  .page-container {
    @apply max-w-full w-full mx-auto;
  }
}


File: src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import 'reactflow/dist/style.css'; // Import React Flow styles
import 'antd/dist/reset.css'; // Import Ant Design styles (updated path)
import { AuthProvider } from './context/AuthContext'; // Import AuthProvider
import { WebApiClient } from './api/client'; // Import client

const apiClientInstance = new WebApiClient(); // Create single client instance

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <AuthProvider apiClientInstance={apiClientInstance}> {/* Wrap App */}
      <App />
    </AuthProvider>
  </React.StrictMode>
);

File: src/utils/dateFormat.ts
interface DateFormatOptions {
  /** Whether to include timezone in the full format */
  includeTimezone?: boolean;
  /** Whether to use 24-hour format */
  hour24?: boolean;
  /** Custom Intl.DateTimeFormat options for display text */
  displayOptions?: Intl.DateTimeFormatOptions;
  /** Custom Intl.DateTimeFormat options for tooltip text */
  tooltipOptions?: Intl.DateTimeFormatOptions;
}

interface FormattedDate {
  /** Short format for display (e.g., "Mar 28, 2025, 17:30") */
  displayText: string;
  /** Full format for tooltip (e.g., "Mar 28, 2025, 17:30 GST") */
  fullText: string;
}

const defaultDisplayOptions: Intl.DateTimeFormatOptions = {
  year: 'numeric',
  month: 'short',
  day: 'numeric',
  hour: '2-digit',
  minute: '2-digit',
  hour12: false
};

const defaultTooltipOptions: Intl.DateTimeFormatOptions = {
  ...defaultDisplayOptions,
  timeZoneName: 'short'
};

/**
 * Format a date string with display text and tooltip text
 * @param dateStr - ISO date string to format
 * @param options - Formatting options
 * @returns Object with displayText and fullText properties
 */
export const formatDate = (
  dateStr: string | undefined | null,
  options: DateFormatOptions = {}
): FormattedDate => {
  if (!dateStr) {
    return { displayText: 'N/A', fullText: 'N/A' };
  }

  try {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      console.error('Invalid date string:', dateStr);
      return { displayText: 'Invalid Date', fullText: 'Invalid Date' };
    }

    const {
      hour24 = true,
      includeTimezone = true,
      displayOptions: customDisplayOptions = {},
      tooltipOptions: customTooltipOptions = {}
    } = options;

    // Merge custom options with defaults
    const displayOpts: Intl.DateTimeFormatOptions = {
      ...defaultDisplayOptions,
      ...customDisplayOptions,
      hour12: !hour24
    };

    const tooltipOpts: Intl.DateTimeFormatOptions = {
      ...defaultTooltipOptions,
      ...customTooltipOptions,
      hour12: !hour24,
      timeZoneName: includeTimezone ? 'short' : undefined
    };

    const displayText = new Intl.DateTimeFormat('default', displayOpts).format(date);
    const fullText = new Intl.DateTimeFormat('default', tooltipOpts).format(date);

    return { displayText, fullText };
  } catch (e) {
    console.error('Error formatting date:', dateStr, e);
    return { displayText: 'Invalid Date', fullText: 'Invalid Date' };
  }
};

File: src/test-data/create-excel.js
import XLSX from 'xlsx';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Read the CSV file
const csvPath = path.join(__dirname, 'sample_products.csv');
const csvContent = fs.readFileSync(csvPath, 'utf-8');

// Parse CSV content
const workbook = XLSX.utils.book_new();
const worksheet = XLSX.utils.csv_to_sheet(csvContent);

// Add the worksheet to the workbook
XLSX.utils.book_append_sheet(workbook, worksheet, 'Products');

// Write to Excel file
const excelPath = path.join(__dirname, 'sample_products.xlsx');
XLSX.writeFile(workbook, excelPath);

console.log('Excel file created successfully at:', excelPath);

File: src/pages/BatchPage.tsx
import React, { useState, useEffect } from 'react';
import BatchTab from '../components/BatchTab/BatchTab';
import { ApiClient, ClassificationSystem } from '../api/types';
import { useAuth } from '../context/AuthContext';

interface BatchPageProps {
  apiClient: ApiClient;
}

const BatchPage: React.FC<BatchPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  const [availableSystems, setAvailableSystems] = useState<ClassificationSystem[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [canSubmit, setCanSubmit] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Load available systems
  useEffect(() => {
    const loadSystems = async () => {
      try {
        const systems = await apiClient.getClassificationSystems();
        setAvailableSystems(systems);
      } catch (err) {
        console.error('Failed to load classification systems:', err);
      }
    };
    loadSystems();
  }, [apiClient]);

  const handleSubmit = async () => {
    // Check permission before submitting batch
    if (!checkPermission('classify:batch')) {
      setError('You do not have permission to perform batch classifications');
      return;
    }
  };

  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Batch Classification</h1>
        <p className="text-secondary-600">Process multiple items for classification at once</p>
      </div>

      {/* Add permission check warning if user lacks permission */}
      {!checkPermission('classify:batch') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to perform batch classifications. Please contact your administrator for access.
          </p>
        </div>
      )}
      
      <BatchTab apiClient={apiClient} availableSystems={availableSystems.map(s => ({ system: s }))} />
    </div>
  );
};

export default BatchPage;

File: src/pages/HistoryPage.tsx
import React from 'react';
import { HistoryTab } from '../components/HistoryTab';
import { ApiClient } from '../api/types';

interface HistoryPageProps {
  apiClient: ApiClient;
}

const HistoryPage: React.FC<HistoryPageProps> = ({ apiClient }) => {
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Classification History</h1>
        <p className="text-secondary-600">
          View and manage previous classification results
        </p>
      </div>
      
      <HistoryTab apiClient={apiClient} />
    </div>
  );
};

export default HistoryPage;

File: src/pages/RagInfoPage.tsx
// src/pages/RagInfoPage.tsx
import React from 'react';
import { ApiClient } from '../api/types';
import { RagInfoTab } from '../components/RagInfoTab'; // Correct import for the main tab component
import { useAuth } from '../context/AuthContext';

interface RagInfoPageProps {
  apiClient: ApiClient;
}

const RagInfoPage: React.FC<RagInfoPageProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();

  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Information Management</h1>
        <p className="text-secondary-600">
          Manage information for RAG classification assistance
        </p>
      </div>

      {/* Display permission warning if needed */}
      {!checkPermission('rag:view') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to view or manage RAG information.
            Please contact your administrator for access.
          </p>
        </div>
      )}

      {/* Only show RAG info component if user has permission */}
      {/* Render RagInfoTab (which contains the table, filters, buttons etc.) */}
      {checkPermission('rag:view') && <RagInfoTab apiClient={apiClient} />}

    </div>
  );
};

export default RagInfoPage;

File: src/pages/BatchJobsPage.tsx
import React from 'react';
import BatchJobsTab from '../components/BatchJobsTab/BatchJobsTab';
import { ApiClient } from '../api/types';

interface BatchJobsPageProps {
  apiClient: ApiClient;
}

const BatchJobsPage: React.FC<BatchJobsPageProps> = ({ apiClient }) => {
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Batch Jobs</h1>
        <p className="text-secondary-600">
          View and manage batch classification jobs
        </p>
      </div>
      
      <BatchJobsTab apiClient={apiClient} />
    </div>
  );
};

export default BatchJobsPage;

File: src/App.css
/* App.css */
/* Main app container */
.app-container {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  
  /* Header styles */
  .app-header {
    background-color: #1e40af; /* primary-900 */
    color: white;
    height: 64px;
    display: flex;
    align-items: center;
    padding: 0 24px;
    position: fixed;
    top: 0;
    width: 100%;
    z-index: 10;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }
  
  .app-title {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0;
  }
  
  /* Main content area */
  .app-content {
    display: flex;
    flex: 1;
    margin-top: 64px; /* Header height */
    position: relative;
    height: calc(100vh - 64px);
  }
  
  /* Sidebar wrapper - fixed width plus transition */
  .sidebar-wrapper {
    position: fixed;
    width: 60px;
    height: calc(100vh - 64px);
    z-index: 5;
  }
  
  /* Main content styles - adjust margin to sidebar width */
  .main-content {
    flex: 1;
    padding: 24px;
    margin-left: 60px; /* Match sidebar width */
    transition: margin-left 0.3s ease-in-out;
    background-color: #f9fafb; /* gray-50 */
    overflow-y: auto;
    width: calc(100% - 60px); /* Ensure content takes remaining space */
  }
  
  /* When sidebar is expanded, adjust margin of content */
  .main-content.sidebar-expanded {
    margin-left: 230px;
    width: calc(100% - 230px);
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .sidebar-wrapper {
      position: fixed;
      z-index: 5;
      height: calc(100vh - 64px);
    }
    
    .main-content {
      margin-left: 0;
      padding: 16px;
    }
  }


File: src/langgraph/services/langGraphApiService.fixed.ts
/**
 * Represents the UI position of a node for visualization.
 * Mirrors backend: NodeUIPosition
 */
export interface UINodePosition {
  x: number;
  y: number;
}

/**
 * Defines a single node in the graph structure for frontend use.
 * Mirrors backend: NodeDefinition
 */
export interface FrontendNodeDef {
  id: string;
  type: string; // Maps to backend logic (e.g., 'llm_node', 'tool_node')
  config: Record<string, any>; // Configuration specific to this node type
  uiPosition?: UINodePosition; // Optional UI positioning
  // Frontend-specific display properties can be added here if needed
  // e.g., customData?: { label?: string; icon?: string; status?: 'running' | 'completed' | 'error' };
}

/**
 * Defines a directed edge between two nodes for frontend use.
 * Mirrors backend: EdgeDefinition
 */
export interface FrontendEdgeDef {
  id: string;
  source: string; // ID of the source node
  target: string; // ID of the target node
  label?: string; // Optional label for the edge
  animated?: boolean;
  // type?: string; // For custom React Flow edge rendering
}

/**
 * Defines the target node for a specific condition name.
 * Mirrors backend: ConditionalEdgeMapping
 */
export interface FrontendConditionalEdgeMapping {
  conditionName: string; // The name of the condition
  targetNodeId: string;  // The ID of the node to transition to
}

/**
 * Defines conditional outgoing edges for a specific source node.
 * Mirrors backend: ConditionalEdgesDefinition
 */
export interface FrontendConditionalEdgesDef {
  sourceNodeId: string;
  // routerFunctionName?: string; // Name of the router function in backend's ROUTER_IMPLEMENTATIONS
  mappings: FrontendConditionalEdgeMapping[];
}

/**
 * Full definition of a LangGraph workflow for frontend use.
 * Mirrors backend: GraphDefinition
 */
export interface FrontendGraphDef {
  id: string;
  name: string;
  description?: string;
  stateSchemaName: string; // Name of the Pydantic model for LangGraph state
  nodes: FrontendNodeDef[];
  edges: FrontendEdgeDef[];
  conditionalEdges: FrontendConditionalEdgesDef[];
  entryPointNodeId: string;
  terminalNodeIds?: string[];
  version?: number;
  createdAt?: string; // ISO date string
  updatedAt?: string; // ISO date string
}

/**
 * Minimal identifier for a graph definition, used in listings.
 * Mirrors backend: GraphDefinitionIdentifier
 */
export interface GraphDefinitionIdentifierFE {
  id: string;
  name: string;
  updatedAt?: string; // ISO date string
}

/**
 * Response for listing graph definitions.
 * Mirrors backend: GraphDefinitionListResponse
 */
export interface GraphDefinitionListResponseFE {
  graphs: GraphDefinitionIdentifierFE[];
}

/**
 * Request payload for creating a new graph definition.
 * Mirrors backend: CreateGraphRequest
 */
export interface CreateGraphRequestFE extends Omit<FrontendGraphDef, 'id' | 'createdAt' | 'updatedAt' | 'version'> {
  // id, createdAt, updatedAt, version are typically server-generated
}

/**
 * Request payload for updating an existing graph definition.
 * Mirrors backend: UpdateGraphRequest
 */
export interface UpdateGraphRequestFE extends CreateGraphRequestFE {
  // Inherits all fields from CreateGraphRequestFE.
  // The ID of the graph to update is usually passed as a path parameter.
}


// --- WebSocket Event Types (mirroring backend schemas) ---

export type WebSocketEventType =
  | 'graph_execution_start'
  | 'node_start'
  | 'node_end'
  | 'edge_taken' // You might need to infer this or have backend send it explicitly
  | 'graph_execution_end'
  | 'graph_error'
  | 'pong'; // For keep-alive if implemented

export interface WebSocketBaseEventFE {
  eventType: WebSocketEventType;
  timestamp: string; // ISO date string
  executionId: string;
  graphId: string;
}

export interface GraphExecutionStartEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_start';
  inputArgs: Record<string, any>;
}

export interface NodeLifecycleEventFE extends WebSocketBaseEventFE {
  nodeId: string;
  nodeType?: string;
}

export interface NodeStartEventFE extends NodeLifecycleEventFE {
  eventType: 'node_start';
  inputData: Record<string, any>;
}

export interface NodeEndEventFE extends NodeLifecycleEventFE {
  eventType: 'node_end';
  outputData: Record<string, any>;
  status: 'success' | 'failure';
  errorMessage?: string;
  durationMs?: number;
}

export interface EdgeTakenEventFE extends WebSocketBaseEventFE {
  eventType: 'edge_taken';
  sourceNodeId: string;
  targetNodeId: string;
  edgeLabel?: string;
  isConditional: boolean;
}

export interface GraphExecutionEndEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_end';
  finalState: Record<string, any>;
  status: 'completed' | 'failed' | 'interrupted';
  totalDurationMs?: number;
}

export interface GraphErrorEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_error';
  message: string;
  details?: string;
  nodeId?: string;
}

export interface PongEventFE extends Omit<WebSocketBaseEventFE, 'executionId' | 'graphId'> {
    eventType: 'pong';
    serverTime: string;
}

// Union type for all possible incoming WebSocket messages
export type LangGraphExecutionEvent =
  | GraphExecutionStartEventFE
  | NodeStartEventFE
  | NodeEndEventFE
  | EdgeTakenEventFE
  | GraphExecutionEndEventFE
  | GraphErrorEventFE
  | PongEventFE;

// --- HTTP API Request/Response Types for LangGraph Management ---

/**
 * Request to initiate execution of a graph via HTTP (if implemented).
 * Mirrors backend: ExecuteGraphRequest
 */
export interface ExecuteGraphRequestFE {
  inputArgs?: Record<string, any>;
  // configOverrides?: Record<string, any>;
}

/**
 * Response after initiating a graph execution via HTTP.
 * Mirrors backend: ExecuteGraphResponse
 */
export interface ExecuteGraphResponseFE {
  executionId: string;
  message: string;
  // statusUrl?: string; // URL to poll for status if not using WebSockets
}

/**
 * Generic message response from the API.
 */
export interface MessageResponseFE {
  message: string;
  details?: any;
}

import { ApiClient } from '../../api/types';

// --- LangGraphApiService Class ---
export class LangGraphApiService {
  private apiClient: ApiClient;
  private prefix: string;

  constructor(apiClient: ApiClient, prefix: string = '/v1/lg-vis') {
    this.apiClient = apiClient;
    this.prefix = prefix;
    console.log(`[LangGraphApiService] Initialized with prefix: ${this.prefix}`);
  }

  // Custom method to get data that bypasses formatEndpoint
  private async directGet<T = any>(path: string, params?: Record<string, any>): Promise<T> {
    // Ensure path is correct by removing any duplicate slashes between prefix and path
    const basePath = path.startsWith('/') ? path : `/${path}`;
    
    // Add query parameters to the URL
    let urlString = basePath;
    if (params && Object.keys(params).length > 0) {
      const queryParams = new URLSearchParams();
      Object.keys(params).forEach(key => {
        if (params[key] !== undefined && params[key] !== null) {
          queryParams.append(key, String(params[key]));
        }
      });
      const queryString = queryParams.toString();
      urlString = queryString ? `${basePath}${basePath.includes('?') ? '&' : '?'}${queryString}` : basePath;
    }
    
    console.log(`[LangGraphApiService] Making direct request to: ${urlString}`);
    const response = await fetch(urlString, { method: 'GET' });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${urlString}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async listGraphDefinitions(includeStatic: boolean = false): Promise<GraphDefinitionListResponseFE> {
    console.log(`[LangGraphApiService] Listing graph definitions with prefix: ${this.prefix}`);
    return this.directGet<GraphDefinitionListResponseFE>(`${this.prefix}/graphs`, { include_static: includeStatic });
  }

  async getGraphDefinition(graphId: string): Promise<FrontendGraphDef> {
    return this.directGet<FrontendGraphDef>(`${this.prefix}/graphs/${graphId}`);
  }

  // Custom method to post data that bypasses formatEndpoint
  private async directPost<T = any>(path: string, body: any): Promise<T> {
    // Ensure path is correct by removing any duplicate slashes between prefix and path
    const fullPath = path.startsWith('/') ? path : `/${path}`;
    console.log(`[LangGraphApiService] Making direct POST request to: ${fullPath}`);
    const response = await fetch(fullPath, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${fullPath}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async createGraphDefinition(data: CreateGraphRequestFE): Promise<FrontendGraphDef> {
    // Convert camelCase keys to snake_case for Python backend
    const transformedData = {
      name: data.name,
      description: data.description,
      state_schema_name: data.stateSchemaName,
      entry_point_node_id: data.entryPointNodeId,
      nodes: data.nodes.map(node => ({
        id: node.id,
        type: node.type,
        config: node.config,
        ui_position: node.uiPosition ? {
          x: node.uiPosition.x,
          y: node.uiPosition.y
        } : undefined
      })),
      edges: data.edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        label: edge.label,
        animated: edge.animated
      })),
      conditional_edges: data.conditionalEdges.map(condEdge => ({
        source_node_id: condEdge.sourceNodeId,
        mappings: condEdge.mappings.map(mapping => ({
          condition_name: mapping.conditionName,
          target_node_id: mapping.targetNodeId
        }))
      })),
      terminal_node_ids: data.terminalNodeIds
    };

    return this.directPost<FrontendGraphDef>(`${this.prefix}/graphs`, transformedData);
  }

  // Custom method to put data that bypasses formatEndpoint
  private async directPut<T = any>(path: string, body: any): Promise<T> {
    // Ensure path is correct by removing any duplicate slashes between prefix and path
    const fullPath = path.startsWith('/') ? path : `/${path}`;
    console.log(`[LangGraphApiService] Making direct PUT request to: ${fullPath}`);
    const response = await fetch(fullPath, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${fullPath}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async updateGraphDefinition(graphId: string, data: UpdateGraphRequestFE): Promise<FrontendGraphDef> {
    // Convert camelCase keys to snake_case for Python backend
    const transformedData = {
      name: data.name,
      description: data.description,
      state_schema_name: data.stateSchemaName,
      entry_point_node_id: data.entryPointNodeId,
      nodes: data.nodes.map(node => ({
        id: node.id,
        type: node.type,
        config: node.config,
        ui_position: node.uiPosition ? {
          x: node.uiPosition.x,
          y: node.uiPosition.y
        } : undefined
      })),
      edges: data.edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        label: edge.label,
        animated: edge.animated
      })),
      conditional_edges: data.conditionalEdges.map(condEdge => ({
        source_node_id: condEdge.sourceNodeId,
        mappings: condEdge.mappings.map(mapping => ({
          condition_name: mapping.conditionName,
          target_node_id: mapping.targetNodeId
        }))
      })),
      terminal_node_ids: data.terminalNodeIds
    };

    return this.directPut<FrontendGraphDef>(`${this.prefix}/graphs/${graphId}`, transformedData);
  }

  // Custom method to delete data that bypasses formatEndpoint
  private async directDelete<T = any>(path: string): Promise<T> {
    // Ensure path is correct by removing any duplicate slashes between prefix and path
    const fullPath = path.startsWith('/') ? path : `/${path}`;
    console.log(`[LangGraphApiService] Making direct DELETE request to: ${fullPath}`);
    const response = await fetch(fullPath, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      }
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${fullPath}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async deleteGraphDefinition(graphId: string): Promise<MessageResponseFE> {
    return this.directDelete<MessageResponseFE>(`${this.prefix}/graphs/${graphId}`);
  }

  // Placeholder for HTTP execution if needed, otherwise remove
  async executeGraph(graphId: string, request: ExecuteGraphRequestFE): Promise<ExecuteGraphResponseFE> {
    return this.directPost<ExecuteGraphResponseFE>(`${this.prefix}/graphs/${graphId}/execute`, request);
  }
}


File: src/pages/RoleManagementPage.tsx
import React from 'react';
import { ApiClient } from '../api/types';
import { useAuth } from '../context/AuthContext';
import { RoleManagementComponent } from '../components/RoleManagement/RoleManagementComponent';

interface RoleManagementPageProps {
  apiClient: ApiClient;
}

const RoleManagementPage: React.FC<RoleManagementPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Role Management</h1>
        <p className="text-secondary-600">
          View and manage roles and their permissions
        </p>
      </div>
      
      {/* Display permission warning if needed */}
      {!checkPermission('roles:manage') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to view or manage roles. 
            Please contact your administrator for access.
          </p>
        </div>
      )}
      
      {/* Only show role management component if user has permission */}
      {checkPermission('roles:manage') && <RoleManagementComponent apiClient={apiClient} />}
    </div>
  );
};

export default RoleManagementPage;

File: src/pages/ChatPage.tsx
// src/pages/ChatPage.tsx
import React from 'react';
import { useChat, Message as VercelMessage } from '@ai-sdk/react';
import { Input, Button, List, Avatar, Alert, Form } from 'antd';
import { UserOutlined, RobotOutlined, SendOutlined } from '@ant-design/icons';
import { API_ENDPOINTS, formatEndpoint } from '../config/api'; // To construct the API path
import { useAuth } from '../context/AuthContext'; // To get user info for display

import './ChatPage.css'; // We'll create this file for custom styles

const ChatPage: React.FC = () => {
  const { user } = useAuth(); // Get current user for avatar or display name
  const { messages, input, handleInputChange, handleSubmit, isLoading, error } = useChat({
    api: formatEndpoint(API_ENDPOINTS.chat.completions), // Your Go backend endpoint
    onError: (err) => {
      // Handle API errors (e.g., display a toast message)
      console.error("Chat API error:", err);
    },
  });

  const onFormSubmit = () => {
    handleSubmit({ preventDefault: () => {} } as React.FormEvent<HTMLFormElement>);
  };

  // Scroll to bottom of message list when new messages are added
  const messagesEndRef = React.useRef<HTMLDivElement | null>(null);
  React.useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="page-container chat-page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">AI Chat</h1>
        <p className="text-secondary-600">
          Chat with the AI assistant for to discusss your classification tasks.
        </p>
      </div>

      {error && (
        <Alert
          message="Chat Error"
          description={error.message || 'An unexpected error occurred.'}
          type="error"
          showIcon
          closable
          className="mb-4"
        />
      )}

      <div className="chat-messages-list">
        <List
          itemLayout="horizontal"
          dataSource={messages}
          renderItem={(message: VercelMessage, index: number) => (
            <List.Item
              key={message.id || `msg-${index}`}
              className={message.role === 'user' ? 'chat-message user' : 'chat-message assistant'}
            >
              <List.Item.Meta
                avatar={
                  message.role === 'user' ? (
                    <Avatar icon={<UserOutlined />} />
                  ) : (
                    <Avatar icon={<RobotOutlined />} style={{ backgroundColor: '#1890ff' }} />
                  )
                }
                title={
                  message.role === 'user'
                    ? (user?.username || 'You')
                    : 'AI Assistant'
                }
                description={
                  <div className="message-content">
                    {message.content.split('\n').map((line, i) => (
                      <React.Fragment key={i}>
                        {line}
                        {i < message.content.split('\n').length - 1 && <br />}
                      </React.Fragment>
                    ))}
                  </div>
                }
              />
            </List.Item>
          )}
        />
        {isLoading && messages.length > 0 && messages[messages.length -1].role === 'user' && (
          <div className="chat-message assistant loading-dots-container">
             <Avatar icon={<RobotOutlined />} style={{ backgroundColor: '#1890ff' }} />
             <div className="loading-dots">
                <span></span><span></span><span></span>
             </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <Form onFinish={onFormSubmit} className="chat-input-form">
        <Input.Group compact style={{ display: 'flex' }}>
          <Input.TextArea
            value={input}
            onChange={handleInputChange}
            placeholder="Type your message..."
            disabled={isLoading}
            onPressEnter={(e) => {
              if (!e.shiftKey && !isLoading && input.trim()) {
                e.preventDefault();
                onFormSubmit();
              }
            }}
            autoSize={{ minRows: 1, maxRows: 5 }}
            style={{ flexGrow: 1, marginRight: 8 }}
          />
          <Button
            type="primary"
            htmlType="submit"
            icon={<SendOutlined />}
            loading={isLoading}
            disabled={!input.trim()}
          >
            Send
          </Button>
        </Input.Group>
      </Form>
    </div>
  );
};

export default ChatPage;

File: src/langgraph/types/langgraph.ts
// src/langgraph/types/langgraph.ts

/**
 * Represents the UI position of a node for visualization.
 * Mirrors backend: NodeUIPosition
 */
export interface UINodePosition {
  x: number;
  y: number;
}

/**
 * Defines a single node in the graph structure for frontend use.
 * Mirrors backend: NodeDefinition
 */
export interface FrontendNodeDef {
  id: string;
  type: string; // Maps to backend logic (e.g., 'llm_node', 'tool_node')
  config: Record<string, any>; // Configuration specific to this node type
  uiPosition?: UINodePosition; // Optional UI positioning
  // Frontend-specific display properties can be added here if needed
  // e.g., customData?: { label?: string; icon?: string; status?: 'running' | 'completed' | 'error' };
}

/**
 * Defines a directed edge between two nodes for frontend use.
 * Mirrors backend: EdgeDefinition
 */
export interface FrontendEdgeDef {
  id: string;
  source: string; // ID of the source node
  target: string; // ID of the target node
  label?: string; // Optional label for the edge
  animated?: boolean;
  // type?: string; // For custom React Flow edge rendering
}

/**
 * Defines the target node for a specific condition name.
 * Mirrors backend: ConditionalEdgeMapping
 */
export interface FrontendConditionalEdgeMapping {
  conditionName: string; // The name of the condition
  targetNodeId: string;  // The ID of the node to transition to
}

/**
 * Defines conditional outgoing edges for a specific source node.
 * Mirrors backend: ConditionalEdgesDefinition
 */
export interface FrontendConditionalEdgesDef {
  sourceNodeId: string;
  // routerFunctionName?: string; // Name of the router function in backend's ROUTER_IMPLEMENTATIONS
  mappings: FrontendConditionalEdgeMapping[];
}

/**
 * Full definition of a LangGraph workflow for frontend use.
 * Mirrors backend: GraphDefinition
 */
export interface FrontendGraphDef {
  id: string;
  name: string;
  description?: string;
  stateSchemaName: string; // Name of the Pydantic model for LangGraph state
  nodes: FrontendNodeDef[];
  edges: FrontendEdgeDef[];
  conditionalEdges: FrontendConditionalEdgesDef[];
  entryPointNodeId: string;
  terminalNodeIds?: string[];
  version?: number;
  createdAt?: string; // ISO date string
  updatedAt?: string; // ISO date string
}

/**
 * Minimal identifier for a graph definition, used in listings.
 * Mirrors backend: GraphDefinitionIdentifier
 */
export interface GraphDefinitionIdentifierFE {
  id: string;
  name: string;
  updatedAt?: string; // ISO date string
}

/**
 * Response for listing graph definitions.
 * Mirrors backend: GraphDefinitionListResponse
 */
export interface GraphDefinitionListResponseFE {
  graphs: GraphDefinitionIdentifierFE[];
}

/**
 * Request payload for creating a new graph definition.
 * Mirrors backend: CreateGraphRequest
 */
export interface CreateGraphRequestFE extends Omit<FrontendGraphDef, 'id' | 'createdAt' | 'updatedAt' | 'version'> {
  // id, createdAt, updatedAt, version are typically server-generated
}

/**
 * Request payload for updating an existing graph definition.
 * Mirrors backend: UpdateGraphRequest
 */
export interface UpdateGraphRequestFE extends CreateGraphRequestFE {
  // Inherits all fields from CreateGraphRequestFE.
  // The ID of the graph to update is usually passed as a path parameter.
}


// --- WebSocket Event Types (mirroring backend schemas) ---

export type WebSocketEventType =
  | 'graph_execution_start'
  | 'node_start'
  | 'node_end'
  | 'edge_taken' // You might need to infer this or have backend send it explicitly
  | 'graph_execution_end'
  | 'graph_error'
  | 'pong'; // For keep-alive if implemented

export interface WebSocketBaseEventFE {
  eventType: WebSocketEventType;
  timestamp: string; // ISO date string
  executionId: string;
  graphId: string;
}

export interface GraphExecutionStartEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_start';
  inputArgs: Record<string, any>;
}

export interface NodeLifecycleEventFE extends WebSocketBaseEventFE {
  nodeId: string;
  nodeType?: string;
}

export interface NodeStartEventFE extends NodeLifecycleEventFE {
  eventType: 'node_start';
  inputData: Record<string, any>;
}

export interface NodeEndEventFE extends NodeLifecycleEventFE {
  eventType: 'node_end';
  outputData: Record<string, any>;
  status: 'success' | 'failure';
  errorMessage?: string;
  durationMs?: number;
}

export interface EdgeTakenEventFE extends WebSocketBaseEventFE {
  eventType: 'edge_taken';
  sourceNodeId: string;
  targetNodeId: string;
  edgeLabel?: string;
  isConditional: boolean;
}

export interface GraphExecutionEndEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_end';
  finalState: Record<string, any>;
  status: 'completed' | 'failed' | 'interrupted';
  totalDurationMs?: number;
}

export interface GraphErrorEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_error';
  message: string;
  details?: string;
  nodeId?: string;
}

export interface PongEventFE extends Omit<WebSocketBaseEventFE, 'executionId' | 'graphId'> {
    eventType: 'pong';
    serverTime: string;
}

// Union type for all possible incoming WebSocket messages
export type LangGraphExecutionEvent =
  | GraphExecutionStartEventFE
  | NodeStartEventFE
  | NodeEndEventFE
  | EdgeTakenEventFE
  | GraphExecutionEndEventFE
  | GraphErrorEventFE
  | PongEventFE;

// --- HTTP API Request/Response Types for LangGraph Management ---

/**
 * Request to initiate execution of a graph via HTTP (if implemented).
 * Mirrors backend: ExecuteGraphRequest
 */
export interface ExecuteGraphRequestFE {
  inputArgs?: Record<string, any>;
  // configOverrides?: Record<string, any>;
}

/**
 * Response after initiating a graph execution via HTTP.
 * Mirrors backend: ExecuteGraphResponse
 */
export interface ExecuteGraphResponseFE {
  executionId: string;
  message: string;
  websocketUrl?: string;
}

/**
 * Generic message response.
 * Mirrors backend: MessageResponse
 */
export interface MessageResponseFE {
    message: string;
}

// --- React Flow Specific Types (can be extended as needed) ---
// These types are what React Flow expects for its `nodes` and `edges` props.
// We will adapt FrontendNodeDef and FrontendEdgeDef to these.

export interface ReactFlowNodeData {
  label: string;
  // Custom data for rendering or logic
  type?: string; // Original node type from definition
  status?: 'idle' | 'running' | 'success' | 'error' | 'active'; // For visual styling
  config?: Record<string, any>; // Original config for inspection
  inputs?: Record<string, any>; // Last known inputs to this node
  outputs?: Record<string, any>; // Last known outputs from this node
}

export interface ReactFlowEdgeData {
  label?: string;
  // Custom data for rendering or logic
  status?: 'idle' | 'traversed'; // For visual styling
}

// Example of how you might type the nodes and edges for React Flow itself
// import { Node, Edge } from 'reactflow';
// export type LangGraphReactFlowNode = Node<ReactFlowNodeData>;
// export type LangGraphReactFlowEdge = Edge<ReactFlowEdgeData>;

File: src/pages/LoginPage.tsx
import React from 'react';
import { ApiClient } from '../api/types'; 
import '../components/LoginForm';
import LoginForm from '../components/LoginForm';

interface LoginPageProps {
    apiClient: ApiClient;
    onLoginSuccess: () => void;
}

const LoginPage: React.FC<LoginPageProps> = ({ apiClient, onLoginSuccess }) => {
  return (
    <div className="flex items-center justify-center min-h-screen bg-secondary-100">
      <div className="w-full max-w-md px-8 py-10 bg-white shadow-xl rounded-lg">
        <h1 className="text-3xl font-bold text-center text-secondary-900 mb-8">
          Classifier Login
        </h1>
        <LoginForm apiClient={apiClient} onLoginSuccess={onLoginSuccess} />
      </div>
    </div>
  );
};

export default LoginPage;

File: src/langgraph/pages/LangGraphViewPage.tsx
// src/langgraph/pages/LangGraphViewPage.tsx
import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useReactFlow, Controls, Background, MiniMap, BackgroundVariant } from 'reactflow';
import type { Node as ReactFlowNodeUi, Edge as ReactFlowEdgeUi, NodeMouseHandler, EdgeMouseHandler } from 'reactflow';

import { Button, Input, Card, Spin, Alert, Typography, Tooltip, Modal, Row, Col, Tag } from 'antd';
import { PlayCircleOutlined, StopOutlined, EditOutlined, ReloadOutlined, ShareAltOutlined } from '@ant-design/icons';

import { useAuth } from '../../context/AuthContext'; // Adjust path
import { useLangGraphDefinitions } from '../hooks/useLangGraphDefinitions';
import { useLangGraphRunner } from '../hooks/useLangGraphRunner';
import { useReactFlowGraphAdapter } from '../hooks/useReactFlowGraphAdapter';
import { FrontendGraphDef, ReactFlowNodeData, ReactFlowEdgeData } from '../types/langgraph';
import LangGraphCanvas from '../components/LangGraphCanvas';
import NodeInspectorPanel from '../components/NodeInspectorPanel';
// import CustomGraphNode from '../components/CustomGraphNode'; // If using custom nodes
// import CustomGraphEdge from '../components/CustomGraphEdge'; // If using custom edges

// const nodeTypes = { customGraphNode: CustomGraphNode };
// const edgeTypes = { customGraphEdge: CustomGraphEdge };

const { Title, Text, Paragraph } = Typography;
const { TextArea } = Input;

const LangGraphViewPage: React.FC = () => {
  const { graphId } = useParams<{ graphId: string }>();
  const navigate = useNavigate();
  const { apiClient, checkPermission } = useAuth();
  const { fitView } = useReactFlow(); // React Flow hook for controlling the viewport

  // --- State for Graph Definition ---
  const { getGraphDefinition, isLoading: isLoadingDefinition, error: definitionError } = useLangGraphDefinitions(apiClient, '/v1/lg-vis');
  const [graphDefinition, setGraphDefinition] = useState<FrontendGraphDef | null>(null);

  // --- State for React Flow Adaptation & Layout ---
  const {
    nodes: rfNodes,
    edges: rfEdges,
    layoutGraph,
    isLoadingLayout,
    errorLayout,
  } = useReactFlowGraphAdapter();

  // --- State for Graph Execution via WebSocket ---
  const {
    connectAndExecute,
    disconnect,
    // executionEvents, // For logging or advanced display - remove if not used
    currentExecutionId,
    status: executionStatus,
    error: runnerError,
    graphError: executionGraphError,
    currentGraphState, // This is key for styling nodes/edges
  } = useLangGraphRunner(); // Pass baseWsUrl if not default and configured

  // --- UI State ---
  const [initialArgsJson, setInitialArgsJson] = useState<string>('{}');
  const [selectedElement, setSelectedElement] = useState<ReactFlowNodeUi<ReactFlowNodeData> | ReactFlowEdgeUi<ReactFlowEdgeData> | null>(null);
  const [isInspectorPanelOpen, setIsInspectorPanelOpen] = useState<boolean>(false);

  // Fetch graph definition when graphId changes
  useEffect(() => {
    if (graphId) {
      const fetchDef = async () => {
        setSelectedElement(null); // Clear selection when graph changes
        setIsInspectorPanelOpen(false);
        setGraphDefinition(null); // Clear previous definition
        const definition = await getGraphDefinition(graphId);
        if (definition) {
          setGraphDefinition(definition);
        }
        // Error is handled by definitionError state
      };
      fetchDef();
    }
    // Cleanup: disconnect WebSocket if graphId changes or component unmounts
    return () => {
      disconnect();
    };
  }, [graphId, getGraphDefinition, disconnect]);

  // Layout graph when definition is loaded or changes
  useEffect(() => {
    if (graphDefinition) {
      layoutGraph(graphDefinition);
      // Add Controls, Background, MiniMap here if they are part of the layout or canvas setup
      // For example, if LangGraphCanvas takes them as props or if they are added directly
    }
  }, [graphDefinition, layoutGraph]);

  // Fit view when nodes are initially layouted or execution ends/starts
  useEffect(() => {
    if (rfNodes.length > 0) {
      // Timeout to ensure layout has been applied by the browser
      const timer = setTimeout(() => fitView({ duration: 500, padding: 0.1 }), 100);
      return () => clearTimeout(timer);
    }
  }, [rfNodes, fitView, executionStatus]); // Also re-fit on execution status change to recenter


  const handleExecuteGraph = useCallback(() => {
    if (!graphId || !graphDefinition) {
      Modal.error({ title: 'Error', content: 'Graph definition not loaded.' });
      return;
    }
    if (executionStatus === 'running' || executionStatus === 'connecting' || executionStatus === 'starting') {
      Modal.warn({ title: 'In Progress', content: 'Graph is already running or attempting to connect.' });
      return;
    }

    let parsedArgs: Record<string, any> = {};
    try {
      parsedArgs = JSON.parse(initialArgsJson);
    } catch (e) {
      Modal.error({ title: 'Invalid Input', content: 'Initial arguments must be valid JSON.' });
      return;
    }
    connectAndExecute(graphId, parsedArgs /*, optional predefinedExecutionId */);
  }, [graphId, graphDefinition, initialArgsJson, connectAndExecute, executionStatus]);

  const handleStopExecution = useCallback(() => {
    disconnect();
  }, [disconnect]);

  // --- Node and Edge Click Handlers for Inspector ---
  const onNodeClickHandler: NodeMouseHandler = useCallback((_event, node) => {
    const enrichedNodeData: ReactFlowNodeData = {
      ...node.data,
      inputs: currentGraphState.lastInputByNode[node.id],
      outputs: currentGraphState.lastOutputByNode[node.id],
    };
    setSelectedElement({ ...node, data: enrichedNodeData });
    setIsInspectorPanelOpen(true);
  }, [currentGraphState]);

  const onEdgeClickHandler: EdgeMouseHandler = useCallback((_event, edge) => {
    setSelectedElement(edge);
    setIsInspectorPanelOpen(true);
  }, []);

  const closeInspectorPanel = useCallback(() => {
    setIsInspectorPanelOpen(false);
    setSelectedElement(null); // Deselect
  }, []);

  // --- Memoized Nodes and Edges with Dynamic Styling from Execution State ---
  const styledNodes = useMemo(() => {
    return rfNodes.map(node => {
      const data = node.data as ReactFlowNodeData;
      let newStatus: ReactFlowNodeData['status'] = 'idle';

      if (currentGraphState.activeNodeIds.has(node.id)) newStatus = 'running';
      else if (currentGraphState.errorNodeIds.has(node.id)) newStatus = 'error';
      else if (currentGraphState.completedNodeIds.has(node.id)) newStatus = 'success';
      else if (selectedElement?.id === node.id) newStatus = 'active';

      return { ...node, data: { ...data, status: newStatus } };
    });
  }, [rfNodes, currentGraphState, selectedElement]);

  const styledEdges = useMemo(() => {
    return rfEdges.map(edge => {
      const data = edge.data as ReactFlowEdgeData;
      // Construct edge ID like "source__target" or "source__target__label" if that's how you store it
      const edgeKeyForTraversalCheck = `${edge.source}__${edge.target}` + (edge.label ? `__${edge.label}` : '');
      const isTraversed = currentGraphState.traversedEdgeIds.has(edgeKeyForTraversalCheck);

      return {
        ...edge,
        animated: isTraversed && (executionStatus === 'running' || executionStatus === 'starting'),
        data: { ...data, status: isTraversed ? 'traversed' : 'idle' } as ReactFlowEdgeData,
        // Style can be set directly here, or better, handled by CustomGraphEdge based on data.status
      };
    });
  }, [rfEdges, currentGraphState, executionStatus]);


  // --- Render Logic ---
  if (isLoadingDefinition || (!graphDefinition && !definitionError && graphId)) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 'calc(100vh - 100px)' }}>
        <Spin size="large" tip={`Loading graph definition for ${graphId}...`} />
      </div>
    );
  }

  if (definitionError) {
    return (
      <div className="page-container">
        <Alert message="Error Loading Graph Definition" description={definitionError} type="error" showIcon />
        <Button onClick={() => navigate('/langgraph')} style={{ marginTop: '16px' }}>Back to List</Button>
      </div>
    );
  }

  if (!graphDefinition) {
    return (
      <div className="page-container">
        <Alert message="Graph Not Found" description={`Could not find graph definition for ID: ${graphId}`} type="warning" showIcon />
         <Button onClick={() => navigate('/langgraph')} style={{ marginTop: '16px' }}>Back to List</Button>
      </div>
    );
  }

  return (
    <div className="page-container" style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 64px)', /* Adjust based on your app's header height */ }}>
      <Card
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Title level={3} style={{ margin: 0, display: 'flex', alignItems: 'center' }}>
              <ShareAltOutlined style={{ marginRight: '10px' }} />
              {graphDefinition.name}
              <Text type="secondary" style={{ marginLeft: '10px', fontSize: '0.9em' }}>(ID: {graphDefinition.id})</Text>
            </Title>
            {checkPermission('langgraph:edit') && !graphDefinition.id.startsWith('static_') && (
                <Tooltip title="Edit Graph Definition">
                    <Button
                        icon={<EditOutlined />}
                        onClick={() => navigate(`/langgraph/edit/${graphId}`)} // Assuming an edit route
                    >
                        Edit
                    </Button>
                </Tooltip>
            )}
          </div>
        }
        bordered={false}
        style={{ marginBottom: '16px' }}
      >
        {graphDefinition.description && <Paragraph type="secondary">{graphDefinition.description}</Paragraph>}
        <Row gutter={16} align="bottom">
          <Col flex="auto">
            <Text strong>Initial Arguments (JSON):</Text>
            <TextArea
              rows={3}
              value={initialArgsJson}
              onChange={(e) => setInitialArgsJson(e.target.value)}
              placeholder='e.g., {"input": "User query here..."}'
              disabled={executionStatus === 'running' || executionStatus === 'starting'}
              style={{ fontFamily: 'monospace', fontSize: '12px' }}
            />
          </Col>
          <Col>
            {executionStatus !== 'running' && executionStatus !== 'starting' ? (
              <Tooltip title="Start graph execution">
                <Button
                  type="primary"
                  icon={<PlayCircleOutlined />}
                  onClick={handleExecuteGraph}
                  loading={executionStatus === 'connecting'}
                  disabled={!checkPermission('langgraph:execute')} // Example permission
                >
                  Execute
                </Button>
              </Tooltip>
            ) : (
              <Tooltip title="Stop graph execution">
                <Button
                  type="default"
                  danger
                  icon={<StopOutlined />}
                  onClick={handleStopExecution}
                >
                  Stop
                </Button>
              </Tooltip>
            )}
          </Col>
           <Col>
                <Tooltip title="Reload graph definition and reset layout">
                    <Button
                        icon={<ReloadOutlined />}
                        onClick={() => {
                            disconnect(); // Stop any current execution
                            if(graphId) getGraphDefinition(graphId).then(def => def && setGraphDefinition(def));
                        }}
                        disabled={isLoadingDefinition || isLoadingLayout}
                    >
                        Reload Graph
                    </Button>
                </Tooltip>
            </Col>
        </Row>
        <div style={{ marginTop: '12px', display: 'flex', alignItems: 'center', gap: '16px' }}>
            <Text>Execution Status: <Tag color={
                executionStatus === 'running' || executionStatus === 'starting' ? 'blue' :
                executionStatus === 'completed' ? 'green' :
                executionStatus === 'error' ? 'red' :
                executionStatus === 'connecting' ? 'geekblue' :
                'default'
            }>{executionStatus.toUpperCase()}</Tag></Text>
            {currentExecutionId && <Text type="secondary" style={{fontSize: '0.8em'}}>Run ID: <Text copyable code style={{fontSize: '1em'}}>{currentExecutionId}</Text></Text>}
        </div>
        {runnerError && <Alert message="Connection Error" description={runnerError} type="error" showIcon style={{marginTop: '8px'}} />}
        {executionGraphError && (
          <Alert
            message={`Graph Execution Error (Node: ${executionGraphError.nodeId || 'Unknown'})`}
            description={executionGraphError.message + (executionGraphError.details ? ` | Details: ${executionGraphError.details}` : '')}
            type="error"
            showIcon
            style={{marginTop: '8px'}}
          />
        )}
      </Card>

      <div style={{ display: 'flex', flexGrow: 1, height: '100%', overflow: 'hidden' }}>
        <div style={{ flexGrow: 1, height: '100%', position: 'relative' /* For React Flow */ }}>
          {isLoadingLayout ? (
             <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                <Spin size="large" tip="Applying graph layout..." />
             </div>
          ) : errorLayout ? (
            <Alert message="Layout Error" description={errorLayout} type="error" showIcon />
          ) : (
            <>
              <LangGraphCanvas
                nodes={styledNodes}
                edges={styledEdges}
                onNodeClick={onNodeClickHandler}
                onEdgeClick={onEdgeClickHandler}
                // Pass nodeTypes and edgeTypes if you have CustomGraphNode/CustomGraphEdge
                // nodeTypes={nodeTypes}
                // edgeTypes={edgeTypes}
              />
              <Controls />
              <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
              <MiniMap nodeStrokeWidth={3} zoomable pannable />
            </>
          )}
        </div>
        {isInspectorPanelOpen && (
          <div style={{ width: '320px', minWidth: '280px', height: '100%', borderLeft: '1px solid #f0f0f0', backgroundColor: '#ffffff' }}>
            <NodeInspectorPanel
              selectedElement={selectedElement}
              onClose={closeInspectorPanel}
            />
          </div>
        )}
      </div>
    </div>
  );
};

export default LangGraphViewPage;

File: src/pages/SettingsPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { ApiClient, LlmConfig, UpdateConfigRequest } from '../api/types';
import SettingsTab from '../components/Settings/SettingsTab';
import { useAuth } from '../context/AuthContext';
import { Button, Spin, Alert, message, Form } from 'antd';
import { EditOutlined, SaveOutlined, CloseOutlined } from '@ant-design/icons';

interface SettingsPageProps {
  apiClient: ApiClient;
}

const SettingsPage: React.FC<SettingsPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  const [form] = Form.useForm(); // Create form instance here

  const [config, setConfig] = useState<LlmConfig | null>(null);
  const [loading, setLoading] = useState(true); // Loading state for initial fetch
  const [saving, setSaving] = useState(false); // Separate state for saving operation
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);

  const canView = checkPermission('config:view');
  const canUpdate = checkPermission('config:update');

  const loadConfig = useCallback(async () => {
    if (!canView) {
        setLoading(false);
        return; // Don't load if user can't view
    }
    setLoading(true);
    setError(null);
    try {
      const fetchedConfig = await apiClient.getConfig();
      setConfig(fetchedConfig);
      form.resetFields(); // Reset form when new config is loaded
    } catch (err) {
      console.error('Failed to load settings:', err);
      setError(err instanceof Error ? err.message : 'Failed to load configuration');
      setConfig(null);
    } finally {
      setLoading(false);
    }
  }, [apiClient, canView, form]); // Add form dependency

  useEffect(() => {
    loadConfig();
  }, [loadConfig]); // Reload if loadConfig changes

  const handleEdit = () => {
    if (canUpdate) {
      setIsEditing(true);
      // Form initialization happens in SettingsTab's useEffect
    }
  };

  const handleCancel = () => {
    setIsEditing(false);
    form.resetFields(); // Reset form to initial values on cancel
    message.info('Changes discarded.');
  };

  // This function will be called by SettingsTab's Form onFinish
  const handleSave = async () => {
    if (!canUpdate) return;
    setSaving(true);
    setError(null);
    try {
      const formValues = await form.validateFields();

      // Construct the UpdateConfigRequest payload
      // Only include sections that have changed or contain updatable fields
      const updatePayload: UpdateConfigRequest = {};

      // Helper function to prune unchanged/sensitive fields before sending
      const buildUpdateSection = (sectionKey: keyof LlmConfig, formSectionValues: any) => {
        if (!formSectionValues || typeof formSectionValues !== 'object') return null;
        const originalSection = config?.[sectionKey] as any;
        const updateSection: any = {};
        let hasChanges = false;

        Object.keys(formSectionValues).forEach(key => {
          const fullKey = `${sectionKey}.${key}`;
          const newValue = formSectionValues[key];
          const originalValue = originalSection?.[key];

          // Special handling for sensitive fields: only include if non-empty
          if (['llmApiKey', 'smtpPassword'].includes(key)) {
            if (newValue && typeof newValue === 'string' && newValue.trim() !== '') {
              updateSection[key] = newValue.trim();
              hasChanges = true;
              console.log(`[SAVE] Including updated sensitive field: ${fullKey}`);
            } else {
              console.log(`[SAVE] Skipping empty/unchanged sensitive field: ${fullKey}`);
            }
          } else if (newValue !== originalValue) {
            // Basic change detection (might need deep compare for objects/arrays)
            updateSection[key] = newValue;
            hasChanges = true;
            console.log(`[SAVE] Field changed: ${fullKey}`, { from: originalValue, to: newValue });
          } else {
            console.log(`[SAVE] Field unchanged: ${fullKey}`);
          }
        });
        return hasChanges ? updateSection : null;
      };

      // Iterate through top-level keys present in the form
      const topLevelKeys = ['server', 'service', 'database', 'auth', 'validation', 'alert'] as const; // Add all keys
      topLevelKeys.forEach(key => {
        if (formValues[key]) {
          const updateSectionData = buildUpdateSection(key, formValues[key]);
          if (updateSectionData) {
            updatePayload[key] = updateSectionData;
          }
        }
      });

      if (Object.keys(updatePayload).length === 0) {
        message.info('No changes detected to save.');
        setIsEditing(false); // Exit edit mode if no changes
        setSaving(false);
        return;
      }

      console.log("Submitting update payload:", updatePayload); // Log the final payload

      await apiClient.updateConfig(updatePayload);
      message.success('Configuration updated successfully!');
      setIsEditing(false);
      await loadConfig(); // Reload config to show persisted values

    } catch (err) {
      console.error('Failed to save settings:', err);
      setError(err instanceof Error ? err.message : 'Failed to save configuration');
      message.error(`Save failed: ${err instanceof Error ? err.message : 'Unknown error'}`);
      // Keep form values on error so user can fix them
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="page-container">
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-semibold text-secondary-900">Settings</h1>
          <p className="text-secondary-600">
            {isEditing ? 'Modify' : 'View'} application and service configuration.
          </p>
        </div>
        {canView && ( // Show buttons only if user can view
          <div className="flex space-x-2">
            {isEditing ? (
              <>
                <Button
                  icon={<CloseOutlined />}
                  onClick={handleCancel}
                  disabled={saving}
                >
                  Cancel
                </Button>
                <Button
                  type="primary"
                  icon={<SaveOutlined />}
                  onClick={() => form.submit()} // Trigger form submission via AntD form instance
                  loading={saving}
                  disabled={!canUpdate} // Also disable if user lost update permission while editing
                >
                  Save Changes
                </Button>
              </>
            ) : (
              <Button
                icon={<EditOutlined />}
                onClick={handleEdit}
                disabled={loading || !canUpdate} // Disable if loading or no update permission
                title={!canUpdate ? "Permission denied to edit settings" : "Edit Settings"}
              >
                Edit
              </Button>
            )}
          </div>
        )}
      </div>

      {/* Permission Warning */}
      {!canView ? (
        <Alert
          message="Permission Denied"
          description="You don't have permission to view configuration settings. Please contact your administrator."
          type="warning"
          showIcon
        />
      ) : loading ? (
          <div className="flex justify-center items-center py-10">
            <Spin size="large" tip="Loading configuration..." />
          </div>
      ) : error ? (
         <Alert
             message="Error Loading Configuration"
             description={error}
             type="error"
             showIcon
             closable
             onClose={() => setError(null)}
             className="mb-4"
           />
      ) : (
        // Pass relevant state and handlers to SettingsTab
        <SettingsTab
          apiClient={apiClient}
          isEditing={isEditing}
          onSave={handleSave} // Pass the save handler
          form={form} // Pass the form instance
          initialConfig={config} // Pass the loaded config
          loading={saving} // Indicate loading state during save
          error={error} // Pass error to potentially display within tabs
        />
      )}
       {/* Display persistent errors from save below the tabs */}
       {error && !loading && (
           <Alert
             message="Save Error"
             description={error}
             type="error"
             showIcon
             closable
             onClose={() => setError(null)}
             className="mt-4"
           />
        )}
    </div>
  );
};

export default SettingsPage;

File: src/langgraph/services/langGraphApiService.ts
/**
 * Represents the UI position of a node for visualization.
 * Mirrors backend: NodeUIPosition
 */
export interface UINodePosition {
  x: number;
  y: number;
}

/**
 * Defines a single node in the graph structure for frontend use.
 * Mirrors backend: NodeDefinition
 */
export interface FrontendNodeDef {
  id: string;
  type: string; // Maps to backend logic (e.g., 'llm_node', 'tool_node')
  config: Record<string, any>; // Configuration specific to this node type
  uiPosition?: UINodePosition; // Optional UI positioning
  // Frontend-specific display properties can be added here if needed
  // e.g., customData?: { label?: string; icon?: string; status?: 'running' | 'completed' | 'error' };
}

/**
 * Defines a directed edge between two nodes for frontend use.
 * Mirrors backend: EdgeDefinition
 */
export interface FrontendEdgeDef {
  id: string;
  source: string; // ID of the source node
  target: string; // ID of the target node
  label?: string; // Optional label for the edge
  animated?: boolean;
  // type?: string; // For custom React Flow edge rendering
}

/**
 * Defines the target node for a specific condition name.
 * Mirrors backend: ConditionalEdgeMapping
 */
export interface FrontendConditionalEdgeMapping {
  conditionName: string; // The name of the condition
  targetNodeId: string;  // The ID of the node to transition to
}

/**
 * Defines conditional outgoing edges for a specific source node.
 * Mirrors backend: ConditionalEdgesDefinition
 */
export interface FrontendConditionalEdgesDef {
  sourceNodeId: string;
  // routerFunctionName?: string; // Name of the router function in backend's ROUTER_IMPLEMENTATIONS
  mappings: FrontendConditionalEdgeMapping[];
}

/**
 * Full definition of a LangGraph workflow for frontend use.
 * Mirrors backend: GraphDefinition
 */
export interface FrontendGraphDef {
  id: string;
  name: string;
  description?: string;
  stateSchemaName: string; // Name of the Pydantic model for LangGraph state
  nodes: FrontendNodeDef[];
  edges: FrontendEdgeDef[];
  conditionalEdges: FrontendConditionalEdgesDef[];
  entryPointNodeId: string;
  terminalNodeIds?: string[];
  version?: number;
  createdAt?: string; // ISO date string
  updatedAt?: string; // ISO date string
}

/**
 * Minimal identifier for a graph definition, used in listings.
 * Mirrors backend: GraphDefinitionIdentifier
 */
export interface GraphDefinitionIdentifierFE {
  id: string;
  name: string;
  updatedAt?: string; // ISO date string
}

/**
 * Response for listing graph definitions.
 * Mirrors backend: GraphDefinitionListResponse
 */
export interface GraphDefinitionListResponseFE {
  graphs: GraphDefinitionIdentifierFE[];
}

/**
 * Request payload for creating a new graph definition.
 * Mirrors backend: CreateGraphRequest
 */
export interface CreateGraphRequestFE extends Omit<FrontendGraphDef, 'id' | 'createdAt' | 'updatedAt' | 'version'> {
  // id, createdAt, updatedAt, version are typically server-generated
}

/**
 * Request payload for updating an existing graph definition.
 * Mirrors backend: UpdateGraphRequest
 */
export interface UpdateGraphRequestFE extends CreateGraphRequestFE {
  // Inherits all fields from CreateGraphRequestFE.
  // The ID of the graph to update is usually passed as a path parameter.
}


// --- WebSocket Event Types (mirroring backend schemas) ---

export type WebSocketEventType =
  | 'graph_execution_start'
  | 'node_start'
  | 'node_end'
  | 'edge_taken' // You might need to infer this or have backend send it explicitly
  | 'graph_execution_end'
  | 'graph_error'
  | 'pong'; // For keep-alive if implemented

export interface WebSocketBaseEventFE {
  eventType: WebSocketEventType;
  timestamp: string; // ISO date string
  executionId: string;
  graphId: string;
}

export interface GraphExecutionStartEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_start';
  inputArgs: Record<string, any>;
}

export interface NodeLifecycleEventFE extends WebSocketBaseEventFE {
  nodeId: string;
  nodeType?: string;
}

export interface NodeStartEventFE extends NodeLifecycleEventFE {
  eventType: 'node_start';
  inputData: Record<string, any>;
}

export interface NodeEndEventFE extends NodeLifecycleEventFE {
  eventType: 'node_end';
  outputData: Record<string, any>;
  status: 'success' | 'failure';
  errorMessage?: string;
  durationMs?: number;
}

export interface EdgeTakenEventFE extends WebSocketBaseEventFE {
  eventType: 'edge_taken';
  sourceNodeId: string;
  targetNodeId: string;
  edgeLabel?: string;
  isConditional: boolean;
}

export interface GraphExecutionEndEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_end';
  finalState: Record<string, any>;
  status: 'completed' | 'failed' | 'interrupted';
  totalDurationMs?: number;
}

export interface GraphErrorEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_error';
  message: string;
  details?: string;
  nodeId?: string;
}

export interface PongEventFE extends Omit<WebSocketBaseEventFE, 'executionId' | 'graphId'> {
    eventType: 'pong';
    serverTime: string;
}

// Union type for all possible incoming WebSocket messages
export type LangGraphExecutionEvent =
  | GraphExecutionStartEventFE
  | NodeStartEventFE
  | NodeEndEventFE
  | EdgeTakenEventFE
  | GraphExecutionEndEventFE
  | GraphErrorEventFE
  | PongEventFE;

// --- HTTP API Request/Response Types for LangGraph Management ---

/**
 * Request to initiate execution of a graph via HTTP (if implemented).
 * Mirrors backend: ExecuteGraphRequest
 */
export interface ExecuteGraphRequestFE {
  inputArgs?: Record<string, any>;
  // configOverrides?: Record<string, any>;
}

/**
 * Response after initiating a graph execution via HTTP.
 * Mirrors backend: ExecuteGraphResponse
 */
export interface ExecuteGraphResponseFE {
  executionId: string;
  message: string;
  // statusUrl?: string; // URL to poll for status if not using WebSockets
}

/**
 * Generic message response from the API.
 */
export interface MessageResponseFE {
  message: string;
  details?: any;
}

import { ApiClient } from '../../api/types';

// --- LangGraphApiService Class ---
export class LangGraphApiService {
  private apiClient: ApiClient;
  private basePath: string;

  constructor(apiClient: ApiClient, basePath: string = '/v1/lg-vis') {
    this.apiClient = apiClient;
    // Ensure basePath starts with a slash but doesn't end with one
    this.basePath = basePath.startsWith('/') ? basePath : `/${basePath}`;
    if (this.basePath.endsWith('/')) {
      this.basePath = this.basePath.slice(0, -1);
    }
    console.log(`[LangGraphApiService] Initialized with basePath: ${this.basePath}`);
  }

  /**
   * Builds a URL combining the base path with the provided endpoint.
   * Ensures no duplicate slashes between segments.
   * 
   * @param endpoint The API endpoint without the base path
   * @returns The full URL path including the base path
   */
  private buildUrl(endpoint: string): string {
    const cleanEndpoint = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
    return `${this.basePath}/${cleanEndpoint}`;
  }

  /**
   * Makes a GET request to the API.
   */
  private async get<T = any>(endpoint: string, params?: Record<string, any>): Promise<T> {
    const url = this.buildUrl(endpoint);
    
    console.log(`[LangGraphApiService] Making GET request to: ${url}`, params);
    try {
      const response = await this.apiClient.get(url, params);
      return response;
    } catch (error) {
      console.error(`[LangGraphApiService] Error making GET request to: ${url}`, error);
      throw error;
    }
  }

  /**
   * Makes a POST request to the API.
   */
  private async post<T = any>(endpoint: string, data: any): Promise<T> {
    const url = this.buildUrl(endpoint);
    
    console.log(`[LangGraphApiService] Making POST request to: ${url}`);
    try {
      const response = await this.apiClient.post(url, data);
      return response;
    } catch (error) {
      console.error(`[LangGraphApiService] Error making POST request to: ${url}`, error);
      throw error;
    }
  }

  /**
   * Makes a PUT request to the API.
   */
  private async put<T = any>(endpoint: string, data: any): Promise<T> {
    const url = this.buildUrl(endpoint);
    
    console.log(`[LangGraphApiService] Making PUT request to: ${url}`);
    try {
      const response = await this.apiClient.put(url, data);
      return response;
    } catch (error) {
      console.error(`[LangGraphApiService] Error making PUT request to: ${url}`, error);
      throw error;
    }
  }

  /**
   * Makes a DELETE request to the API.
   */
  private async delete<T = any>(endpoint: string): Promise<T> {
    const url = this.buildUrl(endpoint);
    
    console.log(`[LangGraphApiService] Making DELETE request to: ${url}`);
    try {
      const response = await this.apiClient.delete(url);
      return response;
    } catch (error) {
      console.error(`[LangGraphApiService] Error making DELETE request to: ${url}`, error);
      throw error;
    }
  }
  // Public API methods that use the utility methods above

  async listGraphDefinitions(includeStatic: boolean = false): Promise<GraphDefinitionListResponseFE> {
    return this.get<GraphDefinitionListResponseFE>('graphs', { include_static: includeStatic });
  }

  async getGraphDefinition(graphId: string): Promise<FrontendGraphDef> {
    return this.get<FrontendGraphDef>(`graphs/${graphId}`);
  }

  async createGraphDefinition(data: CreateGraphRequestFE): Promise<FrontendGraphDef> {
    // Convert camelCase keys to snake_case for Python backend
    const transformedData = {
      name: data.name,
      description: data.description,
      state_schema_name: data.stateSchemaName,
      entry_point_node_id: data.entryPointNodeId,
      nodes: data.nodes.map(node => ({
        id: node.id,
        type: node.type,
        config: node.config,
        ui_position: node.uiPosition ? {
          x: node.uiPosition.x,
          y: node.uiPosition.y
        } : undefined
      })),
      edges: data.edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        label: edge.label,
        animated: edge.animated
      })),
      conditional_edges: data.conditionalEdges.map(condEdge => ({
        source_node_id: condEdge.sourceNodeId,
        mappings: condEdge.mappings.map(mapping => ({
          condition_name: mapping.conditionName,
          target_node_id: mapping.targetNodeId
        }))
      })),
      terminal_node_ids: data.terminalNodeIds
    };

    return this.post<FrontendGraphDef>('graphs', transformedData);
  }

  async updateGraphDefinition(graphId: string, data: UpdateGraphRequestFE): Promise<FrontendGraphDef> {
    // Convert camelCase keys to snake_case for Python backend
    const transformedData = {
      name: data.name,
      description: data.description,
      state_schema_name: data.stateSchemaName,
      entry_point_node_id: data.entryPointNodeId,
      nodes: data.nodes.map(node => ({
        id: node.id,
        type: node.type,
        config: node.config,
        ui_position: node.uiPosition ? {
          x: node.uiPosition.x,
          y: node.uiPosition.y
        } : undefined
      })),
      edges: data.edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        label: edge.label,
        animated: edge.animated
      })),
      conditional_edges: data.conditionalEdges.map(condEdge => ({
        source_node_id: condEdge.sourceNodeId,
        mappings: condEdge.mappings.map(mapping => ({
          condition_name: mapping.conditionName,
          target_node_id: mapping.targetNodeId
        }))
      })),
      terminal_node_ids: data.terminalNodeIds
    };
    
    return this.put<FrontendGraphDef>(`graphs/${graphId}`, transformedData);
  }

  async deleteGraphDefinition(graphId: string): Promise<MessageResponseFE> {
    return this.delete<MessageResponseFE>(`graphs/${graphId}`);
  }

  // Placeholder for HTTP execution if needed, otherwise remove
  async executeGraph(graphId: string, request: ExecuteGraphRequestFE): Promise<ExecuteGraphResponseFE> {
    return this.post<ExecuteGraphResponseFE>(`graphs/${graphId}/execute`, request);
  }
}

File: src/langgraph/components/NodeInspectorPanel.tsx
// src/langgraph/components/NodeInspectorPanel.tsx
import React from 'react';
import { Node as ReactFlowNode, Edge as ReactFlowEdge } from 'reactflow';
import { ReactFlowNodeData, ReactFlowEdgeData } from '../types/langgraph';
import { Button, Descriptions, Empty, Tag, Card, Typography, Tooltip } from 'antd'; // Using Ant Design components
import { InfoCircleOutlined } from '@ant-design/icons';

const { Text, Paragraph } = Typography;

interface NodeInspectorPanelProps {
  selectedElement: ReactFlowNode<ReactFlowNodeData> | ReactFlowEdge<ReactFlowEdgeData> | null;
  onClose: () => void; // Callback to close the panel
  // You might also pass node-specific data from execution state if needed
  // For example: lastInput?: any; lastOutput?: any;
}

const JsonViewer: React.FC<{ data: any; title?: string }> = ({ data, title }) => {
  if (data === undefined || data === null || Object.keys(data).length === 0) {
    return <Text type="secondary" italic>{title ? `${title}: Not available` : 'Not available'}</Text>;
  }
  try {
    return (
      <div style={{ marginTop: '8px' }}>
        {title && <Text strong className="text-sm">{title}:</Text>}
        <pre
          style={{
            background: '#f0f2f5', // Ant Design background color
            border: '1px solid #d9d9d9', // Ant Design border color
            borderRadius: '4px',
            padding: '8px',
            fontSize: '12px',
            maxHeight: '200px',
            overflowY: 'auto',
            whiteSpace: 'pre-wrap', // Ensure wrapping
            wordBreak: 'break-all', // Break long words/strings
          }}
        >
          {JSON.stringify(data, null, 2)}
        </pre>
      </div>
    );
  } catch (e) {
    return <Text type="danger" italic>{title ? `${title}: Error displaying data` : 'Error displaying data'}</Text>;
  }
};

const NodeInspectorPanel: React.FC<NodeInspectorPanelProps> = ({
  selectedElement,
  onClose,
}) => {
  if (!selectedElement) {
    return (
      <div style={{ padding: '16px', borderLeft: '1px solid #e8e8e8', height: '100%' }}>
        <Empty description="Select a node or edge to see details" image={Empty.PRESENTED_IMAGE_SIMPLE} />
      </div>
    );
  }

  const isNode = 'data' in selectedElement && 'position' in selectedElement; // Basic check for Node type
  const data = selectedElement.data as ReactFlowNodeData | ReactFlowEdgeData; // Type assertion

  return (
    <Card
      title={
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          {isNode ? 'Node Details' : 'Edge Details'}
          <Button type="text" onClick={onClose} size="small">
            Close
          </Button>
        </div>
      }
      style={{ height: '100%', display: 'flex', flexDirection: 'column', borderLeft: '1px solid #f0f0f0' }}
      bodyStyle={{ flexGrow: 1, overflowY: 'auto', padding: '16px' }}
      size="small"
    >
      <Descriptions bordered column={1} size="small" layout="horizontal">
        <Descriptions.Item label="ID">
          <Text copyable style={{ fontFamily: 'monospace' }}>{selectedElement.id}</Text>
        </Descriptions.Item>

        {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.type && (
          <Descriptions.Item label="Type">
            <Tag color="blue">{(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.type}</Tag>
          </Descriptions.Item>
        )}

        {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status && (
          <Descriptions.Item label="Status">
            <Tag
              color={
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'running' ? 'gold' :
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'success' ? 'green' :
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'error' ? 'red' :
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'active' ? 'processing' :
                'default'
              }
            >
              {(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status?.toUpperCase()}
            </Tag>
          </Descriptions.Item>
        )}

        {!isNode && (data as ReactFlowEdgeData).label && (
          <Descriptions.Item label="Label">
            <Text>{(data as ReactFlowEdgeData).label}</Text>
          </Descriptions.Item>
        )}
         {!isNode && (data as ReactFlowEdgeData).status && (
          <Descriptions.Item label="Status">
             <Tag color={(data as ReactFlowEdgeData).status === 'traversed' ? 'green' : 'default'}>
                {(data as ReactFlowEdgeData).status?.toUpperCase()}
             </Tag>
          </Descriptions.Item>
        )}
      </Descriptions>

      {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.config && (
        <JsonViewer data={(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.config} title="Configuration" />
      )}

      {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.inputs && (
        <JsonViewer data={(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.inputs} title="Last Inputs" />
      )}

      {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.outputs && (
        <JsonViewer data={(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.outputs} title="Last Outputs" />
      )}

      {/* Raw Data for Debugging - can be behind a toggle */}
      <details style={{ marginTop: '16px', cursor: 'pointer' }}>
        <summary style={{ fontSize: '12px', color: '#888' }}>
            <Tooltip title="View raw element data for debugging">
                <InfoCircleOutlined style={{marginRight: '4px'}} />
                Raw Data
            </Tooltip>
        </summary>
        <JsonViewer data={selectedElement} />
      </details>

    </Card>
  );
};

export default NodeInspectorPanel;

File: src/langgraph/pages/LangGraphListPage.tsx
// src/langgraph/pages/LangGraphListPage.tsx
import React, { useEffect, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Adjust path as needed
import { useLangGraphDefinitions } from '../hooks/useLangGraphDefinitions';
import { Button, List, Card, Typography, Spin, Alert, Tag, Empty, Tooltip, Switch } from 'antd';
import { PlusOutlined, EyeOutlined, EditOutlined, DeleteOutlined, ShareAltOutlined } from '@ant-design/icons';
import { formatDate } from '../../utils/dateFormat'; // Your existing date formatter

const { Title, Text, Paragraph } = Typography;

const LangGraphListPage: React.FC = () => {
  const { apiClient, checkPermission } = useAuth(); // Get apiClient and permission checker
  const {
    graphDefinitions,
    isLoading,
    error,
    fetchGraphDefinitions,
    deleteGraphDefinition,
  } = useLangGraphDefinitions(apiClient, '/v1/lg-vis'); // Pass the apiClient and explicitly set the prefix
  const navigate = useNavigate();
  const [includeStatic, setIncludeStatic] = useState<boolean>(true);

  useEffect(() => {
    // Fetch definitions (including static ones if you want them listed here)
    // Set includeStatic to true if your listGraphDefinitions API and hook support it.
    fetchGraphDefinitions(includeStatic);
    
    // Clean up any pending requests
    return () => {
      // Any cleanup code if needed
    };
  }, [fetchGraphDefinitions, includeStatic]); // Add includeStatic as a dependency

  const handleDelete = async (graphId: string, graphName: string) => {
    if (!checkPermission('langgraph:delete')) { // Example permission
      alert('Permission denied to delete graph definitions.');
      return;
    }
    if (window.confirm(`Are you sure you want to delete the graph "${graphName}" (ID: ${graphId})? This action cannot be undone.`)) {
      const success = await deleteGraphDefinition(graphId);
      if (success) {
        // The list should refresh automatically due to the hook's logic
        alert(`Graph "${graphName}" deleted successfully.`);
      } else {
        // Error is handled by the hook and displayed
        alert(`Failed to delete graph "${graphName}".`);
      }
    }
  };

  const handleCreateNew = () => {
     if (!checkPermission('langgraph:create')) { // Example permission
       alert('Permission denied to create graph definitions.');
       return;
     }
    // Navigate to a create page or open a modal
    navigate('/langgraph/create'); // Assuming you have a LangGraphCreatePage
  };

  if (isLoading && graphDefinitions.length === 0) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 'calc(100vh - 150px)' }}>
        <Spin size="large" tip="Loading graph definitions..." />
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ padding: '20px' }}>
        <Alert message="Error Loading Graph Definitions" description={error} type="error" showIcon />
        <Button onClick={() => fetchGraphDefinitions(true)} style={{ marginTop: '16px' }}>
          Retry
        </Button>
      </div>
    );
  }

  return (
    <div className="page-container" style={{ maxWidth: '1200px', margin: '0 auto' }}>
      <Card
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Title level={2} style={{ margin: 0 }}>
              <ShareAltOutlined style={{ marginRight: '12px' }} />
              Agentic Workflows (Graphs)
            </Title>
            {checkPermission('langgraph:create') && (
              <Button type="primary" icon={<PlusOutlined />} onClick={handleCreateNew}>
                Create New Graph
              </Button>
            )}
          </div>
        }
        bordered={false}
      >        <Paragraph type="secondary">
          Manage and explore your automated agentic workflows powered by LangGraph.
          Each graph represents a sequence of operations that can be executed and visualized.
        </Paragraph>

        <div style={{ marginBottom: 16, display: 'flex', alignItems: 'center' }}>
          <Switch 
            checked={includeStatic} 
            onChange={(checked) => setIncludeStatic(checked)} 
            style={{ marginRight: 8 }}
          />
          <Text type="secondary">Include Static Graphs</Text>
          {isLoading && <Spin size="small" style={{ marginLeft: 16 }} />}
        </div>

        {graphDefinitions.length === 0 && !isLoading ? (
          <Empty description="No graph definitions found. Create one to get started!" style={{marginTop: '40px'}}>
            {checkPermission('langgraph:create') && (
                <Button type="primary" icon={<PlusOutlined />} onClick={handleCreateNew}>
                    Create Your First Graph
                </Button>
            )}
          </Empty>
        ) : (
          <List
            itemLayout="horizontal"
            dataSource={graphDefinitions}
            loading={isLoading} // Show loading indicator on list if fetching in background
            renderItem={(item) => {
              const isStatic = item.id.startsWith('static_');
              return (
                <List.Item
                  actions={[
                    <Tooltip title="View/Execute Graph" key="view">
                      <Link to={`/langgraph/view/${item.id}`}>
                        <Button icon={<EyeOutlined />} type="text" shape="circle" />
                      </Link>
                    </Tooltip>,
                    ...(checkPermission('langgraph:edit') && !isStatic ? [ // Assuming edit for non-static graphs
                      <Tooltip title="Edit Graph Definition" key="edit">
                         {/* Link to an edit page or open an edit modal */}
                         <Link to={`/langgraph/edit/${item.id}`}>
                            <Button icon={<EditOutlined />} type="text" shape="circle" />
                         </Link>
                      </Tooltip>
                    ] : []),
                    ...(checkPermission('langgraph:delete') && !isStatic ? [ // Prevent deleting static graphs via UI
                      <Tooltip title="Delete Graph" key="delete">
                        <Button
                          icon={<DeleteOutlined />}
                          type="text"
                          danger
                          shape="circle"
                          onClick={() => handleDelete(item.id, item.name)}
                        />
                      </Tooltip>
                    ] : []),
                  ]}
                >
                  <List.Item.Meta
                    avatar={<ShareAltOutlined style={{ fontSize: '24px', color: isStatic ? '#1677ff' : '#52c41a' }} />}
                    title={<Link to={`/langgraph/view/${item.id}`} style={{ fontSize: '1.1em' }}>{item.name}</Link>}
                    description={
                      <>
                        <Text type="secondary" style={{ display: 'block' }}>ID: <Text copyable code style={{fontSize: '0.8em'}}>{item.id}</Text></Text>
                        {item.updatedAt && (
                          <Text type="secondary" style={{ display: 'block' }}>
                            Last Updated: {formatDate(item.updatedAt).displayText}
                          </Text>
                        )}
                        {isStatic && <Tag color="geekblue" style={{marginTop: '4px'}}>Static Definition</Tag>}
                      </>
                    }
                  />
                </List.Item>
              );
            }}
            pagination={false} // Add pagination if list becomes very long
            // pagination={{
            //   pageSize: 10, // Or make it configurable
            //   total: graphDefinitions.length, // Hook doesn't provide total for this simple list yet
            //   showSizeChanger: true,
            // }}
          />
        )}
      </Card>
    </div>
  );
};

export default LangGraphListPage;

File: src/langgraph/pages/LangGraphCreatePage.tsx
// src/langgraph/pages/LangGraphCreatePage.tsx
import React, { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button, Card, Input, Typography, Spin, Alert, Modal, Row, Col, Form } from 'antd';
import { SaveOutlined, CodeOutlined, ArrowLeftOutlined, InfoCircleOutlined } from '@ant-design/icons';

import { useAuth } from '../../context/AuthContext'; // Adjust path
import { useLangGraphDefinitions } from '../hooks/useLangGraphDefinitions';
import { CreateGraphRequestFE, FrontendGraphDef } from '../types/langgraph';
// You might want a JSON schema or examples to guide the user
// import exampleGraphJsonSchema from './exampleGraphSchema.json'; // Example

const { Title, Paragraph, Text } = Typography;
const { TextArea } = Input;

// Basic example JSON structure to guide the user
const EXAMPLE_GRAPH_JSON = `{
  "name": "My New Workflow",
  "description": "A brief description of what this workflow does.",
  "stateSchemaName": "BasicAgentState",
  "entryPointNodeId": "start_node",
  "nodes": [
    {
      "id": "start_node",
      "type": "simple_modifier",
      "config": { "message_prefix": "Entry: " },
      "uiPosition": { "x": 100, "y": 100 }
    }, 
    {
      "id": "next_step",
      "type": "simple_modifier",
      "config": { "message_prefix": "Next: " },
      "uiPosition": { "x": 300, "y": 100 }
    }
  ],
  "edges": [
    { "id": "e_start_to_next", "source": "start_node", "target": "next_step", "label": "Proceed" }
  ],
  "conditionalEdges": [],
  "terminalNodeIds": ["next_step"]
}`;

const LangGraphCreatePage: React.FC = () => {
  const navigate = useNavigate();
  const { apiClient, checkPermission } = useAuth();
  const { createGraphDefinition, isLoading, error } = useLangGraphDefinitions(apiClient, '/v1/lg-vis');

  const [graphJson, setGraphJson] = useState<string>(EXAMPLE_GRAPH_JSON);
  const [formError, setFormError] = useState<string | null>(null);

  // Permission check
  const canCreate = checkPermission('langgraph:create'); // Example permission

  const handleSubmit = useCallback(async () => {
    if (!canCreate) {
      Modal.error({ title: 'Permission Denied', content: 'You do not have permission to create graph definitions.' });
      return;
    }

    setFormError(null);
    let parsedData: Partial<CreateGraphRequestFE>;

    try {
      parsedData = JSON.parse(graphJson);
      // Basic validation (more thorough validation should happen on the backend via Pydantic)
      if (!parsedData.name || !parsedData.stateSchemaName || !parsedData.entryPointNodeId || !parsedData.nodes) {
        setFormError('Required fields missing: name, stateSchemaName, entryPointNodeId, and nodes are mandatory.');
        return;
      }
    } catch (e) {
      setFormError('Invalid JSON format. Please check the syntax.');
      return;
    }

    const newGraph = await createGraphDefinition(parsedData as CreateGraphRequestFE);

    if (newGraph && newGraph.id) {
      Modal.success({
        title: 'Graph Created Successfully!',
        content: `Graph "${newGraph.name}" has been created.`,
        onOk: () => navigate(`/langgraph/view/${newGraph.id}`),
      });
    } else {
      // Error is handled by the hook and displayed via the 'error' state variable
      // but we can also set a form-specific error if the hook's error isn't user-friendly enough
      setFormError(error || 'Failed to create graph. Please check the details and try again.');
    }
  }, [graphJson, createGraphDefinition, navigate, error, canCreate]);

  if (!canCreate) {
    return (
         <div className="page-container">
            <Alert
                message="Permission Denied"
                description="You do not have permission to create new graph definitions. Please contact your administrator."
                type="error"
                showIcon
            />
            <Button icon={<ArrowLeftOutlined />} onClick={() => navigate('/langgraph')} style={{ marginTop: 16 }}>
                Back to Graph List
            </Button>
        </div>
    );
  }

  return (
    <div className="page-container" style={{ maxWidth: '1000px', margin: '0 auto' }}>
      <Card
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Title level={2} style={{ margin: 0 }}>
              <CodeOutlined style={{ marginRight: '12px' }} />
              Create New Agentic Workflow
            </Title>
            <Button icon={<ArrowLeftOutlined />} onClick={() => navigate('/langgraph')}>
                Back to List
            </Button>
          </div>
        }
        bordered={false}
      >
        <Paragraph type="secondary">
          Define your LangGraph workflow by providing its structure in JSON format.
          Ensure the node types and state schema name correspond to definitions known by the backend.
          Refer to the documentation or examples for the correct schema.
        </Paragraph>

        <Form layout="vertical" onFinish={handleSubmit}>
          <Form.Item
            label="Graph Definition (JSON)"
            help={formError || (error && `API Error: ${error}`) || "Paste your graph definition JSON here."}
            validateStatus={formError || error ? 'error' : ''}
            required
          >
            <TextArea
              rows={20}
              value={graphJson}
              onChange={(e) => setGraphJson(e.target.value)}
              placeholder={EXAMPLE_GRAPH_JSON}
              style={{ fontFamily: 'monospace', fontSize: '13px' }}
              disabled={isLoading}
            />
          </Form.Item>

          <Row justify="end">
            <Col>
              <Button
                type="primary"
                htmlType="submit"
                icon={<SaveOutlined />}
                loading={isLoading}
                disabled={!graphJson.trim()}
              >
                Create Graph
              </Button>
            </Col>
          </Row>
        </Form>

        <details style={{ marginTop: '24px', cursor: 'pointer', border: '1px solid #e8e8e8', padding: '12px', borderRadius: '4px' }}>
            <summary style={{ fontWeight: '500', fontSize: '0.9em' }}>
                <InfoCircleOutlined style={{marginRight: '6px'}} />
                Example JSON Structure & Key Fields
            </summary>
            <Paragraph style={{marginTop: '8px', fontSize: '0.85em'}}>
                <Text strong>Required fields:</Text>
                <ul>
                    <li><Text code>name</Text>: (string) Human-readable name.</li>
                    <li><Text code>stateSchemaName</Text>: (string) Name of a Pydantic state model registered in the backend (e.g., "BasicAgentState", "DocumentProcessingState").</li>
                    <li><Text code>entryPointNodeId</Text>: (string) The ID of one of your defined nodes.</li>
                    <li><Text code>nodes</Text>: (array) List of node definitions. Each node needs:
                        <ul>
                            <li><Text code>id</Text>: (string) Unique ID for the node.</li>
                            <li><Text code>type</Text>: (string) Type string matching a key in backend's `NODE_IMPLEMENTATIONS` (e.g., "llm_node", "simple_modifier").</li>
                            <li><Text code>config</Text>: (object, optional) Configuration for the node type.</li>
                            <li><Text code>uiPosition</Text>: (object, optional) <Text code>{`{ "x": number, "y": number }`}</Text> for initial UI placement.</li>
                        </ul>
                    </li>
                </ul>
                <Text strong>Optional but important fields:</Text>
                <ul>
                    <li><Text code>description</Text>: (string) What the graph does.</li>
                    <li><Text code>edges</Text>: (array) Standard edges. Each edge needs:
                        <ul>
                             <li><Text code>id</Text>: (string) Unique ID for the edge.</li>
                             <li><Text code>source</Text>: (string) Source node ID.</li>
                             <li><Text code>target</Text>: (string) Target node ID.</li>
                             <li><Text code>label</Text>: (string, optional) Edge label.</li>
                        </ul>
                    </li>
                    <li><Text code>conditionalEdges</Text>: (array) For branching logic. Each entry needs:
                        <ul>
                            <li><Text code>sourceNodeId</Text>: (string) The node whose config specifies a `router_function_name`.</li>
                            <li><Text code>mappings</Text>: (array) Each mapping needs:
                                <ul>
                                    <li><Text code>conditionName</Text>: (string) Key returned by the router function.</li>
                                    <li><Text code>targetNodeId</Text>: (string) Target node ID for this condition.</li>
                                </ul>
                            </li>
                        </ul>
                        (Note: The router function itself is specified in the source node's `config` via `router_function_name`.)
                    </li>
                     <li><Text code>terminalNodeIds</Text>: (array of strings, optional) Node IDs that should implicitly connect to END.</li>
                </ul>
            </Paragraph>
        </details>
      </Card>
    </div>
  );
};

export default LangGraphCreatePage;

File: src/pages/ChatPage.css
/* src/pages/ChatPage.css */
.chat-page-container {
  display: flex;
  flex-direction: column;
  height: calc(100vh - 64px - 48px); /* Adjust based on your header/footer or PageLayout structure */
  /* Assuming header is 64px and some padding/margin of 48px */
  max-height: calc(100vh - 64px - 48px);
}

.chat-messages-list {
  flex-grow: 1;
  overflow-y: auto;
  padding: 16px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  margin-bottom: 16px;
  background-color: #f9f9f9;
}

.chat-message .ant-list-item-meta-title {
  margin-bottom: 2px !important;
  font-weight: 600;
}

.chat-message .ant-list-item-meta-description {
  color: rgba(0, 0, 0, 0.85);
}

.chat-message.user .ant-list-item-meta {
  flex-direction: row-reverse;
  text-align: right;
}

.chat-message.user .ant-list-item-meta-content {
  text-align: right; /* Align user's message text to the right */
}
.chat-message.user .ant-list-item-meta-avatar {
    margin-left: 12px;
    margin-right: 0;
}

.chat-message.assistant .ant-list-item-meta-avatar {
  margin-right: 12px;
}


.message-content {
  background-color: #ffffff;
  padding: 8px 12px;
  border-radius: 8px;
  display: inline-block;
  max-width: 80%; /* Prevent messages from taking full width */
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  white-space: pre-wrap; /* Preserve whitespace and newlines */
  word-wrap: break-word; /* Break long words */
}

.chat-message.user .message-content {
  background-color: #e6f7ff; /* Light blue for user messages */
  text-align: left; /* Keep text inside bubble left-aligned */
}

.chat-message.assistant .message-content {
  background-color: #f0f0f0; /* Light grey for assistant messages */
}


.chat-input-form {
  display: flex;
  align-items: center;
  padding-top: 16px; /* Add some space above input */
  border-top: 1px solid #f0f0f0; /* Separator line */
}

.loading-dots-container {
    display: flex;
    align-items: center;
    padding: 8px 0px;
}

.loading-dots span {
  display: inline-block;
  width: 8px;
  height: 8px;
  margin: 0 2px;
  background-color: #1890ff;
  border-radius: 50%;
  animation: loading-dots-animation 1.4s infinite ease-in-out both;
}

.loading-dots span:nth-child(1) {
  animation-delay: -0.32s;
}

.loading-dots span:nth-child(2) {
  animation-delay: -0.16s;
}

@keyframes loading-dots-animation {
  0%, 80%, 100% {
    transform: scale(0);
  }
  40% {
    transform: scale(1.0);
  }
}

File: src/langgraph/components/CustomGraphEdge.tsx
// src/langgraph/components/CustomGraphEdge.tsx
import React, { memo } from 'react';
import {
  EdgeProps,
  getSmoothStepPath, // Or use getBezierPath, getStraightPath
  EdgeLabelRenderer, // For custom label positioning
  BaseEdge,          // Renders the path and markers
} from 'reactflow';

import { ReactFlowEdgeData } from '../types/langgraph'; // Your custom edge data type

const CustomGraphEdge: React.FC<EdgeProps<ReactFlowEdgeData>> = ({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  data, // Contains { label?: string, status?: 'idle' | 'traversed' }
  markerEnd,
}) => {
  const { label, status } = data || {};

  // Use getSmoothStepPath for a nice curved edge.
  // You can adjust parameters like borderRadius.
  const [edgePath, labelX, labelY] = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    borderRadius: 10, // Adjust for more or less curve at corners
  });

  // --- Dynamic Styling based on status ---
  const edgeStyle: React.CSSProperties = {
    ...style, // Apply any base styles passed as props
    strokeWidth: status === 'traversed' ? 2.5 : 1.5,
    stroke: status === 'traversed' ? '#10B981' : '#a3a3a3', // Emerald-500 for traversed, neutral-400 for idle
    transition: 'stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out',
  };

  // --- Animated SVG Dash for Traversed Edges ---
  // This creates a "marching ants" effect.
  // Adjust dasharray and animation speed as needed.
  const animationStyle = status === 'traversed' ? {
    strokeDasharray: '5, 5',
    animation: 'dashdraw 0.5s linear infinite',
  } : {};

  return (
    <>
      <BaseEdge path={edgePath} markerEnd={markerEnd} style={{...edgeStyle, ...animationStyle}} />
      {label && (
        <EdgeLabelRenderer>
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
              background: status === 'traversed' ? '#d1fae5' : '#f3f4f6', // emerald-100 or gray-100
              padding: '2px 6px',
              borderRadius: '4px',
              fontSize: 10,
              fontWeight: 500,
              color: status === 'traversed' ? '#059669' : '#4b5563', // emerald-700 or gray-600
              pointerEvents: 'all', // Allow interaction with the label if needed
              border: status === 'traversed' ? '1px solid #6ee7b7' : '1px solid #e5e7eb', // emerald-300 or gray-200
            }}
            className="nodrag nopan" // Prevent dragging canvas when interacting with label
          >
            {label}
          </div>
        </EdgeLabelRenderer>
      )}
      {/* CSS for animation (can be put in a global CSS file or a style tag) */}
      <style>{`
        @keyframes dashdraw {
          to {
            stroke-dashoffset: -10;
          }
        }
      `}</style>
    </>
  );
};

export default memo(CustomGraphEdge);

File: src/test-data/sample_products.csv
Product Description,Additional Context,Expected Category
"Blue ballpoint pens with medium point","Office supplies for front desk","Office supplies"
"HP LaserJet Pro color printer with wireless","IT department equipment","Computer printers"
"Ergonomic mesh office chair with lumbar support","Furniture for new hires","Office furniture"
"LED desk lamp with adjustable brightness","Workspace accessories","Office lighting"
"Microsoft Windows 11 Professional license key","Software licenses","Operating systems"
"First aid kit with 100 pieces","Safety equipment","Medical supplies"
"55-inch 4K smart TV for conference room","Meeting room equipment","Display devices"
"Wireless keyboard and mouse combo","Computer peripherals","Input devices"
"Industrial paper shredder cross-cut","Document security","Office machines"
"Cloud-based accounting software subscription","Finance department tools","Business software"

File: src/langgraph/components/LangGraphCanvas.tsx
// src/langgraph/components/LangGraphCanvas.tsx
import React, { useMemo } from 'react';
import ReactFlow, {
  Node,
  Edge,
  Controls,
  Background,
  MiniMap,
  ReactFlowProvider, // Good practice to wrap if using hooks like useReactFlow
  BackgroundVariant,
} from 'reactflow';
import 'reactflow/dist/style.css'; // Ensure styles are imported

import { ReactFlowNodeData, ReactFlowEdgeData } from '../types/langgraph';
// import CustomGraphNode from './CustomGraphNode'; // Placeholder for custom node
// import CustomGraphEdge from './CustomGraphEdge'; // Placeholder for custom edge

// --- Optional: Define Custom Node and Edge Types for React Flow ---
// const nodeTypes = {
//   customGraphNode: CustomGraphNode, // Maps 'customGraphNode' type from adapter to this component
//   // You can add more types: 'llmNodeType': LlmNodeComponent, 'toolNodeType': ToolNodeComponent etc.
// };

// const edgeTypes = {
//   customGraphEdge: CustomGraphEdge, // Maps 'customGraphEdge' type from adapter
// };
// --- End Optional Custom Types ---

interface LangGraphCanvasProps {
  nodes: Node<ReactFlowNodeData, string | undefined>[]; // Nodes from useReactFlowGraphAdapter
  edges: Edge<ReactFlowEdgeData>[];                   // Edges from useReactFlowGraphAdapter
  onNodeClick?: (event: React.MouseEvent, node: Node<ReactFlowNodeData>) => void;
  onEdgeClick?: (event: React.MouseEvent, edge: Edge<ReactFlowEdgeData>) => void;
  // Add other React Flow props you might need, like onConnect, onNodesChange, onEdgesChange if editable
  isLoading?: boolean; // To show a loading overlay or message
}

const LangGraphCanvas: React.FC<LangGraphCanvasProps> = ({
  nodes,
  edges,
  onNodeClick,
  onEdgeClick,
  isLoading = false,
}) => {
  // Memoize node and edge types if they were defined
  // const memoizedNodeTypes = useMemo(() => nodeTypes, []);
  // const memoizedEdgeTypes = useMemo(() => edgeTypes, []);

  if (isLoading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
        <p>Loading graph data...</p> {/* Or use an Ant Design Spin component */}
      </div>
    );
  }

  return (
    // It's good practice to wrap ReactFlow with ReactFlowProvider if you plan to use
    // React Flow hooks like useNodesState, useEdgesState, useReactFlow within this component
    // or its children, though for a display-only canvas it might not be strictly necessary
    // if nodes/edges are fully managed by the parent hook.
    <ReactFlowProvider>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        // nodeTypes={memoizedNodeTypes} // Uncomment if using custom nodes
        // edgeTypes={memoizedEdgeTypes} // Uncomment if using custom edges
        onNodeClick={onNodeClick}
        onEdgeClick={onEdgeClick}
        fitView // Automatically fits the graph into the view on initial render or when nodes/edges change
        fitViewOptions={{ padding: 0.1, duration: 300 }}
        nodesDraggable={true} // Allow dragging nodes
        nodesConnectable={false} // Disable manual connection creation for display
        elementsSelectable={true} // Allow selecting nodes/edges
        attributionPosition="bottom-left" // Default position for React Flow attribution
        proOptions={{ hideAttribution: false }} // Shows "React Flow" attribution; set to true to hide
        // style={{ background: '#f8f9fa' }} // Optional: background color for the canvas
      >
        <Controls
          showInteractive={false} // Simplifies controls if graph is not interactive for connections
        />
        <MiniMap
          nodeStrokeColor={(n: Node): string => { // Type annotation for n
            if (n.type === 'input') return '#0041d0';
            if (n.type === 'output') return '#ff0072';
            if (n.data?.status === 'running') return '#fbbf24'; // amber-400
            if (n.data?.status === 'success') return '#34d399'; // emerald-400
            if (n.data?.status === 'error') return '#f87171'; // red-400
            return '#9ca3af'; // gray-400
          }}
          nodeColor={(n: Node): string => { // Type annotation for n
            if (n.data?.status === 'running') return '#fef3c7'; // amber-100
            if (n.data?.status === 'success') return '#d1fae5'; // emerald-100
            if (n.data?.status === 'error') return '#fee2e2'; // red-100
            return '#ffffff';
          }}
          nodeBorderRadius={2}
          pannable={true}
          zoomable={true}
        />
        <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
      </ReactFlow>
    </ReactFlowProvider>
  );
};

export default LangGraphCanvas;

File: src/context/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { ApiClient, User } from '../api/types';

// Define the context shape
interface AuthContextType {
  isAuthenticated: boolean;
  user: User | null;
  loading: boolean;
  authEnabled: boolean | null;
  apiClient: ApiClient;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  checkPermission: (permissionCode: string) => boolean;
  handleLoginSuccess: () => void;
}

// Create the context with default values
const AuthContext = createContext<AuthContextType>({
  isAuthenticated: false,
  user: null,
  loading: true,
  authEnabled: null,
  apiClient: {} as ApiClient, // Will be provided in the provider
  login: async () => {},
  logout: () => {},
  checkPermission: () => false,
  handleLoginSuccess: () => {},
});

// Props interface for the provider component
interface AuthProviderProps {
  children: ReactNode;
  apiClientInstance: ApiClient;
}

// Provider component
export const AuthProvider: React.FC<AuthProviderProps> = ({ children, apiClientInstance }) => {
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(apiClientInstance.isLoggedIn());
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [authEnabled, setAuthEnabled] = useState<boolean | null>(null);

  // Function to check if a user has a specific permission
  const checkPermission = (permissionCode: string): boolean => {
    if (!authEnabled) return true; // If auth is disabled, all permissions are allowed
    if (!isAuthenticated || !user) return false; // Not logged in, no permissions
    
    // Check if the user has this specific permission
    return user.permissions?.includes(permissionCode) || false;
  };

  // Login function
  const login = async (username: string, password: string): Promise<void> => {
    try {
      const response = await apiClientInstance.login(username, password);
      setIsAuthenticated(true);
      setUser(response.user);
    } catch (error) {
      console.error("Login failed:", error);
      throw error; // Re-throw to handle in the UI
    }
  };

  // Logout function
  const logout = (): void => {
    apiClientInstance.clearToken();
    setIsAuthenticated(false);
    setUser(null);
  };

  // Handler for successful login (for use with LoginPage)
  const handleLoginSuccess = async (): Promise<void> => {
    setIsAuthenticated(true);
    // Fetch current user details
    try {
      const currentUser = await apiClientInstance.getCurrentUser();
      setUser(currentUser);
    } catch (error) {
      console.error("Failed to fetch user details after login:", error);
    }
  };

  // Effect to check auth configuration on initial load
  useEffect(() => {
    const fetchAuthConfig = async () => {
      setLoading(true);
      try {
        await apiClientInstance.fetchAuthConfig();
        const isAuth = apiClientInstance.isAuthEnabled();
        setAuthEnabled(isAuth);
        
        // If auth is enabled and we're logged in, fetch user data
        if (isAuth && apiClientInstance.isLoggedIn()) {
          try {
            const currentUser = await apiClientInstance.getCurrentUser();
            setUser(currentUser);
            setIsAuthenticated(true);
          } catch (error) {
            console.error("Failed to fetch user details:", error);
            apiClientInstance.clearToken(); // Clear invalid session
            setIsAuthenticated(false);
            setUser(null);
          }
        }
      } catch (error) {
        console.error("Failed to fetch auth config:", error);
        setAuthEnabled(false); // Default to false on error
      } finally {
        setLoading(false);
      }
    };

    fetchAuthConfig();
  }, [apiClientInstance]);

  // The context value
  const contextValue: AuthContextType = {
    isAuthenticated,
    user,
    loading,
    authEnabled,
    apiClient: apiClientInstance,
    login,
    logout,
    checkPermission,
    handleLoginSuccess,
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

// Custom hook to use the auth context
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

File: src/langgraph/components/CustomGraphNode.tsx
// src/langgraph/components/CustomGraphNode.tsx
import React, { memo } from 'react';
import { Handle, Position, NodeProps, NodeResizer } from 'reactflow';
import {
  PlayCircleOutlined, // Example for generic runnable
  ApiOutlined,        // Example for LLM/API calls
  ToolOutlined,       // Example for tools
  ForkOutlined,       // Example for routers/conditional
  CheckCircleFilled,  // Example for success
  CloseCircleFilled,  // Example for error
  LoadingOutlined,    // Example for running
  SettingOutlined,    // Example for config/data nodes
} from '@ant-design/icons'; // Using Ant Design icons for consistency

import { ReactFlowNodeData } from '../types/langgraph'; // Your custom node data type

// Define a type for node status for clarity
type NodeDisplayStatus = 'idle' | 'running' | 'success' | 'error' | 'active';

// Helper to map node type to an icon (customize as needed)
const getNodeIcon = (nodeType?: string, status?: NodeDisplayStatus) => {
  if (status === 'running') return <LoadingOutlined spin style={{ fontSize: '16px' }} />;
  if (status === 'success') return <CheckCircleFilled style={{ fontSize: '16px', color: '#34d399' }} />; // emerald-400
  if (status === 'error') return <CloseCircleFilled style={{ fontSize: '16px', color: '#f87171' }} />;   // red-400

  switch (nodeType?.toLowerCase()) {
    case 'llm_node':
    case 'apicallnode':
      return <ApiOutlined style={{ fontSize: '16px' }} />;
    case 'tool_node':
    case 'toolnode':
      return <ToolOutlined style={{ fontSize: '16px' }} />;
    case 'router_node':
    case 'conditional_edge_router':
    case 'conditionnode':
      return <ForkOutlined style={{ fontSize: '16px' }} />;
    case 'entry_point':
    case 'entrypointnode':
      return <PlayCircleOutlined style={{ fontSize: '16px', color: '#3b82f6' }} />; // blue-500
    case 'data_node': // Example type for nodes that just hold/transform data
      return <SettingOutlined style={{ fontSize: '16px' }} />;
    default:
      return <PlayCircleOutlined style={{ fontSize: '16px' }} />; // Default icon
  }
};

// Define styles based on status
const getStatusStyles = (status?: NodeDisplayStatus): React.CSSProperties => {
  switch (status) {
    case 'running':
      return {
        borderColor: '#fbbf24', // amber-400
        backgroundColor: '#fef3c7', // amber-100
        boxShadow: '0 0 8px rgba(251, 191, 36, 0.5)',
      };
    case 'success':
      return {
        borderColor: '#34d399', // emerald-400
        backgroundColor: '#d1fae5', // emerald-100
      };
    case 'error':
      return {
        borderColor: '#f87171', // red-400
        backgroundColor: '#fee2e2', // red-100
      };
    case 'active': // When node is selected
      return {
        borderColor: '#60a5fa', // blue-400
        boxShadow: '0 0 10px rgba(96, 165, 250, 0.6)',
      };
    case 'idle':
    default:
      return {
        borderColor: '#d1d5db', // gray-300
        backgroundColor: '#ffffff', // white
      };
  }
};

const CustomGraphNode: React.FC<NodeProps<ReactFlowNodeData>> = ({
  data,
  isConnectable, // Provided by React Flow
  selected,      // Provided by React Flow
  // sourcePosition = Position.Bottom, // Default can be overridden by node instance
  // targetPosition = Position.Top,   // Default can be overridden by node instance
}) => {
  const { label, type: nodeType, status, config } = data; // Status comes from useLangGraphRunner via useReactFlowGraphAdapter

  const displayStatus = selected && status === 'idle' ? 'active' : status;
  const statusStyles = getStatusStyles(displayStatus);
  const icon = getNodeIcon(nodeType, displayStatus);

  // Base style for the node
  const nodeStyle: React.CSSProperties = {
    border: '2px solid',
    borderRadius: '8px',
    padding: '10px 15px',
    minWidth: '150px', // Ensure a minimum width
    // maxWidth: '250px', // Optional: constraint width
    textAlign: 'center',
    fontSize: '12px',
    transition: 'all 0.2s ease-out',
    ...statusStyles, // Apply status-specific styles
  };

  return (
    <div style={nodeStyle}>
      {/* NodeResizer (optional) makes node user-resizable - install @reactflow/node-resizer if used */}
      {/* <NodeResizer minWidth={100} minHeight={40} isVisible={selected} /> */}

      {/* Handles for incoming connections (targets) */}
      {/* You can have multiple handles and position them differently */}
      <Handle
        type="target"
        position={Position.Top}
        id="target-top"
        isConnectable={isConnectable}
        style={{ background: '#9ca3af' }} // gray-400
      />
      {/* <Handle type="target" position={Position.Left} id="target-left" isConnectable={isConnectable} /> */}

      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', marginBottom: '5px' }}>
        {icon && <span style={{ marginRight: '8px' }}>{icon}</span>}
        <strong style={{ color: '#1f2937' /* gray-800 */, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
          {label}
        </strong>
      </div>

      {nodeType && (
        <div style={{ fontSize: '10px', color: '#6b7280' /* gray-500 */, marginBottom: '3px', textTransform: 'uppercase' }}>
          {nodeType.replace(/_/g, ' ')}
        </div>
      )}

      {/* Example: Displaying a piece of config if available */}
      {config?.action && typeof config.action === 'string' && (
        <div style={{ fontSize: '10px', color: '#4b5563' /* gray-600 */, fontStyle: 'italic' }}>
          Action: {config.action}
        </div>
      )}
      {/* You can add more details from `data` or `config` here */}

      {/* Handles for outgoing connections (sources) */}
      <Handle
        type="source"
        position={Position.Bottom}
        id="source-bottom"
        isConnectable={isConnectable}
        style={{ background: '#9ca3af' }} // gray-400
      />
      {/* <Handle type="source" position={Position.Right} id="source-right" isConnectable={isConnectable} /> */}
    </div>
  );
};

export default memo(CustomGraphNode); // Use memo for performance optimization

File: src/pages/UserManagementPage.tsx
// src/pages/UserManagementPage.tsx
import React from 'react';
import { ApiClient } from '../api/types';
import { useAuth } from '../context/AuthContext';
import { UserManagementComponent } from '../components/UserManagement/UserManagementComponent';

interface UserManagementPageProps {
  apiClient: ApiClient;
}

const UserManagementPage: React.FC<UserManagementPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">User Management</h1>
        <p className="text-secondary-600">
          View and manage user accounts and permissions
        </p>
      </div>
      
      {/* Display permission warning if needed */}
      {!checkPermission('users:manage') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to view or manage users. 
            Please contact your administrator for access.
          </p>
        </div>
      )}
      
      {/* Only show user management component if user has permission */}
      {checkPermission('users:manage') && <UserManagementComponent apiClient={apiClient} />}
    </div>
  );
};

export default UserManagementPage;

File: src/langgraph/hooks/useLangGraphDefinitions.ts
// src/langgraph/hooks/useLangGraphDefinitions.ts
import { useState, useCallback, useMemo } from 'react';
import {
  FrontendGraphDef,
  GraphDefinitionIdentifierFE,
  GraphDefinitionListResponseFE,
  CreateGraphRequestFE,
  UpdateGraphRequestFE,
  MessageResponseFE,
} from '../types/langgraph';
import { LangGraphApiService } from '../services/langGraphApiService';
import { ApiClient } from '../../api/types'; // main ApiClient type

export interface UseLangGraphDefinitionsResult {
  graphDefinitions: GraphDefinitionIdentifierFE[];
  isLoading: boolean;
  error: string | null;
  fetchGraphDefinitions: (includeStatic?: boolean) => Promise<void>;
  getGraphDefinition: (graphId: string) => Promise<FrontendGraphDef | null>;
  createGraphDefinition: (data: CreateGraphRequestFE) => Promise<FrontendGraphDef | null>;
  updateGraphDefinition: (graphId: string, data: UpdateGraphRequestFE) => Promise<FrontendGraphDef | null>;
  deleteGraphDefinition: (graphId: string) => Promise<boolean>;
}

export const useLangGraphDefinitions = (
  apiClient: ApiClient, // Pass your main ApiClient instance
  lgVisApiPrefix: string = '/v1/lg-vis' // Default prefix for LangGraph Vis backend
): UseLangGraphDefinitionsResult => {
  const [graphDefinitions, setGraphDefinitions] = useState<GraphDefinitionIdentifierFE[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);  // Initialize the langGraphApiService once and memoize it to prevent recreation on every render
  const langGraphService = useMemo(
    () => new LangGraphApiService(apiClient, lgVisApiPrefix),
    [apiClient, lgVisApiPrefix]
  );

  const fetchGraphDefinitions = useCallback(async (includeStatic: boolean = false) => {
    setIsLoading(true);
    setError(null);
    try {
      console.log('[useLangGraphDefinitions] Fetching graphs with includeStatic =', includeStatic);
      const response: GraphDefinitionListResponseFE = await langGraphService.listGraphDefinitions(includeStatic);
      console.log('[useLangGraphDefinitions] Received response:', response);
      setGraphDefinitions(response.graphs || []);
    } catch (err) {
      console.error('[useLangGraphDefinitions] Error fetching graph definitions:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to load graph definitions.';
      setError(errorMessage);
      // Only clear data on error if we don't have any existing data to maintain UX
      if (graphDefinitions.length === 0) {
        setGraphDefinitions([]);
      }
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, graphDefinitions.length]); // Dependency: langGraphService and current graphDefinitions length

  const getGraphDefinition = useCallback(async (graphId: string): Promise<FrontendGraphDef | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const graphDef: FrontendGraphDef = await langGraphService.getGraphDefinition(graphId);
      return graphDef;
    } catch (err) {
      console.error(`[useLangGraphDefinitions] Error fetching graph definition ${graphId}:`, err);
      const errorMessage = err instanceof Error ? err.message : `Failed to load graph definition ${graphId}.`;
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService]); // Dependency: langGraphService

  const createGraphDefinition = useCallback(async (data: CreateGraphRequestFE): Promise<FrontendGraphDef | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const newGraphDef: FrontendGraphDef = await langGraphService.createGraphDefinition(data);
      // After creating, refresh the list of definitions
      await fetchGraphDefinitions(); // Or optimistically add to list
      return newGraphDef;
    } catch (err) {
      console.error('[useLangGraphDefinitions] Error creating graph definition:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to create graph definition.';
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, fetchGraphDefinitions]);

  const updateGraphDefinition = useCallback(async (graphId: string, data: UpdateGraphRequestFE): Promise<FrontendGraphDef | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const updatedGraphDef: FrontendGraphDef = await langGraphService.updateGraphDefinition(graphId, data);
      // After updating, refresh the list of definitions
      await fetchGraphDefinitions(); // Or optimistically update in list
      return updatedGraphDef;
    } catch (err) {
      console.error(`[useLangGraphDefinitions] Error updating graph definition ${graphId}:`, err);
      // Ensure err is treated as Error type for message property
      const errorMessage = err instanceof Error ? err.message : `Failed to update graph definition ${graphId}.`;
      setError(errorMessage);
      return null; // Ensure null is returned here
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, fetchGraphDefinitions]);

  const deleteGraphDefinition = useCallback(async (graphId: string): Promise<boolean> => {
    setIsLoading(true);
    setError(null);
    try {
      const response: MessageResponseFE = await langGraphService.deleteGraphDefinition(graphId);
      console.log(response.message); // Keep or remove logging as needed
      // After deleting, refresh the list of definitions
      await fetchGraphDefinitions();
      return true;
    } catch (err) {
      console.error(`[useLangGraphDefinitions] Error deleting graph definition ${graphId}:`, err);
      const errorMessage = err instanceof Error ? err.message : `Failed to delete graph definition ${graphId}.`;
      setError(errorMessage);
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, fetchGraphDefinitions]);

  // Removed initial useEffect for fetching definitions, as per original commented-out code.
  // Pages can trigger fetchGraphDefinitions as needed.

  return {
    graphDefinitions,
    isLoading,
    error,
    fetchGraphDefinitions,
    getGraphDefinition,
    createGraphDefinition,
    updateGraphDefinition,
    deleteGraphDefinition,
  };
};

File: src/langgraph/hooks/useReactFlowGraphAdapter.ts
// src/langgraph/hooks/useReactFlowGraphAdapter.ts
import { useState, useEffect, useCallback } from 'react';
import { Node as ReactFlowNode, Edge as ReactFlowEdge, Position, MarkerType } from 'reactflow';
import dagre from 'dagre'; // Graph layout library
import {
  FrontendGraphDef,
  FrontendNodeDef,
  FrontendEdgeDef,
  FrontendConditionalEdgesDef,
  UINodePosition,
  ReactFlowNodeData, // From your langgraph.ts types
  ReactFlowEdgeData, // From your langgraph.ts types
} from '../types/langgraph';

// --- Dagre Layout Configuration ---
const dagreGraph = new dagre.graphlib.Graph({ compound: true }); // Enable compound for subgraphs if needed
dagreGraph.setDefaultEdgeLabel(() => ({})); // Default empty label for edges in dagre
dagreGraph.setGraph({
  rankdir: 'TB', // Top to Bottom layout
  nodesep: 70,   // Horizontal separation between nodes
  ranksep: 90,   // Vertical separation between ranks (layers)
  // align: 'UL', // Alignment for nodes in the rank (UL, UR, DL, DR)
});

const DEFAULT_NODE_WIDTH = 180;
const DEFAULT_NODE_HEIGHT = 60;

interface UseReactFlowGraphAdapterResult {
  nodes: ReactFlowNode<ReactFlowNodeData>[];
  edges: ReactFlowEdge<ReactFlowEdgeData>[];
  layoutGraph: (graphDefinition: FrontendGraphDef, currentExecutionState?: any) => void; // Pass ExecutionState if needed for styling
  isLoadingLayout: boolean;
  errorLayout: string | null;
}

export const useReactFlowGraphAdapter = (): UseReactFlowGraphAdapterResult => {
  const [nodes, setNodes] = useState<ReactFlowNode<ReactFlowNodeData>[]>([]);
  const [edges, setEdges] = useState<ReactFlowEdge<ReactFlowEdgeData>[]>([]);
  const [isLoadingLayout, setIsLoadingLayout] = useState<boolean>(false);
  const [errorLayout, setErrorLayout] = useState<string | null>(null);

  const layoutGraph = useCallback((
    graphDefinition: FrontendGraphDef,
    // Optional: Pass current execution state to style nodes/edges during layout
    // currentExecutionState?: ExecutionState // Assuming ExecutionState is defined elsewhere
  ) => {
    if (!graphDefinition) {
      setNodes([]);
      setEdges([]);
      return;
    }

    setIsLoadingLayout(true);
    setErrorLayout(null);

    try {
      const dagreNodes: ReactFlowNode<ReactFlowNodeData>[] = [];
      const dagreEdges: ReactFlowEdge<ReactFlowEdgeData>[] = [];

      // 1. Prepare nodes for Dagre and React Flow
      graphDefinition.nodes.forEach((nodeDef: FrontendNodeDef) => {
        dagreGraph.setNode(nodeDef.id, {
          width: DEFAULT_NODE_WIDTH,
          height: DEFAULT_NODE_HEIGHT,
          // label: nodeDef.id, // Dagre uses label for its internal purposes if needed
        });

        const nodeData: ReactFlowNodeData = {
          label: nodeDef.id, // Display label for React Flow
          type: nodeDef.type, // Original type for custom rendering or logic
          config: nodeDef.config,
          status: 'idle', // Default status
        };

        dagreNodes.push({
          id: nodeDef.id,
          type: 'customGraphNode', // Or determine based on nodeDef.type for different custom nodes
          data: nodeData,
          position: nodeDef.uiPosition || { x: 0, y: 0 }, // Initial position, Dagre will override
          sourcePosition: Position.Bottom, // Default connection points
          targetPosition: Position.Top,
          // style: { width: DEFAULT_NODE_WIDTH, height: DEFAULT_NODE_HEIGHT }, // Can be set here or in custom node
        });
      });

      // 2. Prepare standard edges for Dagre and React Flow
      graphDefinition.edges.forEach((edgeDef: FrontendEdgeDef) => {
        dagreGraph.setEdge(edgeDef.source, edgeDef.target);
        dagreEdges.push({
          id: edgeDef.id || `e_${edgeDef.source}__${edgeDef.target}`,
          source: edgeDef.source,
          target: edgeDef.target,
          label: edgeDef.label,
          type: 'customGraphEdge', // Or 'default', 'smoothstep', etc.
          animated: edgeDef.animated || false,
          markerEnd: { type: MarkerType.ArrowClosed },
          data: { label: edgeDef.label, status: 'idle' } as ReactFlowEdgeData,
        });
      });

      // 3. Prepare conditional edges for Dagre and React Flow
      graphDefinition.conditionalEdges.forEach((condEdgesDef: FrontendConditionalEdgesDef) => {
        condEdgesDef.mappings.forEach((mapping) => {
          dagreGraph.setEdge(condEdgesDef.sourceNodeId, mapping.targetNodeId);
          dagreEdges.push({
            id: `ce_${condEdgesDef.sourceNodeId}__${mapping.targetNodeId}__${mapping.conditionName}`,
            source: condEdgesDef.sourceNodeId,
            target: mapping.targetNodeId,
            label: mapping.conditionName, // Use condition name as label
            type: 'customGraphEdge', // Style differently for conditional edges
            animated: false,
            markerEnd: { type: MarkerType.ArrowClosed, color: '#FF0072' }, // Example: different color
            style: { stroke: '#FF0072' }, // Example: different color
            data: { label: mapping.conditionName, status: 'idle' } as ReactFlowEdgeData,
          });
        });
      });

      // 4. Run Dagre layout
      dagre.layout(dagreGraph);

      // 5. Update React Flow node positions with Dagre's calculated layout
      const layoutedNodes = dagreNodes.map((node) => {
        const dagreNode = dagreGraph.node(node.id);
        if (dagreNode) {
          return {
            ...node,
            position: {
              x: dagreNode.x - dagreNode.width / 2, // Dagre positions are center-based
              y: dagreNode.y - dagreNode.height / 2,
            },
          };
        }
        return node; // Should not happen if node was added to dagreGraph
      });

      setNodes(layoutedNodes);
      setEdges(dagreEdges);

    } catch (err) {
      console.error('[useReactFlowGraphAdapter] Error during graph layout:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to layout graph.';
      setErrorLayout(errorMessage);
      setNodes([]); // Clear on error
      setEdges([]);
    } finally {
      setIsLoadingLayout(false);
    }
  }, []); // No dependencies, as it operates on passed graphDefinition

  // Effect to clear layout if the component unmounts (optional, for cleanup)
  useEffect(() => {
    return () => {
      setNodes([]);
      setEdges([]);
    };
  }, []);

  return {
    nodes,
    edges,
    layoutGraph,
    isLoadingLayout,
    errorLayout,
  };
};

File: src/langgraph/services/langGraphSocketService.ts
// src/langgraph/services/langGraphSocketService.ts
import {
  LangGraphExecutionEvent,
  ExecuteGraphRequestFE,
} from '../types/langgraph'; // Assuming your types are here
import { API_CONFIG } from '../../config/api'; // To construct WebSocket URL

const DEFAULT_RECONNECT_INTERVAL_MS = 5000;
const MAX_RECONNECT_ATTEMPTS = 5;
const PING_INTERVAL_MS = 30000; // 30 seconds for keep-alive ping

export type LangGraphSocketMessageHandler = (event: LangGraphExecutionEvent) => void;
export type LangGraphSocketErrorHandler = (error: Event) => void;
export type LangGraphSocketCloseHandler = (event: CloseEvent) => void;
export type LangGraphSocketOpenHandler = () => void;

interface LangGraphSocketServiceOptions {
  onOpen?: LangGraphSocketOpenHandler;
  onMessage: LangGraphSocketMessageHandler;
  onError?: LangGraphSocketErrorHandler;
  onClose?: LangGraphSocketCloseHandler;
  autoReconnect?: boolean;
  baseWsUrl?: string; // e.g., ws://localhost:8000 or wss://yourdomain.com
}

export class LangGraphSocketService {
  private ws: WebSocket | null = null;
  private graphId: string | null = null;
  private executionId: string | null = null; // Can be predefined or generated
  private readonly onOpenCallback?: LangGraphSocketOpenHandler;
  private readonly onMessageCallback: LangGraphSocketMessageHandler;
  private readonly onErrorCallback?: LangGraphSocketErrorHandler;
  private readonly onCloseCallback?: LangGraphSocketCloseHandler;

  private readonly autoReconnect: boolean;
  private explicitlyClosed: boolean = false; // Flag to indicate explicit closure
  private reconnectAttempts: number = 0;
  private reconnectIntervalId: NodeJS.Timeout | null = null;
  private pingIntervalId: NodeJS.Timeout | null = null;

  private baseWsUrl: string;

  constructor(options: LangGraphSocketServiceOptions) {
    this.onOpenCallback = options.onOpen;
    this.onMessageCallback = options.onMessage;
    this.onErrorCallback = options.onError;
    this.onCloseCallback = options.onClose;
    this.autoReconnect = options.autoReconnect !== undefined ? options.autoReconnect : true;
    this.explicitlyClosed = false; // Initialize here

    // Determine base WebSocket URL
    if (options.baseWsUrl) {
        this.baseWsUrl = options.baseWsUrl;
    } else {
        // Construct from API_CONFIG (assuming HTTP/HTTPS maps to WS/WSS)
        const httpBase = API_CONFIG.baseUrl.startsWith('http')
            ? API_CONFIG.baseUrl
            : `${window.location.protocol}//${window.location.host}${API_CONFIG.baseUrl}`; // Handle relative base URL
        const wsProtocol = httpBase.startsWith('https') ? 'wss:' : 'ws:';
        const url = new URL(httpBase);
        this.baseWsUrl = `${wsProtocol}//${url.host}`; // Use only protocol and host, paths will be added
    }
    console.log('[LangGraphSocketService] Base WebSocket URL set to:', this.baseWsUrl);
  }

  private getWebSocketUrl(): string {
    if (!this.graphId) {
      throw new Error('Graph ID is not set for WebSocket connection.');
    }
    // Path should match the backend WebSocket router configuration
    // Example: /v1/lg-vis/ws/langgraph/graphs/{graph_id}/execute/{execution_id}
    // Or /v1/lg-vis/ws/langgraph/graphs/{graph_id}/execute if executionId is generated by WS server
    const pathPrefix = API_CONFIG.baseUrl.startsWith('http') ? new URL(API_CONFIG.baseUrl).pathname : API_CONFIG.baseUrl;
    const fullPrefix = pathPrefix.endsWith('/') ? pathPrefix.slice(0, -1) : pathPrefix; // Ensure no double slashes    // Choose path based on whether executionId is pre-defined
    if (this.executionId) {
      return `${this.baseWsUrl}${fullPrefix}/v1/lg-vis/ws/langgraph/graphs/${this.graphId}/execute/${this.executionId}`;
    }
    return `${this.baseWsUrl}${fullPrefix}/v1/lg-vis/ws/langgraph/graphs/${this.graphId}/execute`;
  }

  public connect(graphId: string, executionId?: string): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      console.warn('[LangGraphSocketService] WebSocket is already open.');
      return;
    }
    this.graphId = graphId;
    this.executionId = executionId || null; // If undefined, it means server will generate one
    this.explicitlyClosed = false; // Reset flag on new connection attempt

    const wsUrl = this.getWebSocketUrl();
    console.log(`[LangGraphSocketService] Attempting to connect to: ${wsUrl}`);

    this.ws = new WebSocket(wsUrl);

    this.ws.onopen = () => {
      console.log(`[LangGraphSocketService] WebSocket connected for graph '${this.graphId}', execution '${this.executionId || 'NEW'}'.`);
      this.reconnectAttempts = 0; // Reset on successful connection
      if (this.reconnectIntervalId) {
        clearInterval(this.reconnectIntervalId);
        this.reconnectIntervalId = null;
      }
      this.startPing();
      this.onOpenCallback?.();
    };

    this.ws.onmessage = (event: MessageEvent) => {
      try {
        const data = JSON.parse(event.data as string) as LangGraphExecutionEvent;
        // console.debug('[LangGraphSocketService] Message received:', data);
        this.onMessageCallback(data);
      } catch (error) {
        console.error('[LangGraphSocketService] Error parsing message or in onMessage callback:', error, event.data);
        // Optionally, notify via error callback or a specific message type
      }
    };

    this.ws.onerror = (event: Event) => {
      console.error('[LangGraphSocketService] WebSocket error:', event);
      this.onErrorCallback?.(event);
    };

    this.ws.onclose = (event: CloseEvent) => {
      console.log(`[LangGraphSocketService] WebSocket closed for graph '${this.graphId}', execution '${this.executionId || 'PREVIOUS'}'. Code: ${event.code}, Reason: ${event.reason}`);
      this.stopPing();
      this.onCloseCallback?.(event);

      // MODIFIED: Check explicitlyClosed flag
      if (!this.explicitlyClosed && this.autoReconnect && this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS && !event.wasClean) {
        this.reconnectAttempts++;
        const delay = DEFAULT_RECONNECT_INTERVAL_MS * Math.pow(2, this.reconnectAttempts -1); // Exponential backoff
        console.log(`[LangGraphSocketService] Attempting to reconnect in ${delay / 1000}s (attempt ${this.reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
        this.reconnectIntervalId = setTimeout(() => {
          if (this.graphId && !this.explicitlyClosed) { // Check again before reconnecting
            this.connect(this.graphId, this.executionId || undefined); // Pass current executionId or let server generate
          }
        }, delay);
      } else if (this.reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        console.error('[LangGraphSocketService] Max reconnect attempts reached.');
      }
    };
  }

  public send(initialMessage: ExecuteGraphRequestFE): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      try {
        const messageString = JSON.stringify(initialMessage);
        console.log('[LangGraphSocketService] Sending initial message:', messageString);
        this.ws.send(messageString);
      } catch (error) {
        console.error('[LangGraphSocketService] Error sending initial message:', error);
      }
    } else {
      console.warn('[LangGraphSocketService] WebSocket is not open. Cannot send message.');
      // Optionally queue the message or throw an error
    }
  }

  private startPing(): void {
    this.stopPing(); // Clear any existing ping interval
    this.pingIntervalId = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        // console.debug('[LangGraphSocketService] Sending ping');
        this.ws.send(JSON.stringify({ eventType: 'ping', timestamp: new Date().toISOString() }));
      } else {
        // console.debug('[LangGraphSocketService] WebSocket not open, stopping ping.');
        this.stopPing(); // Stop pinging if connection is closed for any reason
      }
    }, PING_INTERVAL_MS);
  }

  private stopPing(): void {
    if (this.pingIntervalId) {
      clearInterval(this.pingIntervalId);
      this.pingIntervalId = null;
      // console.debug('[LangGraphSocketService] Ping interval stopped.');
    }
  }

  public close(code?: number, reason?: string): void {
    this.explicitlyClosed = true; // MODIFIED: Set the flag here
    this.stopPing();
    if (this.reconnectIntervalId) {
        clearInterval(this.reconnectIntervalId);
        this.reconnectIntervalId = null;
    }
    if (this.ws) {
      console.log(`[LangGraphSocketService] Closing WebSocket explicitly. Code: ${code}, Reason: ${reason}`);
      this.ws.close(code, reason);
      this.ws = null;
    }
    this.graphId = null;
    this.executionId = null;
  }

  public getReadyState(): number | undefined {
    return this.ws?.readyState;
  }
}

File: src/components/RerunStatusModal.tsx
import React from 'react';

interface RerunStatusModalProps {
  isOpen: boolean;
  description: string;
}

export const RerunStatusModal: React.FC<RerunStatusModalProps> = ({ isOpen, description }) => {
  if (!isOpen) {
    return null;
  }

  return (
    <div className="fixed inset-0 flex items-center justify-center z-50">
      <div className="fixed inset-0 bg-black opacity-30"></div>
      <div className="relative bg-white rounded-lg p-6 max-w-md w-full mx-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600 mx-auto mb-4"></div>
          <h3 className="text-lg font-medium text-secondary-900 mb-2">
            Rerunning Classification
          </h3>
          <p className="text-sm text-secondary-600 mb-4">
            {description}
          </p>
          <p className="text-xs text-secondary-500">
            This may take a few moments...
          </p>
        </div>
      </div>
    </div>
  );
};

export default RerunStatusModal;

File: src/enum/sidebar.enum.ts
// Define the sidebar items enum
export enum SidebarItem {
  HOME = '/', // Often a redirect
  TEST = '/test',
  BATCH = '/batch',
  BATCH_CREATE = '/batch/create', // If you have a separate create page for batch
  BATCH_JOBS = '/batch/jobs',
  HISTORY = '/history',
  CHAT = '/chat', // From your App.tsx
  RAG_INFO = '/rag-info',

  // LangGraph Visualization ---
  LANGGRAPH_LIST = '/langgraph',
  LANGGRAPH_VIEW = '/langgraph/view', // Base path, actual view will be /view/:graphId
  LANGGRAPH_CREATE = '/langgraph/create',
  LANGGRAPH_EDIT = '/langgraph/edit', // If you create an edit page

  // Admin ---
  ADMIN_USERS = '/admin/users',
  ADMIN_ROLES = '/admin/roles',

  // Bottom Items ---
  SETTINGS = '/settings',
  LOGOUT = 'logout', // Special key, not a URL path
}

File: src/components/ClassificationDetailsModal.tsx
// src/components/ClassificationDetailsModal.tsx
import React, { useState, useEffect, useMemo } from 'react';
import { ClassificationHistory, CategoryLevel } from '../api/types';
import { formatDate } from '../utils/dateFormat'; 
import ReactMarkdown from 'react-markdown';
// import { InformationCircleIcon } from '@heroicons/react/24/outline'; // Removed unused import

interface ClassificationDetailsModalProps {
  isOpen: boolean;
  onClose: () => void;
  item: ClassificationHistory | null;
}

// Define informationalErrorMessages locally or import if shared
const informationalErrorMessages = [
  "Classification failed to determine required levels",
  "Classification failed to determine required levels.",
  "No matching category found at this level",
  "Failed to classify at this level",
  "Classification is partial; some levels may be missing or invalid.",
  "Classification is partial.", // Added from strategy_standard
  "Classification failed.", // Added from strategy_standard
  "Level not classified.", // Common pattern for level-specific messages
  "No match found for level", // Common pattern for no-match messages
];

const isInformationalError = (errorMessage?: string): boolean => {
  if (!errorMessage) return false;
  const lowerMessage = errorMessage.toLowerCase();
  return informationalErrorMessages.some(msg => lowerMessage.includes(msg.toLowerCase()));
};


export const ClassificationDetailsModal: React.FC<ClassificationDetailsModalProps> = ({
  isOpen,
  onClose,
  item
}) => {
  const [activeTab, setActiveTab] = useState<'details' | 'rag' | 'llm' | 'prompt'>('details');
  const [activeLlmTab, setActiveLlmTab] = useState<string | null>(null);
  const [activePromptTab, setActivePromptTab] = useState<string | null>(null);
  const levelOrder: Record<string, number> = useMemo(() => ({ 
    'segment': 1, 'family': 2, 'class': 3, 'commodity': 4,
    'subcat1': 1, 'subcat2': 2, 'default': 99, 'first_level': 0, 
    'first_level_prompt_only': 0, 'error_prompt': 0
  }), []);

  const parsedPrompts = useMemo(() => {
    if (item?.allPromptsDetail) { // allPromptsDetail is now string | undefined
      try {
        const parsed = JSON.parse(item.allPromptsDetail);
        if (typeof parsed === 'object' && parsed !== null) {
          return parsed as Record<string, string>;
        }
        console.warn("Parsed allPromptsDetail is not an object:", parsed);
        // Fallback if JSON is valid but not an object
      } catch (e) {
        console.error("Failed to parse allPromptsDetail JSON:", e, "\nContent:", item.allPromptsDetail);
        // Fall through to firstLevelPrompt if parsing fails
      }
    }
    
    // Fallback to firstLevelPrompt if allPromptsDetail is missing, unparsable, or not an object
    if (item?.firstLevelPrompt) {
        // Try to determine a sensible key for the first level prompt
        let firstLevelKey = "first_level_prompt"; // Default key
        if (item.levels && Object.keys(item.levels).length > 0) {
            const sortedLevels = Object.keys(item.levels).sort((a,b) => (levelOrder[a.toLowerCase()] ?? 99) - (levelOrder[b.toLowerCase()] ?? 99));
            if (sortedLevels.length > 0) {
                firstLevelKey = sortedLevels[0];
            }
        } else if (item.allPromptsDetail && item.allPromptsDetail.includes("error_prompt")){ 
            // Special case for error prompt
            firstLevelKey = "error_prompt";
        }
        return { [firstLevelKey]: item.firstLevelPrompt };
    }
    return null;
  }, [item?.allPromptsDetail, item?.firstLevelPrompt, item?.levels, levelOrder]);

  const sortedLevelCodesForTabs = useMemo(() => {
    if (!item) return [];
    const levelCodes = new Set<string>();
    
    // From LLM Responses
    if (item.levelResponses) {
        Object.keys(item.levelResponses).forEach(lc => levelCodes.add(lc));
    }
    
    // From Parsed Prompts
    if (parsedPrompts) {
        Object.keys(parsedPrompts).forEach(lc => levelCodes.add(lc));
    }
    
    // From actual classification levels (if available and others are not)
    if (levelCodes.size === 0 && item.levels) {
        Object.keys(item.levels).forEach(lc => levelCodes.add(lc));
    }
    
    return Array.from(levelCodes).sort((a, b) => 
      (levelOrder[a.toLowerCase()] ?? levelOrder['default']) - (levelOrder[b.toLowerCase()] ?? levelOrder['default']) || a.localeCompare(b)
    );
  }, [item, parsedPrompts, levelOrder]);
  useEffect(() => {
    if (isOpen) {
      setActiveTab('details');
      if (sortedLevelCodesForTabs.length > 0) {
        const firstTabKey = sortedLevelCodesForTabs[0];
        setActiveLlmTab(firstTabKey);
        setActivePromptTab(firstTabKey);
      } else {
        // If no specific level tabs, but a firstLevelPrompt exists, set activePromptTab to a generic key
        if (item?.firstLevelPrompt && parsedPrompts && Object.keys(parsedPrompts).length > 0) {
            setActivePromptTab(Object.keys(parsedPrompts)[0]); // Use the key from parsedPrompts
        } else {
            setActivePromptTab(null);
        }
        setActiveLlmTab(null);
      }
    }
  }, [isOpen, sortedLevelCodesForTabs, item?.firstLevelPrompt, parsedPrompts]);

  if (!isOpen || !item) {
    return null;
  }

  const getLevelResponse = (levelCode: string): string => {
    return item?.levelResponses?.[levelCode] || 'No LLM response available for this level.';
  };

  const getLevelPrompt = (levelCode: string): string => {
    return parsedPrompts?.[levelCode] || item?.firstLevelPrompt || 'No prompt available for this level.';
  }

  const formatRagContext = (ragContext: string) => { 
    return ragContext.split('\n\n').map((section, index) => (
      <div key={index} className="mb-4">
        {section.split('\n').map((line, lineIndex) => (
          <div key={lineIndex} className={lineIndex === 0 && !line.startsWith('- ') ? 'font-medium text-secondary-700' : line.startsWith('- ') ? 'ml-2 text-secondary-600' : 'ml-4 text-secondary-600'}>
            {line}
          </div>
        ))}
      </div>
    ));
  };

  const renderMarkdown = (content: string) => { 
    return (
      <div className="text-sm text-secondary-900 whitespace-pre-wrap prose prose-sm max-w-none">
        <ReactMarkdown>{content}</ReactMarkdown>
      </div>
    );
  };

  const getLevelName = (levelCode: string): string => { 
    const levelNames: Record<string, string> = {
      'segment': 'Segment', 'family': 'Family', 'class': 'Class', 'commodity': 'Commodity',
      'subcat1': 'Subcategory 1', 'subcat2': 'Subcategory 2'
    };
    return levelNames[levelCode.toLowerCase()] || levelCode;
  };

  const getSourceTypeLabel = (sourceType: string): string => { 
    if (!sourceType) return 'Unknown';
    const stLower = sourceType.toLowerCase();
    if (stLower.includes('user') || stLower.includes('manual')) return 'Manual Input';
    if (stLower.includes('batch')) return 'Batch';
    if (stLower.includes('api')) return 'API Input';
    return sourceType;
  };

  return (
    <div className="fixed inset-0 flex items-center justify-center z-50 p-4">
      <div className="fixed inset-0 bg-black opacity-30" onClick={onClose}></div>
      <div className="relative bg-white rounded-lg shadow-xl w-full max-w-5xl mx-auto max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="border-b border-secondary-200 px-6 py-4 flex justify-between items-center sticky top-0 bg-white z-10">
          <h3 className="text-xl font-semibold text-secondary-900 flex items-center">
            Classification Details
            <span className={`ml-3 inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${
              item.status === 'success' ? 'bg-green-100 text-green-800 border-green-200' : 
              item.status === 'partial' ? 'bg-yellow-100 text-yellow-800 border-yellow-200' : 
              'bg-red-100 text-red-800 border-red-200'
            }`}>
              {item.status === 'success' ? 'Success' : item.status === 'partial' ? 'Partial' : 'Failed'}
            </span>
          </h3>
          <button onClick={onClose} className="text-secondary-500 hover:text-secondary-700 transition-colors">
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Tabs */}
        <div className="border-b border-secondary-200 px-6 sticky top-[65px] bg-white z-10"> {/* Adjust top based on header height */}
          <div className="flex space-x-6 overflow-x-auto">
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'details' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('details')}
            > Classification Details </button>
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'rag' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('rag')} disabled={!item.ragContextUsed}
            > RAG Context {item.ragContextUsed && (<span className="ml-2 inline-flex items-center px-1.5 py-0.5 rounded-full text-xs font-medium bg-primary-100 text-primary-700">Used</span>)}</button>
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'llm' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('llm')} disabled={!item.levelResponses || sortedLevelCodesForTabs.length === 0}
            > LLM Responses {item.levelResponses && sortedLevelCodesForTabs.length > 0 && (<span className="ml-2 inline-flex items-center px-1.5 py-0.5 rounded-full text-xs font-medium bg-primary-100 text-primary-700">{sortedLevelCodesForTabs.length}</span>)}</button>
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'prompt' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('prompt')} disabled={!parsedPrompts && !item.firstLevelPrompt}
            > Prompts </button>
          </div>
        </div>
        
        {/* Content */}
        <div className="px-6 py-4 overflow-y-auto flex-grow">
          {activeTab === 'details' && ( 
            <div className="space-y-6">
              <div>
                <h4 className="text-lg font-medium text-secondary-900 mb-3">Basic Information</h4>
                <div className="bg-secondary-50 rounded-lg p-4 grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                  <div><p className="text-sm font-medium text-secondary-500">Description</p><p className="text-sm text-secondary-900 mt-1 break-words">{item.description}</p></div>
                  <div><p className="text-sm font-medium text-secondary-500">System</p><p className="text-sm text-secondary-900 mt-1">{item.systemCode}</p></div>
                  <div><p className="text-sm font-medium text-secondary-500">Created At</p>
                    <p className="text-sm text-secondary-900 mt-1" title={formatDate(item.createdAt, {includeTimezone: true}).fullText}>
                        {formatDate(item.createdAt).displayText}
                    </p>
                  </div>
                  <div><p className="text-sm font-medium text-secondary-500">Source</p><p className="text-sm text-secondary-900 mt-1">{getSourceTypeLabel(item.sourceType)}</p></div>
                  {item.modelUsed && (
                    <div>
                      <p className="text-sm font-medium text-secondary-500">Model Used</p>
                      <p className="text-sm text-secondary-900 mt-1">{item.modelUsed}</p>
                    </div>
                  )}
                  {item.key && (<div className="md:col-span-1"><p className="text-sm font-medium text-secondary-500">Item Key</p><p className="text-sm text-secondary-900 mt-1 break-words">{item.key}</p></div>)}
                  {item.additionalContext && (<div className="md:col-span-2"><p className="text-sm font-medium text-secondary-500">Additional Context</p><p className="text-sm text-secondary-900 mt-1 whitespace-pre-wrap">{item.additionalContext}</p></div>)}
                  {item.error && (
                    <div className="md:col-span-2">
                      <p className={`text-sm font-medium ${isInformationalError(item.error) ? 'text-yellow-600' : 'text-red-600'}`}>Error/Note</p>
                      <p className={`text-sm mt-1 ${isInformationalError(item.error) ? 'text-yellow-700' : 'text-red-700'}`}>{item.error}</p>
                    </div>
                  )}
                </div>
              </div>
              <div>
                <h4 className="text-lg font-medium text-secondary-900 mb-3">Classification Result</h4>
                <div className="bg-secondary-50 rounded-lg p-4">
                  <div className="space-y-3">
                    {Object.entries(item.levels || {}).sort(([aCode], [bCode]) => {
                        const orderA = levelOrder[aCode.toLowerCase()] ?? levelOrder['default'];
                        const orderB = levelOrder[bCode.toLowerCase()] ?? levelOrder['default'];
                        return orderA - orderB || aCode.localeCompare(bCode);
                      }).map(([levelCode, category]) => {
                        const typedCategory = category as CategoryLevel; 
                        return (
                          <div key={levelCode} className="pb-3 border-b border-secondary-200 last:border-b-0 last:pb-0">
                            <div className="flex justify-between items-start">
                              <div>
                                <p className="text-sm font-medium text-secondary-700">{getLevelName(levelCode)}</p>
                                <p className="text-base font-medium text-secondary-900 mt-1">{typedCategory.code} - {typedCategory.name}</p>
                                {typedCategory.description && typedCategory.description !== typedCategory.name && (<p className="text-sm text-secondary-600 mt-1">{typedCategory.description}</p>)}
                              </div>
                              {typedCategory.error && (<span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800 border border-red-200">Error</span>)}
                            </div>
                            {typedCategory.error && (<p className="text-sm text-red-600 mt-2">{typedCategory.error}</p>)}
                            {item.levelResponses?.[levelCode] && (
                              <div className="mt-2 pl-4 border-l-2 border-secondary-200">
                                <div className="flex items-center"><p className="text-xs font-medium text-secondary-500 mb-1 mr-2">LLM Rationale:</p>
                                  <button className="text-xs text-primary-600 hover:text-primary-800 underline" onClick={() => { setActiveTab('llm'); setActiveLlmTab(levelCode);}}>View Full Response</button>
                                </div>
                                <div className="text-sm text-secondary-700 line-clamp-3">{renderMarkdown(item.levelResponses[levelCode])}</div>
                              </div>
                            )}
                          </div>);})}
                    {(!item.levels || Object.keys(item.levels).length === 0) && (<p className="text-sm text-secondary-500 italic">No classification levels available.</p>)}
                  </div></div></div></div>
          )}
          
          {activeTab === 'rag' && ( 
            <div>
              <div className="flex items-center justify-between mb-4">
                <h4 className="text-lg font-medium text-secondary-900">RAG Context</h4>
                {item.ragContextUsed ? (<span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 border border-green-200">Used</span>)
                : (<span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800 border border-gray-200">Not Used</span>)}
              </div>
              <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-96"> {/* Added max-h-96 */}
                {item.ragContext ? (<div className="text-sm text-secondary-900 font-mono whitespace-pre-wrap">{formatRagContext(item.ragContext)}</div>)
                : (<p className="text-sm text-secondary-500 italic">No RAG context available</p>)}
              </div></div>
          )}
          
          {activeTab === 'llm' && ( 
             <div>
              <h4 className="text-lg font-medium text-secondary-900 mb-3">LLM Responses by Level</h4>
              {sortedLevelCodesForTabs.length > 0 && item.levelResponses ? (
                <div>
                  <div className="border-b border-secondary-200 mb-4">
                    <nav className="flex -mb-px space-x-4 overflow-x-auto">
                      {sortedLevelCodesForTabs.map((levelCode) => (
                        item.levelResponses?.[levelCode] && // Only show tab if response exists
                        <button key={`llm-tab-${levelCode}`} onClick={() => setActiveLlmTab(levelCode)}
                          className={`py-2 px-1 font-medium text-sm border-b-2 whitespace-nowrap ${activeLlmTab === levelCode ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
                        >{getLevelName(levelCode)}</button>
                      ))}
                    </nav>
                  </div>
                  <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-80">
                    {sortedLevelCodesForTabs.map((levelCode) => (
                      item.levelResponses?.[levelCode] &&
                      <div key={`llm-panel-${levelCode}`} className={`${activeLlmTab === levelCode ? 'block' : 'hidden'}`}>
                        <div className="text-sm text-secondary-900">{renderMarkdown(getLevelResponse(levelCode))}</div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : (<div className="bg-secondary-50 rounded-lg p-6 text-center"><p className="text-sm text-secondary-500">No LLM responses available.</p></div>)}
            </div>
          )}

          {activeTab === 'prompt' && ( 
            <div>
              <h4 className="text-lg font-medium text-secondary-900 mb-3">Prompts by Level</h4>
              {parsedPrompts && sortedLevelCodesForTabs.length > 0 ? (
                <div>
                  <div className="border-b border-secondary-200 mb-4">
                    <nav className="flex -mb-px space-x-4 overflow-x-auto">
                      {sortedLevelCodesForTabs.map((levelCode) => (
                         parsedPrompts[levelCode] && 
                        <button key={`prompt-tab-${levelCode}`} onClick={() => setActivePromptTab(levelCode)}
                          className={`py-2 px-1 font-medium text-sm border-b-2 whitespace-nowrap ${activePromptTab === levelCode ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
                        >{getLevelName(levelCode)}</button>
                      ))}
                    </nav>
                  </div>
                  <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-80">
                    {sortedLevelCodesForTabs.map((levelCode) => (
                      parsedPrompts[levelCode] && 
                      <div key={`prompt-panel-${levelCode}`} className={`${activePromptTab === levelCode ? 'block' : 'hidden'}`}>
                        <div className="text-sm text-secondary-900 font-mono whitespace-pre-wrap">
                          {getLevelPrompt(levelCode)}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : item?.firstLevelPrompt ? (
                <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-96">
                  <p className="text-sm font-medium text-secondary-700 mb-1">First Level Prompt:</p>
                  <div className="text-sm text-secondary-900 font-mono whitespace-pre-wrap">
                    {item.firstLevelPrompt}
                  </div>
                </div>
              ) : (
                <div className="bg-secondary-50 rounded-lg p-6 text-center">
                  <p className="text-sm text-secondary-500">No prompt details available.</p>
                </div>
              )}
            </div>
          )}
        </div>
        
        {/* Footer */}
        <div className="border-t border-secondary-200 px-6 py-4 flex justify-end sticky bottom-0 bg-white z-10">
          <button onClick={onClose} className="btn btn-secondary">Close</button>
        </div>
      </div>
    </div>
  );
};

export default ClassificationDetailsModal;

File: src/components/ClassificationForm.tsx
import React, { useState, useEffect, ChangeEvent, FormEvent } from 'react';
import { InformationCircleIcon } from '@heroicons/react/24/outline'; // Import icon
import ReactMarkdown from 'react-markdown';
import {
  ApiClient,
  ClassificationResult,
  ClassificationSystem,
  ClassificationLevel,
  ManualClassificationRequest,
} from '../api/types';
import { ManualClassificationModal } from './ManualClassificationModal';
import { useAuth } from '../context/AuthContext'; // Import useAuth hook

interface ClassificationFormProps {
  apiClient: ApiClient;
  onResult?: (result: ClassificationResult) => void;
  onError?: (error: Error) => void;
}

export const ClassificationForm: React.FC<ClassificationFormProps> = ({
  apiClient,
  onResult,
  onError,
}) => {
  const { checkPermission } = useAuth(); // Get permission checker from auth context
  const [description, setDescription] = useState('');
  const [additionalContext, setAdditionalContext] = useState('');
  const [selectedSystem, setSelectedSystem] = useState<string>('UNSPSC');
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<ClassificationResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [systems, setSystems] = useState<ClassificationSystem[]>([]);
  const [systemLevels, setSystemLevels] = useState<ClassificationLevel[]>([]);
  
  // State for model selection
  const [availableModels, setAvailableModels] = useState<string[]>([]);
  const [selectedModel, setSelectedModel] = useState<string>('');
  
  // Modal state
  const [showModal, setShowModal] = useState(false);
  
  // Active tab for LLM responses
  const [activeLlmTab, setActiveLlmTab] = useState<string | null>(null);
  
  // Level-specific LLM responses
  const [levelResponses, setLevelResponses] = useState<{[key: string]: string}>({});

  useEffect(() => {
    const loadSystems = async () => {
      try {
        const availableSystems = await apiClient.getClassificationSystems();
        setSystems(availableSystems);
        if (availableSystems.length > 0 && !selectedSystem) {
          setSelectedSystem(availableSystems[0].code);
        }
      } catch (error) {
        console.error('Failed to load classification systems:', error);
        setError('Failed to load classification systems');
      }
    };
    loadSystems();
  }, [apiClient]);

  useEffect(() => {
    const loadSystemLevels = async () => {
      if (!selectedSystem) return;
      try {
        const response = await apiClient.getClassificationSystem(selectedSystem);
        setSystemLevels(response.levels || []);
      } catch (error) {
        console.error('Failed to load system levels:', error);
        setError('Failed to load system levels');
      }
    };
    loadSystemLevels();
  }, [apiClient, selectedSystem]);

  // Load available LLM models from config
  useEffect(() => {
    const loadModels = async () => {
      try {
        const config = await apiClient.getConfig();
        const models = [];
        
        // Add the main model
        if (config.service?.llmModel) {
          models.push(config.service.llmModel);
        }
        
        // Add retry models if available
        if (config.service?.llmRetryModels && Array.isArray(config.service.llmRetryModels)) {
          models.push(...config.service.llmRetryModels);
        }
        
        setAvailableModels(models);
        // Set the default model to the main one
        if (models.length > 0) {
          setSelectedModel(models[0]);
        }
      } catch (error) {
        console.error('Failed to load LLM models:', error);
      }
    };
    loadModels();
  }, [apiClient]);

  // Set the active LLM tab when results are received
  useEffect(() => {
    if (result && systemLevels.length > 0) {
      // Find the first level with results
      const firstLevelCode = Object.keys(result.levels)[0] || systemLevels[0].code;
      setActiveLlmTab(firstLevelCode);
      
      // Check if the backend provided level-specific responses
      if (result.levelResponses && Object.keys(result.levelResponses).length > 0) {
        setLevelResponses(result.levelResponses);
      }
    }
  }, [result, systemLevels]);
  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    
    // Clear previous results when starting a new classification
    setResult(null);
    setLevelResponses({});
    
    try {
      const classificationResult = await apiClient.classify(description, selectedSystem, additionalContext, selectedModel);
      setResult(classificationResult);
      
      // Check if the backend already provided level-specific responses
      if (classificationResult.levelResponses && Object.keys(classificationResult.levelResponses).length > 0) {
        setLevelResponses(classificationResult.levelResponses);
      }
      
      onResult?.(classificationResult);
    } catch (error) {
      let errorMessage = 'Classification failed';
      if (error instanceof Error) {
        if (error.message.includes('OpenRouter API request failed')) {
          errorMessage = 'LLM Service Authentication Error - Please check API configuration';
        } else {
          errorMessage = error.message;
        }
      }
      setError(errorMessage);
      onError?.(error instanceof Error ? error : new Error(errorMessage));
    } finally {
      setLoading(false);
    }
  };

  const handleDescriptionChange = (e: ChangeEvent<HTMLTextAreaElement>) => {
    setDescription(e.target.value);
    setError(null);
  };

  const handleSystemChange = (e: ChangeEvent<HTMLSelectElement>) => {
    setSelectedSystem(e.target.value);
    setError(null);
    setResult(null);
    setLevelResponses({});
  };
  const handleManualClassification = async (manualResult: ClassificationResult) => {
    try {
      // Prepare the request payload according to ManualClassificationRequest interface
      const requestPayload: ManualClassificationRequest = {
        description: description,
        systemCode: selectedSystem,
        selectedSystem: selectedSystem, // As per interface, using selectedSystem state
        additionalContext: additionalContext,
        modelOverride: selectedModel, // Pass the selected model to the manual classification
        levels: Object.fromEntries(
          Object.entries(manualResult.levels).map(([levelCode, categoryLevel]) => [
            levelCode,
            categoryLevel.code, // Extract the code string
          ])
        ),
      };

      const updatedResult = await apiClient.classifyManually(requestPayload);
      console.log("Manual classification result:", updatedResult);
      setResult(updatedResult);

      // Use level-specific responses from the result if available
      if (updatedResult.levelResponses && Object.keys(updatedResult.levelResponses).length > 0) {
        setLevelResponses(updatedResult.levelResponses);
      }

      onResult?.(updatedResult);
    } catch (error) {
      console.error("Failed to save manual classification:", error);
      setError("Failed to save manual classification. Please try again.");
      onError?.(error instanceof Error ? error : new Error("Failed to save manual classification."));
    }
  };

  const getLevelClasses = (index: number): {bg: string, text: string} => {
    const colorClasses = [
      { bg: 'bg-blue-50', text: 'text-blue-600' },
      { bg: 'bg-indigo-50', text: 'text-indigo-600' },
      { bg: 'bg-purple-50', text: 'text-purple-600' },
      { bg: 'bg-pink-50', text: 'text-pink-600' },
      { bg: 'bg-rose-50', text: 'text-rose-600' },
      { bg: 'bg-orange-50', text: 'text-orange-600' },
      { bg: 'bg-amber-50', text: 'text-amber-600' },
      { bg: 'bg-emerald-50', text: 'text-emerald-600' }
    ];
    return colorClasses[index % colorClasses.length];
  };

  // Render markdown content
  const renderMarkdown = (content: string) => {
    return (
      <div className="text-xs text-secondary-600 whitespace-pre-wrap prose prose-sm max-w-none">
        <ReactMarkdown>
          {content}
        </ReactMarkdown>
      </div>
    );
  };

  const getStatusBadge = (status: 'success' | 'partial' | 'failed' | 'all') => {
    const classes = {
      success: 'bg-green-100 text-green-800 border-green-200',
      partial: 'bg-yellow-100 text-yellow-800 border-yellow-200',
      failed: 'bg-red-100 text-red-800 border-red-200',
      all: 'bg-blue-100 text-blue-800 border-blue-200'
    };
    
    const labels = {
      success: 'Success',
      partial: 'Partial',
      failed: 'Failed',
      all: 'Complete'
    };

    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${classes[status]}`}>
        {labels[status]}
      </span>
    );
  };

  return (
    <div className="max-w-8xl mx-auto space-y-10" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
      <div className="bg-white shadow-card rounded-card p-8 w-full" style={{ paddingRight: '5rem', paddingLeft: '3rem'}}>
        <form onSubmit={handleSubmit} className="space-y-6">          <div className="flex flex-col md:flex-row md:space-x-6 md:space-y-0 space-y-6">
            <div className="space-y-2 flex-1">
              <label htmlFor="system" className="block text-sm font-medium text-secondary-700">
                Classification System:
              </label>
              <select
                id="system"
                value={selectedSystem}
                onChange={handleSystemChange}
                className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                style={{ paddingRight: '1rem', paddingLeft: '1rem'}}
              >
                {systems.map(system => (
                  <option key={system.code} value={system.code}>
                    {system.name}
                  </option>
                ))}
              </select>
            </div>

            <div className="space-y-2 flex-1">
              <label htmlFor="model" className="block text-sm font-medium text-secondary-700">
                LLM Model:
              </label>
              <select
                id="model"
                value={selectedModel}
                onChange={(e) => setSelectedModel(e.target.value)}
                className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                style={{ paddingRight: '1rem', paddingLeft: '1rem'}}
                disabled={loading || availableModels.length <= 1}
              >
                {availableModels.map(model => (
                  <option key={model} value={model}>
                    {model}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="space-y-2">
            <label htmlFor="description" className="block text-sm font-medium text-secondary-700">
              Product Description:
            </label>
            <textarea
              id="description"
              value={description}
              onChange={handleDescriptionChange}
              required
              rows={4}
              className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
              placeholder="Enter product description..."
            />
          </div>

          <div className="space-y-2">
            <label htmlFor="additionalContext" className="block text-sm font-medium text-secondary-700">
              Additional Context (Optional):
            </label>
            <textarea
              id="additionalContext"
              value={additionalContext}
              onChange={(e) => setAdditionalContext(e.target.value)}
              rows={3}
              className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
              placeholder="Enter any additional context that might help with classification..."
            />
          </div>

          {error && (
            <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3 text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="flex justify-end">
            <button
              className={`px-6 py-3 rounded-lg font-medium text-white ${
                loading || description.trim() === '' || !checkPermission('classify:item')
                  ? 'bg-gray-400 cursor-not-allowed'
                  : 'bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2'
              }`}
              type="submit"
              disabled={loading || description.trim() === '' || !checkPermission('classify:item')}
              data-testid="classify-button"
              title={!checkPermission('classify:item') ? "You don't have permission to classify items" : ""}
            >
              {loading ? 'Classifying...' : 'Classify'}
            </button>
          </div>

          {!checkPermission('classify:item') && (
            <div className="p-4 border border-yellow-200 bg-yellow-50 rounded-md mt-4">
              <p className="text-yellow-800 text-sm">
                You don't have permission to perform classifications. Please contact your administrator.
              </p>
            </div>
          )}
        </form>
      </div>

      {result && (
        <div className="bg-white shadow-card rounded-card p-8 w-full">
          <div className="flex justify-between items-center mb-8">
            <div className="flex items-center gap-3">
              <h3 className="text-xl font-semibold text-secondary-900">
                Classification Results - {result.system_code}
              </h3>
              {getStatusBadge(result.status)}
            </div>
            <button
              onClick={() => setShowModal(true)}
              className="group relative inline-flex items-center gap-1.5 px-4 py-2.5 bg-white text-sm font-medium text-secondary-700 border border-secondary-200 rounded-lg hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm"
            >
              <svg 
                className="w-4 h-4 text-secondary-500 group-hover:text-secondary-700 transition-colors" 
                fill="none" 
                viewBox="0 0 24 24" 
                stroke="currentColor"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth={2} 
                  d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" 
                />
              </svg>
              <span>Edit Classification</span>
              <div className="absolute inset-0 rounded-lg overflow-hidden">
                <div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div>
              </div>
            </button>
          </div>

          {result.error && (
            <div className="mb-6 rounded-lg border border-yellow-200 bg-yellow-50/50 px-4 py-3 text-yellow-800 text-sm">
              <p className="font-medium">Classification completed with issues:</p>
              <p className="mt-1">{result.error}</p>
            </div>
          )}
          
          {/* Display the model used for classification */}
          {result.modelUsed && (
            <div className="mb-6 rounded-lg border border-blue-200 bg-blue-50/50 px-4 py-3 text-blue-800 text-sm">
              <p className="font-medium">Model Used:</p>
              <p className="mt-1">{result.modelUsed}</p>
            </div>
          )}
          
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            {/* Only show UNSPSC Type for UNSPSC system with valid segment classification */}
            {result.system_code === 'UNSPSC' && result.levels?.segment?.code && (
              <div className="lg:col-span-2 bg-white rounded-lg border border-secondary-200 p-6 shadow-sm">
                <div className="flex items-start space-x-4">
                  <div className="bg-primary-50 w-14 h-14 flex items-center justify-center rounded-xl shadow-sm">
                    <svg className="w-7 h-7 text-primary-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                    </svg>
                  </div>
                  <div className="flex-1 min-w-0">
                    <label className="block text-sm font-medium text-secondary-900 mb-1">UNSPSC Type</label>
                    <div className="flex items-center gap-2">
                      {/* UNSPSC Type based on segment code */}
                      {['1', '2', '3', '4'].some(prefix => result.levels.segment?.code?.startsWith(prefix)) ? (
                        <span className="bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded-full">GOOD</span>
                      ) : ['7', '8', '9'].some(prefix => result.levels.segment?.code?.startsWith(prefix)) ? (
                        <span className="bg-purple-100 text-purple-800 text-xs font-medium px-2.5 py-0.5 rounded-full">SERVICE</span>
                      ) : ['5', '6'].some(prefix => result.levels.segment?.code?.startsWith(prefix)) ? (
                        <span className="bg-amber-100 text-amber-800 text-xs font-medium px-2.5 py-0.5 rounded-full">OTHER</span>
                      ) : (
                        <span className="bg-gray-100 text-gray-800 text-xs font-medium px-2.5 py-0.5 rounded-full">UNCLASSIFIED</span>
                      )}
                      <span className="text-sm text-secondary-600">
                        {result.levels.segment ? `Based on segment code ${result.levels.segment.code}` : 'Segment not classified'}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            )}
            {systemLevels.map((level, index) => {
              const categoryLevel = result.levels[level.code];
              const colors = getLevelClasses(index);

              // If no categoryLevel exists for this level
              if (!categoryLevel) {
                return (
                  <div key={level.code} className="bg-white rounded-lg border border-red-200 p-6 shadow-sm hover:shadow-md transition-shadow">
                    <div className="flex items-start space-x-4">
                      <div className="bg-red-50 w-14 h-14 flex items-center justify-center rounded-xl shadow-sm shrink-0">
                        <span className="text-red-600 font-bold text-lg">
                          {String(index + 1).padStart(2, '0')}
                        </span>
                      </div>
                      <div className="flex-1 min-w-0">
                        <label className="block text-sm font-medium text-secondary-900 mb-1">{level.name}</label>
                        <div className="text-red-600 text-sm">
                          Failed to classify at this level
                        </div>
                      </div>
                    </div>
                  </div>
                );
              }
              
              return (
                <div key={level.code} className="bg-white rounded-lg border border-secondary-200 p-6 shadow-sm hover:shadow-md transition-shadow">
                  <div className="flex items-start space-x-4">
                    <div className={`${colors.bg} w-14 h-14 flex items-center justify-center rounded-xl shadow-sm shrink-0`}>
                      <span className={`${colors.text} font-bold text-lg`}>
                        {String(index + 1).padStart(2, '0')}
                      </span>
                    </div>
                    <div className="flex-1 min-w-0">
                      <label className="block text-sm font-medium text-secondary-900 mb-1">{level.name}</label>
                      <div className="space-y-1">
                        {categoryLevel.code === "NO_MATCH" ? (
                          <div className="text-red-600 font-medium text-sm">
                            No matching category found at this level
                          </div>
                        ) : (
                          <>
                            <div className="text-sm font-semibold text-secondary-800">{categoryLevel.code}</div>
                            <div className="text-sm text-secondary-600">{categoryLevel.name}</div>
                            {categoryLevel.description && categoryLevel.description !== categoryLevel.name && (
                              <div className="text-xs text-secondary-500 mt-1.5">{categoryLevel.description}</div>
                            )}
                            {categoryLevel.error && (
                              <div className="text-amber-600 text-xs mt-1.5">
                                {categoryLevel.error}
                              </div>
                            )}
                          </>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>

          {/* RAG Context Display Section */}
          {result.ragContextUsed && (
            <div className="mt-6 pt-4 border-t border-secondary-200">
              <div className="flex items-center space-x-2 mb-2">
                <InformationCircleIcon className="h-5 w-5 text-blue-500" />
                <h4 className="text-sm font-medium text-secondary-700">
                  Context Used for Classification (from RAG)
                </h4>
              </div>
              <div className="text-xs bg-secondary-50 border border-secondary-200 rounded p-3 max-h-40 overflow-y-auto">
                <pre className="whitespace-pre-wrap font-mono text-secondary-600">
                  {result.ragContext || 'No specific context text available.'}
                </pre>
              </div>
            </div>
          )}

          {/* LLM Response Tabs */}
          {((result.levelResponses && Object.keys(result.levelResponses).length > 0) || Object.keys(levelResponses).length > 0) && (
            <div className="mt-6 pt-4 border-t border-secondary-200">
              <div className="flex items-center space-x-2 mb-2">
                <h4 className="text-sm font-medium text-secondary-700">
                  LLM Response by Level
                </h4>
              </div>
              
              {/* Tab Navigation */}
              <div className="border-b border-secondary-200">
                <nav className="flex -mb-px space-x-6 overflow-x-auto">
                  {systemLevels.filter(level => result.levels[level.code]).map((level) => (
                    <button
                      key={level.code}
                      onClick={() => setActiveLlmTab(level.code)}
                      className={`py-2 px-1 font-medium text-sm border-b-2 whitespace-nowrap ${
                        activeLlmTab === level.code
                          ? 'border-primary-500 text-primary-600'
                          : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'
                      } transition-colors duration-200`}
                    >
                      {level.name} Classification
                    </button>
                  ))}
                </nav>
              </div>
              
              {/* Tab Panels */}
              <div className="mt-3">
                {systemLevels.filter(level => result.levels[level.code]).map((level) => (
                  <div 
                    key={level.code}
                    className={`${activeLlmTab === level.code ? 'block' : 'hidden'} text-xs bg-secondary-50 border border-secondary-200 rounded p-3 max-h-60 overflow-y-auto`}
                  >
                    {renderMarkdown(levelResponses[level.code] || 'No LLM response available for this level.')}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}

      <ManualClassificationModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onSubmit={handleManualClassification}
        apiClient={apiClient}
        description={description}
        systemCode={selectedSystem}
        initialLevels={result?.levels ? Object.fromEntries(
          Object.entries(result.levels).map(([code, category]) => [code, category.code])
        ) : undefined}
      />
    </div>
  );
};


File: src/components/README.md
# System Configuration Components

This directory contains components for displaying system configuration in a user-friendly way.

## Components

### ConfigValue

A reusable component for rendering different types of configuration values. Features:
- Masks sensitive data (password, apiKey, etc.)
- Formats boolean values with color-coded styling
- Handles complex objects and arrays with summary views
- Supports custom styling via className prop

```tsx
<ConfigValue configKey="apiKey" value="secret" />        // Renders: ********
<ConfigValue configKey="enabled" value={true} />         // Renders: True (with green styling)
<ConfigValue configKey="items" value={[1, 2, 3]} />     // Renders: Array[3]
```

### Settings

Main configuration display component that shows system settings in an organized, collapsible format:
- Groups RAG-related settings separately
- Supports nested configuration objects
- Provides expandable/collapsible sections
- Uses ConfigValue for consistent value rendering

## Testing

Tests are written using React Testing Library and cover:
- Value rendering for different data types
- Sensitive data masking
- Boolean value styling
- Complex object handling
- Custom styling support

## Development

To modify these components:

1. Ensure all tests pass:
```bash
npm test
```

2. Use ConfigValue for any new configuration value rendering
3. Update tests when adding new functionality
4. Document any new features or changes

## Dependencies

- React Testing Library
- Jest DOM utilities
- TypeScript type definitions

File: src/components/ManualClassificationModal.tsx
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import Select, { 
  SingleValue, 
  InputActionMeta,
  GroupBase 
} from 'react-select';
import debounce from 'lodash/debounce';
import {
  ApiClient,
  ClassificationLevel,
  Category,
  ManualClassificationRequest,
  ClassificationResult,
  SystemCategoriesRequest
} from '../api/types';

// Constants
const SEARCH_DEBOUNCE_MS = 300;
const MIN_SEARCH_CHARS = 2;
const SELECT_STYLES = {
  menuPortal: (base: any) => ({ ...base, zIndex: 9999 }),
  menu: (base: any) => ({ ...base, zIndex: 9999 })
};

// Types
interface CategoryOption {
  value: string;
  label: string;
  data: Category;
}

interface ManualClassificationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (result: ClassificationResult) => void;
  apiClient: ApiClient;
  description: string;
  systemCode: string;
  initialLevels?: { [levelCode: string]: string };
}

interface LevelState {
  loading: boolean;
  error: string | null;
  options: Category[];
}

// Initial state
const INITIAL_LEVEL_STATE: LevelState = {
  loading: false,
  error: null,
  options: []
};

// Utility functions
const transformCategoryToOption = (category: Category): CategoryOption => ({
  value: category.code,
  label: `${category.code} - ${category.name}`,
  data: category
});

const transformCategoriesToOptions = (categories: Category[]): CategoryOption[] => 
  categories.map(transformCategoryToOption);

export const ManualClassificationModal: React.FC<ManualClassificationModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  apiClient,
  description,
  systemCode,
  initialLevels,
}) => {
  const [selectedCategories, setSelectedCategories] = useState<{ [levelCode: string]: string }>(initialLevels || {});
  const [levels, setLevels] = useState<ClassificationLevel[]>([]);
  const [levelStates, setLevelStates] = useState<{ [levelCode: string]: LevelState }>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const levelSequence = useMemo(() => 
    levels.sort((a, b) => a.levelNumber - b.levelNumber).map(level => level.code), 
    [levels]
  );

  useEffect(() => {
    if (!isOpen) return;

    const initializeLevelStates = () => {
      setLevelStates(prev => {
        const newStates = { ...prev };
        levels.forEach(level => {
          if (!newStates[level.code]) {
            newStates[level.code] = { ...INITIAL_LEVEL_STATE };
          }
        });
        return newStates;
      });
    };

    // Reset selected categories when modal opens
    if (initialLevels) {
      setSelectedCategories(initialLevels);
    } else {
      setSelectedCategories({});
    }

    initializeLevelStates();
  }, [levels, isOpen, initialLevels]);

  useEffect(() => {
    let mounted = true;

    const loadInitialData = async () => {
      if (!isOpen) return;
      // Add guard clause to prevent API call with undefined systemCode
      if (!systemCode) {
        setError('System code is not provided.');
        console.error('Attempted to load initial data without a system code.');
        setLoading(false); // Ensure loading state is reset
        return;
      }
      
      try {
        setError(null);
        setLoading(true);
        
        const { levels: systemLevels } = await apiClient.getClassificationSystem(systemCode);
        if (!mounted) return;
        
        const sortedLevels = systemLevels.sort((a, b) => a.levelNumber - b.levelNumber);
        setLevels(sortedLevels);

        // Initialize all level states
        const initialStates: { [key: string]: LevelState } = {};
        sortedLevels.forEach(level => {
          initialStates[level.code] = { ...INITIAL_LEVEL_STATE };
        });
        setLevelStates(initialStates);

        // Load initial categories for levels with selected values
        if (initialLevels && mounted) {
          // Load levels sequentially to maintain parent-child relationships
          for (const level of sortedLevels) {
            const parentLevel = sortedLevels.find(l => l.levelNumber === level.levelNumber - 1);
            const parentCode = parentLevel ? selectedCategories[parentLevel.code] : undefined;
            
            // Load categories for this level
            await loadLevelCategories(level.code, parentCode);

            // Pre-select the category if it exists in initialLevels
            if (level.code in initialLevels) {
              setSelectedCategories(prev => ({
                ...prev,
                [level.code]: initialLevels[level.code]
              }));
            }
          }
        }
      } catch (error) {
        if (!mounted) return;
        setError(error instanceof Error ? error.message : 'Failed to load system levels');
        console.error('Failed to load system levels:', error);
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };

    loadInitialData();
    return () => { mounted = false; };
  }, [apiClient, systemCode, isOpen, initialLevels]);

  const loadLevelCategories = useCallback(async (
    levelCode: string,
    parentCode?: string,
    search?: string
  ) => {
    console.debug('Loading categories:', { levelCode, parentCode, search });
    
    setLevelStates(prev => ({
      ...prev,
      [levelCode]: {
        ...prev[levelCode],
        loading: true,
        error: null
      }
    }));
    
    try {
      const request: SystemCategoriesRequest = {
        systemCode,
        level: levelCode,
        parentCode,
        search: search?.trim()
      };

      const categories = await apiClient.getSystemCategories(request);
      
      console.debug('Categories loaded:', {
        levelCode,
        parentCode,
        count: categories.length,
        categories: categories.map(c => `${c.code} - ${c.name}`)
      });
      
      setLevelStates(prev => ({
        ...prev,
        [levelCode]: {
          loading: false,
          error: null,
          options: categories
        }
      }));
    } catch (error) {
      const message = error instanceof Error ? error.message : `Failed to load categories for ${levelCode}`;
      console.error('Category loading error:', { levelCode, parentCode, error });
      
      setLevelStates(prev => ({
        ...prev,
        [levelCode]: {
          ...prev[levelCode],
          loading: false,
          error: message
        }
      }));
    }
  }, [apiClient, systemCode]);

  const debouncedLoadCategories = useMemo(
    () => debounce(loadLevelCategories, SEARCH_DEBOUNCE_MS),
    [loadLevelCategories]
  );

  const getParentLevelCode = useCallback((currentLevelCode: string): string | undefined => {
    const currentLevel = levels.find(l => l.code === currentLevelCode);
    if (!currentLevel) return undefined;
    
    const parentLevel = levels.find(l => l.levelNumber === currentLevel.levelNumber - 1);
    return parentLevel?.code;
  }, [levels]);

  const handleCategoryChange = useCallback(async (
    levelCode: string, 
    option: SingleValue<CategoryOption>
  ) => {
    const level = levels.find(l => l.code === levelCode);
    if (!level) return;

    const levelIndex = levelSequence.indexOf(levelCode);
    if (levelIndex === -1) return;

    const categoryCode = option?.value || '';

    setSelectedCategories(prev => {
      const newSelected = { ...prev };
      // Clear subsequent levels
      levelSequence.slice(levelIndex + 1).forEach(nextLevel => {
        delete newSelected[nextLevel];
      });
      
      if (categoryCode) {
        newSelected[levelCode] = categoryCode;
      } else {
        delete newSelected[levelCode];
      }
      
      return newSelected;
    });

    // Clear states for subsequent levels
    setLevelStates(prev => {
      const newStates = { ...prev };
      levelSequence.slice(levelIndex + 1).forEach(nextLevel => {
        newStates[nextLevel] = { ...INITIAL_LEVEL_STATE };
      });
      return newStates;
    });

    // Load next level's categories if a category was selected
    if (categoryCode) {
      const nextLevelCode = levelSequence[levelIndex + 1];
      if (nextLevelCode) {
        await loadLevelCategories(nextLevelCode, categoryCode);
      }
    }
  }, [levels, levelSequence, loadLevelCategories]);

  const handleInputChange = useCallback((
    levelCode: string,
    newValue: string,
    actionMeta: InputActionMeta
  ) => {
    if (actionMeta.action !== 'input-change') return;

    const parentLevelCode = getParentLevelCode(levelCode);
    const parentCategoryCode = parentLevelCode ? selectedCategories[parentLevelCode] : undefined;

    if (newValue.length >= MIN_SEARCH_CHARS) {
      debouncedLoadCategories(levelCode, parentCategoryCode, newValue);
    } else if (newValue.length === 0) {
      loadLevelCategories(levelCode, parentCategoryCode);
    }
  }, [debouncedLoadCategories, loadLevelCategories, getParentLevelCode, selectedCategories]);

  const handleSubmit = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const request: ManualClassificationRequest = {
        description,
        systemCode,
        levels: selectedCategories,
      };
      
      const result = await apiClient.classifyManually(request);
      onSubmit(result);
      onClose();
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Classification failed';
      console.error('Classification error:', error);
      setError(message);
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6 space-y-6">
          <div className="flex justify-between items-center">
            <h2 className="text-xl font-semibold text-secondary-900">
              Manual Classification
            </h2>
            <button
              onClick={onClose}
              className="text-secondary-500 hover:text-secondary-700"
            >
              <span className="sr-only">Close</span>
              <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          <div className="border rounded-lg p-4 bg-secondary-50 text-sm">
            <p className="font-medium">Description:</p>
            <p className="mt-1">{description}</p>
          </div>

          <div className="space-y-4">
            {levels.map((level, index) => {
              const levelState = levelStates[level.code] || { ...INITIAL_LEVEL_STATE };
              const isDisabled = index > 0 && !selectedCategories[levels[index - 1].code];
              const selectedValue = selectedCategories[level.code];
              const selectedOption = selectedValue 
                ? levelState.options.find(cat => cat.code === selectedValue)
                : null;
              
              return (
                <div key={level.code} className="space-y-2">
                  <label className="block text-sm font-medium text-secondary-700">
                    {level.name}:
                  </label>
                  <Select<CategoryOption, false, GroupBase<CategoryOption>>
                    value={selectedOption ? transformCategoryToOption(selectedOption) : null}
                    onChange={(option) => handleCategoryChange(level.code, option)}
                    options={transformCategoriesToOptions(levelState.options)}
                    onInputChange={(newValue, actionMeta) => 
                      handleInputChange(level.code, newValue, actionMeta)
                    }
                    isDisabled={isDisabled || levelState.loading}
                    isLoading={levelState.loading}
                    placeholder={`Search ${level.name}...`}
                    noOptionsMessage={({inputValue}) => 
                      inputValue.length < MIN_SEARCH_CHARS 
                        ? `Type ${MIN_SEARCH_CHARS} or more characters to search...` 
                        : "No options found"
                    }
                    isClearable
                    menuPortalTarget={document.body}
                    styles={SELECT_STYLES}
                    classNamePrefix="react-select"
                  />
                  {levelState.error && (
                    <div className="text-sm text-red-600">
                      {levelState.error}
                    </div>
                  )}
                </div>
              );
            })}
          </div>

          {error && (
            <div className="rounded-lg border border-red-200 bg-red-50/50 px-4 py-3 text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="flex justify-end space-x-4">
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm font-medium text-secondary-700 hover:text-secondary-800 focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2"
              disabled={loading}
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              disabled={loading || Object.keys(selectedCategories).length === 0}
              className={`px-4 py-2 text-sm font-medium text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 ${
                loading || Object.keys(selectedCategories).length === 0
                  ? 'bg-secondary-400 cursor-not-allowed'
                  : 'bg-primary-600 hover:bg-primary-700 focus:ring-primary-500'
              }`}
            >
              {loading ? (
                <div className="flex items-center space-x-2">
                  <svg className="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                  </svg>
                  <span>Saving...</span>
                </div>
              ) : (
                'Save Classification'
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};


File: src/constants/LeftSidebar.constants.ts
// src/constants/LeftSidebar.constants.ts
import {
  HomeOutlined,         // Test
  FileTextOutlined,     // Batch
  AppstoreOutlined,     // Batch Jobs (or use something else)
  HistoryOutlined,      // History
  MessageOutlined,      // Chat (Ant Design)
  DatabaseOutlined,     // RAG Info
  ShareAltOutlined,     // LangGraph (or BulbOutlined, PlayCircleOutlined, ApartmentOutlined)
  UserOutlined,         // Admin Users
  TeamOutlined,         // Admin Roles (or SafetyCertificateOutlined)
  SettingOutlined,      // Settings
  LogoutOutlined,       // Logout
  PlusOutlined,         // Needed for sub-items like "Create Graph"
  // UnorderedListOutlined, // Example for sub-item, if needed
} from '@ant-design/icons';
import { LeftSidebarItem } from '../components/Sidebar/LeftSidebar.interface';
import { SidebarItem as SidebarItemEnum } from '../enum/sidebar.enum';

export const SIDEBAR_NESTED_KEYS: Record<string, string> = {
  '/batch/jobs': SidebarItemEnum.BATCH,
  // If you have /view/:id, /create, etc., and want the main LangGraph item to stay highlighted:
  [SidebarItemEnum.LANGGRAPH_VIEW]: SidebarItemEnum.LANGGRAPH_LIST,
  [SidebarItemEnum.LANGGRAPH_CREATE]: SidebarItemEnum.LANGGRAPH_LIST,
  [SidebarItemEnum.LANGGRAPH_EDIT]: SidebarItemEnum.LANGGRAPH_LIST, // If you add edit
  // Add your existing nested keys for admin, history etc.
  '/admin/users/edit': SidebarItemEnum.ADMIN_USERS, // Assuming you might have edit sub-routes
  '/admin/roles/edit': SidebarItemEnum.ADMIN_ROLES,
  '/history/details': SidebarItemEnum.HISTORY, // Added from previous context
};

// Base items before dynamic insertions
export const SIDEBAR_ITEMS: LeftSidebarItem[] = [
  {
    key: SidebarItemEnum.TEST,
    title: 'Test',
    icon: HomeOutlined,
    dataTestId: 'test-sidebar-item', // Changed dataTestId for clarity
    redirect_url: SidebarItemEnum.TEST,
    requiredPermission: 'classify:item', // Example permission
  },
  {
    key: SidebarItemEnum.BATCH,
    title: 'Batch',
    icon: FileTextOutlined,
    dataTestId: 'batch-sidebar-item',
    redirect_url: SidebarItemEnum.BATCH,
    requiredPermission: 'classify:batch',
    // disableExpandIcon: true, // Remove if children are present and you want auto-expand icon
    children: [
      {
        key: SidebarItemEnum.BATCH_JOBS,
        title: 'Batch Jobs',
        icon: AppstoreOutlined,
        dataTestId: 'batch-jobs-sidebar-item',
        redirect_url: SidebarItemEnum.BATCH_JOBS,
        requiredPermission: 'classify:batch', // Same as parent or more specific
      },
    ],
  },
  {
    key: SidebarItemEnum.HISTORY,
    title: 'History',
    icon: HistoryOutlined,
    dataTestId: 'history-sidebar-item',
    redirect_url: SidebarItemEnum.HISTORY,
    requiredPermission: 'history:view',
  },
  // CHAT_SIDEBAR_ITEM, RAG_INFO_SIDEBAR_ITEM, LANGGRAPH_VIS_SIDEBAR_ITEM will be inserted dynamically
];

// Define items to be dynamically inserted
export const CHAT_SIDEBAR_ITEM: LeftSidebarItem = {
    key: SidebarItemEnum.CHAT,
    title: 'Chat',
    icon: MessageOutlined,
    dataTestId: 'chat-sidebar-item',
    redirect_url: SidebarItemEnum.CHAT,
    requiredPermission: 'chat:use', // Example permission
};

export const RAG_INFO_SIDEBAR_ITEM: LeftSidebarItem = {
    key: SidebarItemEnum.RAG_INFO,
    title: 'Information ', 
    icon: DatabaseOutlined,
    dataTestId: 'rag-info-sidebar-item',
    redirect_url: SidebarItemEnum.RAG_INFO,
    requiredPermission: 'rag:view',
};

export const LANGGRAPH_VIS_SIDEBAR_ITEM: LeftSidebarItem = {
    key: SidebarItemEnum.LANGGRAPH_LIST,
    title: 'Workflows', 
    icon: ShareAltOutlined, // Example icon, choose one you like
    dataTestId: 'langgraph-sidebar-item',
    redirect_url: SidebarItemEnum.LANGGRAPH_LIST,
    requiredPermission: 'langgraph:view', // Example permission
    // If you want sub-menu items like "Create New" or "View X":
    children: [
      // {
      //   key: SidebarItemEnum.LANGGRAPH_LIST, // Would be redundant if parent links here
      //   title: 'View Graphs',
      //   icon: UnorderedListOutlined, // Example
      //   dataTestId: 'view-graphs-item',
      //   redirect_url: SidebarItemEnum.LANGGRAPH_LIST,
      // },
      {
        key: SidebarItemEnum.LANGGRAPH_CREATE,
        title: 'Create Graph',
        icon: PlusOutlined,
        dataTestId: 'create-graph-item',
        redirect_url: SidebarItemEnum.LANGGRAPH_CREATE,
        requiredPermission: 'langgraph:create',
      },
    ]
};

export const ADMIN_SIDEBAR_ITEMS: LeftSidebarItem[] = [
    {
        key: SidebarItemEnum.ADMIN_USERS,
        title: 'Users',
        icon: UserOutlined,
        dataTestId: 'admin-users-sidebar-item',
        redirect_url: SidebarItemEnum.ADMIN_USERS,
        requiredPermission: 'users:view', // Or users:manage if view is tied to manage
    },
    {
        key: SidebarItemEnum.ADMIN_ROLES,
        title: 'Roles',
        icon: TeamOutlined,
        dataTestId: 'admin-roles-sidebar-item',
        redirect_url: SidebarItemEnum.ADMIN_ROLES,
        requiredPermission: 'roles:view', // Or roles:manage
    },
];

// Bottom items remain the same
export const SETTING_ITEM: LeftSidebarItem = {
  key: SidebarItemEnum.SETTINGS,
  title: 'Settings',
  redirect_url: SidebarItemEnum.SETTINGS,
  icon: SettingOutlined,
  dataTestId: 'settings-sidebar-item',
  requiredPermission: 'config:view',
};

export const LOGOUT_ITEM: LeftSidebarItem = {
  key: SidebarItemEnum.LOGOUT,
  title: 'Logout',
  icon: LogoutOutlined,
  dataTestId: 'logout-sidebar-item',
  // No redirect_url, onClick is handled in LeftSidebar.component.tsx
};

export const BOTTOM_SIDEBAR_ITEMS: LeftSidebarItem[] = [SETTING_ITEM, LOGOUT_ITEM];

File: src/components/LoginForm.tsx
import React, { useState, FormEvent } from 'react';
import { ApiClient, LoginResponse, User } from '../api/types'; // Updated import to include LoginResponse and User types

interface LoginFormProps {
    apiClient: ApiClient;
    onLoginSuccess: () => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ apiClient, onLoginSuccess }) => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        setError(null);
        setLoading(true);

        try {
            const response: LoginResponse = await apiClient.login(username, password); // Assuming login method exists
            console.log('Login successful:', response.user);

            // Store the token (e.g., in localStorage)
            if (response.token) {
                localStorage.setItem('authToken', response.token); // Store the token
                localStorage.setItem('userInfo', JSON.stringify(response.user)); // Store user info
                onLoginSuccess(); // Callback to notify App.tsx
            } else {
                setError('Login failed: No token received.');
            }
        } catch (err) {
            console.error('Login error:', err);
            setError(err instanceof Error ? err.message : 'Login failed. Please check your credentials.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-6">
            {error && (
                <div className="rounded-md border border-red-200 bg-red-50 p-3 text-sm text-red-700">
                    {error}
                </div>
            )}
            <div>
                <label htmlFor="username" className="label">
                    Username
                </label>
                <input
                    id="username"
                    type="text"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    required
                    className="input" // Use global style
                    disabled={loading}
                    autoComplete="username"
                />
            </div>
            <div>
                <label htmlFor="password" className="label">
                    Password
                </label>
                <input
                    id="password"
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    required
                    className="input" // Use global style
                    disabled={loading}
                    autoComplete="current-password"
                />
            </div>
            <div>
                <button
                    type="submit"
                    className="w-full btn btn-primary" // Use global styles
                    disabled={loading}
                >
                    {loading ? 'Logging in...' : 'Login'}
                </button>
            </div>
        </form>
    );
};

export default LoginForm;

File: src/config/api.ts
const isProd = process.env.NODE_ENV === 'production';

// Base configuration for API endpoints
export const API_CONFIG = {
  baseUrl: '/api', // Use relative URL in all environments to leverage Vite's proxy
  version: 'v1',
  getFullBaseUrl: () => {
    return `/v1`; // Use relative URL to leverage Vite's proxy
  }
};

export const API_HEADERS = {
  'Content-Type': 'application/json',
  'Accept': 'application/json',
};

export const API_ENDPOINTS = {
  systems: {
    list: '/systems',
    get: '/systems/{code}',
  },
  classify: {
    auto: '/classify',
    manual: '/classify/manual',
    batch: '/classify/batch'
  },
  history: '/history',
  batch: {
    create: '/classify/batch',
    jobs: '/batch/jobs',
    status: '/batch/jobs/{id}'
  },
  // --- User Management Endpoints ---
  users: {
    list: '/users',
    create: '/users',
    get: '/users/{id}',
    update: '/users/{id}',
    delete: '/users/{id}',
    roles: '/users/{id}/roles'
  },
  roles: {
    list: '/roles',
    create: '/roles',
    update: '/roles/{id}',
    delete: '/roles/{id}'
  },
  permissions: {
    list: '/permissions'
  },
  auth: {
    config: '/auth/config',
    login: '/auth/login',
    currentUser: '/auth/me'
  },
  // --- RAG Endpoints ---
  ragInfo: {
    list: '/rag-info',      // GET (with pagination/filter params)
    create: '/rag-info',    // POST
    get: '/rag-info/{id}', // GET
    update: '/rag-info/{id}', // PUT or PATCH
    delete: '/rag-info/{id}'  // DELETE
  },
  // Add endpoint for frontend config if needed
  frontendConfig: '/config/frontend',
  chat: { 
    completions: '/chat/completions', 
  },
};

export const formatEndpoint = (endpoint: string, params?: Record<string, string>): string => {
  let formattedEndpoint = endpoint;
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      formattedEndpoint = formattedEndpoint.replace(`{${key}}`, value);
    });
  }
  
  return `${API_CONFIG.getFullBaseUrl()}${formattedEndpoint}`;
};


File: src/components/HistoryTab.tsx
// src/components/HistoryTab.tsx
import React, { useEffect, useState, useCallback } from 'react'; // Added useCallback
import { Tooltip } from 'antd'; // Import Tooltip
import { ApiClient, ClassificationHistory, ClassificationSourceType, ClassificationStatus, ClassificationSystem } from '../api/types';
import { ManualClassificationModal } from './ManualClassificationModal';
import { RerunStatusModal } from './RerunStatusModal';
import { ClassificationDetailsModal } from './ClassificationDetailsModal';
import { formatDate } from '../utils/dateFormat';
import { useAuth } from '../context/AuthContext'; // Import useAuth hook

interface HistoryTabProps {
  apiClient: ApiClient;
}

export const HistoryTab: React.FC<HistoryTabProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  const [history, setHistory] = useState<ClassificationHistory[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize] = useState(10); // Keep pageSize constant
  const [totalPages, setTotalPages] = useState(1);
  const [pageCursors, setPageCursors] = useState<string[]>([]); // Store cursors for next pages
  const [loading, setLoading] = useState(false);
  const [systems, setSystems] = useState<ClassificationSystem[]>([]);
  const [selectedSystem, setSelectedSystem] = useState<string>();
  const [error, setError] = useState<string>();
  const [showManualModal, setShowManualModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState<ClassificationHistory | null>(null);
  const [showRerunModal, setShowRerunModal] = useState(false);
  const [rerunningItem, setRerunningItem] = useState<ClassificationHistory | null>(null);
  
  // State for the classification details modal
  const [showDetailsModal, setShowDetailsModal] = useState(false);
  const [detailsItem, setDetailsItem] = useState<ClassificationHistory | null>(null);

  // Filter states
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedStatus, setSelectedStatus] = useState<ClassificationStatus>('all');
  const [selectedSource, setSelectedSource] = useState<ClassificationSourceType>();
  const [selectedClassifier, setSelectedClassifier] = useState('');
  const [classifierOptions, setClassifierOptions] = useState<string[]>([]);
  const [startDate, setStartDate] = useState<string>(() => {
    const date = new Date();
    date.setDate(date.getDate() - 7);
    return date.toISOString().split('T')[0];
  });
  const [endDate, setEndDate] = useState<string>(() => {
    return new Date().toISOString().split('T')[0];
  });

  const informationalErrorMessages = [
    "Classification failed to determine required levels",
    "Classification failed to determine required levels.",
    "No matching category found at this level",
    "Failed to classify at this level",
    "Classification is partial; some levels may be missing or invalid.",
    "Classification is partial.", // Matches backend's informational message for partial
    "Classification failed.",   // Matches backend's informational message for failed
  ];

  const isInformationalError = (errorMessage?: string): boolean => {
    if (!errorMessage) return false;
    const lowerMessage = errorMessage.toLowerCase();
    return informationalErrorMessages.some(msg => lowerMessage.includes(msg.toLowerCase()));
  };

  useEffect(() => {
    const loadSystems = async () => {
      try {
        const systemList = await apiClient.getClassificationSystems();
        console.log('Loaded systems:', systemList);
        setSystems(systemList);
      } catch (err) {
        console.error('Failed to load systems:', err);
        setError('Failed to load classification systems');
      }
    };
    loadSystems();
  }, [apiClient]);

  const loadHistory = useCallback(async (targetPage: number = currentPage, cursorToUse?: string) => {
    setLoading(true);
    setError(undefined);
    try {
      const pageToLoad = targetPage;
      let effectiveCursor = cursorToUse;      // If we have a cursor to use (passed in), use it
      // For page 1, we always use undefined (no cursor)
      if (pageToLoad === 1) {
        effectiveCursor = undefined; // Always no cursor for page 1
      }
      // Otherwise use the provided cursor
      // The cursorToUse should be provided by the effect that tracks currentPage changes
      
      console.debug('[History] Loading data:', {
        page: pageToLoad,
        cursor: effectiveCursor,
        filters: {
          system: selectedSystem,
          status: selectedStatus === 'all' ? undefined : selectedStatus,
          search: searchTerm.trim() || undefined,
          sourceType: selectedSource || undefined,
          createdBy: selectedClassifier || undefined,
          startDate,
          endDate: endDate ? new Date(endDate + 'T23:59:59').toISOString() : undefined,
        }
      });

      const result = await apiClient.getClassificationHistory({
        systemCode: selectedSystem,
        cursor: effectiveCursor,
        limit: pageSize,
        status: selectedStatus === 'all' ? undefined : selectedStatus,
        startDate,
        endDate: endDate ? new Date(endDate + 'T23:59:59').toISOString() : undefined,
        search: searchTerm.trim() || undefined,
        sourceType: selectedSource || undefined,
        createdBy: selectedClassifier || undefined
      });
        console.debug('[History] Raw API Response:', result);
      console.debug('[History] First item from API:', result.items?.[0]);
        const firstItem = result.items?.[0];
      if (firstItem) {
        console.debug('[History] First item firstLevelPrompt:', firstItem.firstLevelPrompt);
        console.debug('[History] First item allPromptsDetail:', firstItem.allPromptsDetail);        
        console.debug('[History] First item properties:', 
          Object.keys(firstItem).map(key => {
            const value = firstItem[key as keyof typeof firstItem];
            return `${key}: ${typeof value}`;
          }).join(', '));
      }


      if (!result.items) {
        console.warn('No items array in history response');
        setHistory([]);
        setTotalCount(0);
        setTotalPages(1);
        if (pageToLoad > 1) setCurrentPage(1); // Reset to page 1 if current page had no items
        setPageCursors([]); // Reset cursors
        return;
      }

      setHistory(result.items);
      setTotalCount(result.totalCount);
      setTotalPages(Math.ceil(result.totalCount / pageSize) || 1);      if (result.nextCursor) {
        setPageCursors(prev => {
          const newCursors = [...prev];
          // Cursor returned when fetching page N is the cursor *for* page N+1
          // Store at index N-1 (0-indexed array where index corresponds to page-1)
          if (pageToLoad - 1 < newCursors.length) {
            newCursors[pageToLoad - 1] = result.nextCursor!;
          } else {
            // Ensure array is long enough, filling gaps with undefined if necessary
            for (let i = newCursors.length; i < pageToLoad - 1; i++) {
              newCursors.push(undefined as unknown as string);
            }
            newCursors.push(result.nextCursor!);
          }
          console.debug('[History] Updated pageCursors:', newCursors);
          return newCursors;
        });
      }


    } catch (err) {
      console.error('Failed to load history:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to load classification history';
      setError(`Error loading history: ${errorMessage}`);
      setHistory([]);
      setTotalCount(0);
      setTotalPages(1);
      setCurrentPage(1);
      setPageCursors([]);    } finally {
      setLoading(false);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [apiClient, selectedSystem, selectedStatus, startDate, endDate, searchTerm, selectedSource, selectedClassifier, pageSize]); // pageCursors and currentPage removed from deps of loadHistory
  const handlePageChange = (page: number) => {
      if (page === currentPage || loading) return; // Prevent re-fetch if same page or already loading
      setCurrentPage(page);
      // loadHistory will be called by the effect watching currentPage
  };

  useEffect(() => {
    const loadClassifiers = async () => {
      try {
        // Consider if limiting this initial fetch for classifiers is needed if it's slow
        const result = await apiClient.getClassificationHistory({ limit: 1000 }); 
        const uniqueClassifiers = [...new Set(result.items
          .map(item => item.createdBy))]
          .filter(Boolean) // Remove undefined/empty strings
          .sort();
        setClassifierOptions(uniqueClassifiers);
      } catch (err) {
        console.error('Failed to load classifiers:', err);
      }
    };
    loadClassifiers();
  }, [apiClient]);
  useEffect(() => {
    // This effect resets to page 1 and clears cursors when filters change
    console.debug('[History] Filter change detected, resetting page and cursors.');
    setCurrentPage(1);
    setPageCursors([]); // Clear cursors on filter change
    // The change in currentPage will trigger the next useEffect to load data for page 1
  }, [selectedSystem, selectedStatus, startDate, endDate, searchTerm, selectedSource, selectedClassifier]);
  useEffect(() => {
    // This effect handles loading data whenever currentPage changes OR when filters have reset currentPage to 1
    // Determine the cursor: For page 1, it's always undefined.
    // For page N > 1, it's pageCursors[N-2] (the cursor that led to page N-1 gives us the cursor for page N)
    const cursorForPageToFetch = currentPage === 1 ? undefined : pageCursors[currentPage - 2];
    console.debug(`[History] CurrentPage effect: loading page ${currentPage} with cursor "${cursorForPageToFetch}"`, {pageCursors});
    loadHistory(currentPage, cursorForPageToFetch);
  }, [currentPage, loadHistory]); // pageCursors is intentionally NOT a dependency to break the loop

  const handleReclassify = async (item: ClassificationHistory) => {
    if (!item.systemCode) {
      console.error('Cannot reclassify: systemCode is missing from history item.', item);
      setError('Cannot reclassify this item because its classification system is unknown.');
      return;
    }
    setSelectedItem(item);
    setShowManualModal(true);
  };

  const handleRerun = async (item: ClassificationHistory) => {
    if (!window.confirm('Are you sure you want to rerun this classification?')) { // Changed to window.confirm
      return;
    }

    setRerunningItem(item);
    setShowRerunModal(true);
    setError(undefined);

    try {
      const result = await apiClient.rerunClassification(String(item.id));
      
      if (result.error) {
        setError(`Rerun failed: ${result.error}`);
      }
      setCurrentPage(1);
      setPageCursors([]);
      await loadHistory(1);
    } catch (err) {
      console.error('Failed to rerun classification:', err);
      setError('Failed to start rerun');
    } finally {
      setShowRerunModal(false);
      setRerunningItem(null);
    }
  };

  const handleDelete = async (item: ClassificationHistory) => {
    if (!window.confirm('Are you sure you want to delete this classification? This action cannot be undone.')) { // Changed to window.confirm
      return;
    }

    setLoading(true);
    setError(undefined);
    try {
      await apiClient.deleteClassification(String(item.id));
      setCurrentPage(1);
      setPageCursors([]);
      await loadHistory(1);
    } catch (err) {
      console.error('Failed to delete classification:', err);
      setError('Failed to delete classification');
    } finally {
      setLoading(false);
    }
  };

  const handleManualClassification = async (result: any) => {
    console.debug('[Classification] Manual result:', {
      success: !result.error,
      error: result.error,
      description: result.description
    });

    if (result.error && !isInformationalError(result.error)) {
      setError(`Classification failed: ${result.error}`);
    } else if (result.error && isInformationalError(result.error)) {
      setError(undefined);
      console.info(`Informational message from manual classification: ${result.error}`);
    }

    setCurrentPage(1);
    setPageCursors([]);
    await loadHistory(1);

    setShowManualModal(false);
    setSelectedItem(null);
  };

  const handleView = (item: ClassificationHistory) => {
    console.debug('Viewing details for history item:', item);
    setDetailsItem(item);
    setShowDetailsModal(true);
  };

  const getClassifierBadge = (createdBy: string) => {
    // ... (existing code for getClassifierBadge)
    if (!createdBy || createdBy === 'direct') { // Consider 'direct' or make it consistent from backend
        return (
          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-gray-100 text-gray-800 border-gray-200">
            Direct Input
          </span>
        );
      }
      // Check if createdBy looks like a user ID (number) or a batch ID (string, potentially non-numeric)
      if (/^\d+$/.test(createdBy)) { // If it's purely numeric, assume user ID
        return (
            <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-sky-100 text-sky-800 border-sky-200">
              User ID: {createdBy}
            </span>
          );
      }
      return (
        <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-purple-100 text-purple-800 border-purple-200">
          Batch: {createdBy}
        </span>
      );
  };

  const getSourceBadge = (sourceType?: ClassificationSourceType, createdBy?: string) => { // made params optional for safety
    const classes: Record<string, string> = {
      user: 'bg-blue-100 text-blue-800 border-blue-200',       
      manual: 'bg-blue-100 text-blue-800 border-blue-200',     
      batch: 'bg-purple-100 text-purple-800 border-purple-200',
      api: 'bg-gray-100 text-gray-800 border-gray-200',         
      ui: 'bg-teal-100 text-teal-800 border-teal-200',
      unknown: 'bg-gray-100 text-gray-800 border-gray-200'      
    };

    if (!sourceType) {
      return (
        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${classes.unknown}`}>
          Unknown
        </span>
      );
    }
    const sourceTypeLower = sourceType.toLowerCase();
    let label = 'Unknown';
    if (sourceTypeLower.includes('user') || sourceTypeLower.includes('manual')) label = 'Manual Input';
    else if (sourceTypeLower.includes('batch')) label = 'Batch';
    else if (sourceTypeLower === 'ui') label = 'UI (Web)';
    else if (sourceTypeLower.includes('api')) label = 'API Input';
    
    const detail = sourceTypeLower.includes('batch') && createdBy ? ` (${createdBy})` : '';
    let badgeClass = classes.unknown;
    for (const [key, value] of Object.entries(classes)) {
      if (sourceTypeLower.includes(key)) {
        badgeClass = value;
        break;
      }
    }
    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${badgeClass}`}>
        {label}{detail}
      </span>
    );
  };

  const getStatusBadge = (status: ClassificationStatus) => {
    // ... (existing code for getStatusBadge)
    if (status === 'all') {
        console.warn('Unexpected status "all" for individual item');
        return (
          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-gray-100 text-gray-800 border-gray-200">
            Unknown
          </span>
        );
      }
      
      const classes = {
        success: 'bg-green-100 text-green-800 border-green-200',
        partial: 'bg-yellow-100 text-yellow-800 border-yellow-200',
        failed: 'bg-red-100 text-red-800 border-red-200'
      };
      
      const labels = {
        success: 'Success',
        partial: 'Partial',
        failed: 'Failed'
      };
  
      return (
        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${classes[status]}`}>
          {labels[status]}
        </span>
      );
  };

  return (
    <React.Fragment>
      <div className="max-w-8xl mx-auto space-y-10" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
        <div className="bg-white shadow-card rounded-card p-8 w-full" style={{ paddingRight: '5rem', paddingLeft: '3rem'}}>
          <div className="mb-2">

            {/* Filters */}
            <div className="grid grid-cols-1 md:grid-cols-7 gap-4">
              {/* System filter */}
              <div>
                <label htmlFor="system" className="block text-sm font-medium text-secondary-700 mb-2">
                  System
                </label>
                <select
                  id="system"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedSystem || ''}
                  onChange={(e) => setSelectedSystem(e.target.value || undefined)}
                >
                  <option value="">All Systems</option>
                  {systems.map((system) => (
                    <option key={system.code} value={system.code}>
                      {system.name || system.code}
                    </option>
                  ))}
                </select>
              </div>

              {/* Search Description */}
              <div>
                <label htmlFor="search" className="block text-sm font-medium text-secondary-700 mb-2">
                  Search Description
                </label>
                <input
                  type="text"
                  id="search"
                  placeholder="Search..."
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>

              {/* Status filter */}
              <div>
                <label htmlFor="status" className="block text-sm font-medium text-secondary-700 mb-2">
                  Status
                </label>
                <select
                  id="status"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedStatus}
                  onChange={(e) => setSelectedStatus(e.target.value as ClassificationStatus)}
                >
                  <option value="all">All Status</option>
                  <option value="success">Success</option>
                  <option value="partial">Partial</option>
                  <option value="failed">Failed</option>
                </select>
              </div>

              {/* Source Type filter */}
              <div>
                <label htmlFor="sourceType" className="block text-sm font-medium text-secondary-700 mb-2">
                  Source Type
                </label>
                <select
                  id="sourceType"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedSource || ''} 
                  onChange={(e) => setSelectedSource(e.target.value as '' | 'user' | 'batch' | 'api' | 'manual')}
                >
                  <option value="">All Sources</option>
                  <option value="manual">Manual</option> 
                  <option value="api">API</option> 
                  <option value="batch">Batch</option>
                  <option value="user">User (Legacy)</option>
                </select>
              </div>

              {/* Classifier filter */}
              <div>
                <label htmlFor="classifier" className="block text-sm font-medium text-secondary-700 mb-2">
                  Classified By
                </label>
                <select
                  id="classifier"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedClassifier}
                  onChange={(e) => setSelectedClassifier(e.target.value)}
                >
                  <option value="">All</option>
                  {/* <option value="direct">Direct Input</option> -- consider how to filter user ID vs batch ID */}
                  {classifierOptions.map(opt => (
                    <option key={opt} value={opt}>
                        {/^\d+$/.test(opt) ? `User ID: ${opt}` : `Batch: ${opt}`}
                    </option>
                  ))}
                </select>
              </div>

              {/* Start Date filter */}
              <div>
                <label htmlFor="startDate" className="block text-sm font-medium text-secondary-700 mb-2">
                  Start Date
                </label>
                <input
                  type="date"
                  id="startDate"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={startDate}
                  onChange={(e) => setStartDate(e.target.value)}
                  max={endDate}
                />
              </div>

              {/* End Date filter */}
              <div>
                <label htmlFor="endDate" className="block text-sm font-medium text-secondary-700 mb-2">
                  End Date
                </label>
                <input
                  type="date"
                  id="endDate"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={endDate}
                  onChange={(e) => setEndDate(e.target.value)}
                  min={startDate}
                />
              </div>
            </div>
          </div>

          {error && (
            <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3 mb-6" role="alert">
              <p className="text-sm text-red-700">{error}</p>
            </div>
          )}

          {loading && (
            <div className="rounded-card border border-primary-200 bg-primary-50/50 px-4 py-3 mb-6" role="status">
              <p className="text-sm text-primary-700">Loading...</p>
            </div>
          )}

          <div className="overflow-x-auto rounded-card border border-secondary-200">
            <table className="min-w-full divide-y divide-secondary-200">
              <thead className="bg-secondary-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider max-w-72 truncate">
                    Description
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-24">
                    System
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-64">
                    Categories
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Source
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Date
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-40">
                    Classified By
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-secondary-200">
                {history.map((item) => (
                  <tr key={item.id} className={`hover:bg-secondary-50 ${
                    item.status === 'failed' && !isInformationalError(item.error) ? 'bg-red-50/30' : 
                    item.status === 'partial' || (item.status === 'failed' && isInformationalError(item.error)) ? 'bg-yellow-50/30' : ''
                  }`}>
                    <td className="px-6 py-4 text-sm text-secondary-900 max-w-72">
                      {item.ragContextUsed && item.ragContext ? (
                        <Tooltip
                          title={
                            <pre className="text-xs whitespace-pre-wrap max-w-md">
                              {item.ragContext}
                            </pre>
                          }
                          placement="topLeft"
                          overlayInnerStyle={{ backgroundColor: '#fff', color: '#333', border: '1px solid #ccc', padding: '8px', whiteSpace: 'pre-wrap' }}
                        >
                          <span className="truncate block cursor-help underline decoration-dotted decoration-primary-500">
                            {item.description}
                          </span>
                        </Tooltip>
                      ) : (
                        <span className="truncate block">{item.description}</span>
                      )}
                      {item.error && (
                        <div className={`mt-1 text-xs ${
                          isInformationalError(item.error) ? 'text-yellow-600' : 'text-red-600'
                        }`}>
                          {isInformationalError(item.error) ? `Note: ${item.error}` : `Error: ${item.error}`}
                        </div>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600 w-24">
                      {item.systemCode}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                      {getStatusBadge(item.status)}
                    </td>
                    <td className="px-6 py-4 text-sm w-64">
                      <div className="space-y-1">
                        {Object.entries(item.levels || {})
                          .sort(([a], [b]) => {
                            const levelOrder: Record<string, number> = {
                              'segment': 1, 'family': 2, 'class': 3, 'commodity': 4,
                              'SUBCAT1': 1, 'SUBCAT2': 2, 'default': 99 
                            };
                            const getOrder = (levelCode: string) => levelOrder[levelCode.toLowerCase()] ?? levelOrder['default'];
                            return getOrder(a) - getOrder(b);
                          })
                          .map(([levelCode, category]) => (
                          <div key={levelCode}>
                            <span className="font-medium text-secondary-700">{levelCode}:</span>{' '}
                            <span className="text-secondary-600">{category.code} - {category.name}</span>
                            {category.error && (
                              <div className="text-xs text-red-600 mt-0.5">
                                {category.error}
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600">
                      {getSourceBadge(item.sourceType as ClassificationSourceType, item.createdBy)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600">
                      <span title={formatDate(item.createdAt).fullText}>
                        {formatDate(item.createdAt).displayText}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600 w-40">
                      {getClassifierBadge(item.createdBy)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                    <button
                        onClick={() => handleView(item)}
                        className="group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium text-secondary-700 border border-secondary-200 rounded-lg hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm mr-1"
                        disabled={!checkPermission('history:view')}
                        title={!checkPermission('history:view') ? "Permission denied" : "View details"}
                      >
                        <svg 
                          className={`w-4 h-4 ${!checkPermission('history:view') ? 'text-secondary-300' : 'text-secondary-500 group-hover:text-secondary-700'} transition-colors`}
                          fill="none" 
                          viewBox="0 0 24 24" 
                          stroke="currentColor"
                        >
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden">
                          <div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div>
                        </div>
                      </button>
                      <button
                        onClick={() => handleReclassify(item)}
                        className={`group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium border border-secondary-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm ${
                          !checkPermission('classify:manual') 
                          ? 'text-secondary-400 border-secondary-200 cursor-not-allowed opacity-50' 
                          : 'text-secondary-700 hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900'
                        }`}
                        disabled={!checkPermission('classify:manual')}
                        title={!checkPermission('classify:manual') ? "Permission denied" : "Manually reclassify"}
                      >
                        <svg className={`w-4 h-4 ${!checkPermission('classify:manual') ? 'text-secondary-300' : 'text-secondary-500 group-hover:text-secondary-700'} transition-colors`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden"><div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div></div>
                      </button>
                      <button
                        onClick={() => handleRerun(item)}
                        className={`group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium border border-secondary-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm ${
                           !checkPermission('history:rerun') 
                           ? 'text-secondary-400 border-secondary-200 cursor-not-allowed opacity-50' 
                           : 'text-secondary-700 hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900'
                        }`}
                        disabled={!checkPermission('history:rerun')}
                        title={!checkPermission('history:rerun') ? "Permission denied" : "Rerun classification"}
                      >
                        <svg className={`w-4 h-4 ${!checkPermission('history:rerun') ? 'text-secondary-300' : 'text-secondary-500 group-hover:text-secondary-700'} transition-colors`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden"><div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div></div>
                      </button>
                      <button
                        onClick={() => handleDelete(item)}
                        className={`group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium border rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-all duration-200 shadow-sm ${
                            !checkPermission('history:delete') 
                            ? 'text-red-300 border-red-100 cursor-not-allowed opacity-50' 
                            : 'text-red-600 border-red-200 hover:bg-red-50 hover:border-red-300 hover:text-red-700'
                         }`}
                        disabled={!checkPermission('history:delete')}
                        title={!checkPermission('history:delete') ? "Permission denied" : "Delete classification"}
                      >
                        <svg className={`w-4 h-4 ${!checkPermission('history:delete') ? 'text-red-300' : 'text-red-500 group-hover:text-red-700'} transition-colors`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden"><div className="absolute inset-0 bg-gradient-to-r from-red-100 to-red-50 opacity-0 group-hover:opacity-10 transition-opacity"></div></div>
                      </button>
                    </td>
                  </tr>
                ))}
                {history.length === 0 && (
                  <tr>
                    <td colSpan={8} className="px-6 py-8 text-center text-sm text-secondary-500">
                      No classifications found matching the current filters.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>

          {/* Pagination controls */}
          <div className="mt-6 flex items-center justify-between">
            <div className="flex-1 flex justify-between items-center">
                <p className="text-sm text-secondary-600">
                {history.length > 0
                    ? `Showing ${Math.min((currentPage - 1) * pageSize + 1, totalCount)} - ${Math.min(currentPage * pageSize, totalCount)} of ${totalCount} results`
                    : 'No results found'}
                </p>
                
                <div className="flex items-center gap-2">
                <button
                    onClick={() => handlePageChange(1)}
                    disabled={currentPage === 1 || loading}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >First</button>
                <button
                    onClick={() => handlePageChange(currentPage - 1)}
                    disabled={currentPage === 1 || loading}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >Previous</button>

                {(() => {
                    const pages = [];
                    const maxButtons = 5;
                    let start = Math.max(1, currentPage - Math.floor(maxButtons / 2));
                    let end = Math.min(start + maxButtons - 1, totalPages);
                    if (end === totalPages) start = Math.max(1, end - maxButtons + 1);
                    if (start > 1) pages.push(<span key="start-dots" className="px-2 py-2 text-secondary-500">...</span>);
                    for (let i = start; i <= end; i++) {
                    pages.push(
                        <button
                        key={i}
                        onClick={() => handlePageChange(i)}
                        disabled={loading || (i > currentPage && !pageCursors[currentPage - 1])}
                        className={`px-3 py-2 rounded-lg border text-sm font-medium ${
                            i === currentPage ? 'bg-primary-600 text-white border-primary-600' : 'border-secondary-200 text-secondary-700 hover:bg-secondary-50'
                        }`}
                        >{i}</button>
                    );
                    }
                    if (end < totalPages) pages.push(<span key="end-dots" className="px-2 py-2 text-secondary-500">...</span>);
                    return pages;
                })()}

                <button
                    onClick={() => handlePageChange(currentPage + 1)}
                    disabled={currentPage === totalPages || loading || (currentPage < totalPages && !pageCursors[currentPage - 1])}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >Next</button>
                <button
                    onClick={() => handlePageChange(totalPages)}
                    disabled={currentPage === totalPages || loading || totalPages <= 1}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >Last</button>
                </div>
            </div>
           </div>
        </div>
      </div>

      {selectedItem && (
        <ManualClassificationModal
          isOpen={showManualModal}
          onClose={() => {
            setShowManualModal(false);
            setSelectedItem(null);
          }}
          onSubmit={handleManualClassification}
          apiClient={apiClient}
          description={selectedItem.description}
          systemCode={selectedItem.systemCode} 
          initialLevels={Object.fromEntries(
            Object.entries(selectedItem.levels).map(([code, category]) => [code, category.code])
          )}
        />
      )}
      <RerunStatusModal
        isOpen={showRerunModal}
        description={rerunningItem?.description || ''}
      />
      {detailsItem && (
        <ClassificationDetailsModal
          isOpen={showDetailsModal}
          onClose={() => {
            setShowDetailsModal(false);
            setDetailsItem(null);
          }}
          item={detailsItem}
        />
      )}
    </React.Fragment>
  );
};

export default HistoryTab;

File: src/components/UserManagement/UserManagementComponent.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Modal, Form, Input, message, Space, Select, Tag, Tooltip } from 'antd';
import { useAuth } from '../../context/AuthContext';
import { EditOutlined, DeleteOutlined, EyeOutlined, PlusOutlined } from '@ant-design/icons';
import { 
  ApiClient, 
  CreateUserRequest,
  UpdateUserRequest,
  User,
  Role
} from '../../api/types';

// Define the types needed for User Management functionality
export interface UserManagementComponentProps {
  apiClient: ApiClient;
}

export const UserManagementComponent: React.FC<UserManagementComponentProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  // Component state
  const [users, setUsers] = useState<User[]>([]);
  const [roles, setRoles] = useState<Role[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showViewModal, setShowViewModal] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [pagination, setPagination] = useState({ current: 1, pageSize: 10, total: 0 });
  const [form] = Form.useForm();
  
  // Load users and roles when component mounts
  useEffect(() => {
    loadUsers();
    loadRoles();
  }, []);
  
  const loadUsers = async (page = 1, pageSize = 10) => {
    setLoading(true);
    setError(null);
    
    try {
      const offset = (page - 1) * pageSize;
      const response = await apiClient.getUsers({ limit: pageSize, offset });
      
      setUsers(response.items || []);
      setPagination({
        current: page,
        pageSize: pageSize,
        total: response.totalCount || 0
      });
    } catch (err) {
      console.error('Failed to load users:', err);
      setError('Failed to load user accounts');
    } finally {
      setLoading(false);
    }
  };
  
  const loadRoles = async () => {
    try {
      const response = await apiClient.getRoles({ limit: 100 });
      setRoles(response.items || []);
    } catch (err) {
      console.error('Failed to load roles:', err);
      // We don't set the main error state here to avoid disrupting the UI
      message.error('Failed to load roles. Role selection may be incomplete.');
    }
  };
  
  const handleCreateUser = async (data: any) => {
    // Check if user has permission to create users
    if (!checkPermission('users:create')) {
      setError('You do not have permission to create users');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: CreateUserRequest = {
        username: data.username,
        password: data.password,
        roles: data.roles || []
      };
      
      await apiClient.createUser(request);
      message.success('User created successfully');
      setShowCreateModal(false);
      form.resetFields();
      loadUsers(pagination.current, pagination.pageSize); // Refresh the list
    } catch (err) {
      console.error('Failed to create user:', err);
      setError('Failed to create user account');
    } finally {
      setLoading(false);
    }
  };
  
  const handleUpdateUser = async (data: any) => {
    // Check if user has permission to update users
    if (!checkPermission('users:update')) {
      setError('You do not have permission to update users');
      return;
    }
    
    if (!selectedUser) {
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: UpdateUserRequest = {
        username: data.username !== selectedUser.username ? data.username : undefined,
        password: data.password || undefined, // Only include password if provided
        roles: data.roles // Always send roles to potentially update
      };
      
      // Filter out undefined fields for cleaner request
      const filteredRequest = Object.fromEntries(
        Object.entries(request).filter(([_, v]) => v !== undefined)
      ) as UpdateUserRequest;
      
      await apiClient.updateUser(selectedUser.id, filteredRequest);
      message.success('User updated successfully');
      setShowEditModal(false);
      form.resetFields();
      loadUsers(pagination.current, pagination.pageSize); // Refresh the list
    } catch (err) {
      console.error('Failed to update user:', err);
      setError('Failed to update user account');
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeleteUser = async (id: number) => {
    // Check if user has permission to delete users
    if (!checkPermission('users:delete')) {
      setError('You do not have permission to delete users');
      return;
    }
    
    setLoading(true);
    
    try {
      await apiClient.deleteUser(id);
      message.success('User deleted successfully');
      
      // If we're on a page that might now be empty, go back one page
      const newTotal = pagination.total - 1;
      const newTotalPages = Math.ceil(newTotal / pagination.pageSize);
      const pageToLoad = pagination.current > newTotalPages && newTotalPages > 0 
        ? newTotalPages 
        : pagination.current;
        
      loadUsers(pageToLoad, pagination.pageSize); // Refresh the list
    } catch (err) {
      console.error('Failed to delete user:', err);
      setError('Failed to delete user account');
    } finally {
      setLoading(false);
    }
  };
  
  const showDeleteConfirm = (id: number, username: string) => {
    Modal.confirm({
      title: `Are you sure you want to delete ${username}?`,
      content: 'This action cannot be undone.',
      okText: 'Yes',
      okType: 'danger',
      cancelText: 'No',
      onOk() {
        handleDeleteUser(id);
      },
    });
  };
  
  const openCreateModal = () => {
    form.resetFields();
    setShowCreateModal(true);
  };
  
  const openEditModal = (user: User) => {
    setSelectedUser(user);
    form.setFieldsValue({
      username: user.username,
      // Don't set password field for editing
      roles: user.roles || []
    });
    setShowEditModal(true);
  };
  
  const openViewModal = (user: User) => {
    setSelectedUser(user);
    setShowViewModal(true);
  };
  
  const handlePageChange = (page: number, pageSize?: number) => {
    loadUsers(page, pageSize || pagination.pageSize);
  };
  
  const formatRoles = (roleNames: string[]) => {
    if (!roleNames || roleNames.length === 0) {
      return <Tag>No Roles</Tag>;
    }
    
    return (
      <Space size={[0, 4]} wrap>
        {roleNames.map(role => (
          <Tag color="blue" key={role}>{role}</Tag>
        ))}
      </Space>
    );
  };
  
  const columns = [
    {
      title: 'Username',
      dataIndex: 'username',
      key: 'username',
      sorter: (a: User, b: User) => a.username.localeCompare(b.username),
    },
    {
      title: 'Roles',
      dataIndex: 'roles',
      key: 'roles',
      render: (roles: string[]) => formatRoles(roles),
    },
    {
      title: 'Created At',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (text: string) => text ? new Date(text).toLocaleString() : '-',
    },
    {
      title: 'Updated At',
      dataIndex: 'updatedAt',
      key: 'updatedAt',
      render: (text: string) => text ? new Date(text).toLocaleString() : '-',
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: User) => (
        <Space size="small">
          <Button 
            type="text" 
            icon={<EyeOutlined />} 
            onClick={() => openViewModal(record)}
          />
          {checkPermission('users:update') && (
            <Button 
              type="text" 
              icon={<EditOutlined />} 
              onClick={() => openEditModal(record)}
            />
          )}
          {checkPermission('users:delete') && (
            <Button 
              type="text" 
              danger 
              icon={<DeleteOutlined />} 
              onClick={() => showDeleteConfirm(record.id, record.username)}
            />
          )}
        </Space>
      ),
    },
  ];
  
  return (
    <div className="user-management-container">
      {error && <div className="error-message mb-4 p-3 text-red-700 bg-red-50 border border-red-200 rounded">{error}</div>}
      
      <div className="actions-container" style={{ marginBottom: '16px' }}>
        {checkPermission('users:create') && (
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={openCreateModal}
          >
            Add New User
          </Button>
        )}
      </div>
      
      <Table
        dataSource={users}
        columns={columns}
        rowKey="id"
        loading={loading}
        pagination={{
          current: pagination.current,
          pageSize: pagination.pageSize,
          total: pagination.total,
          onChange: handlePageChange,
          showSizeChanger: true,
          pageSizeOptions: ['10', '20', '50'],
          showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} items`
        }}
      />
      
      {/* Create Modal */}
      <Modal
        title="Add New User"
        open={showCreateModal}
        onCancel={() => setShowCreateModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleCreateUser}
        >
          <Form.Item
            name="username"
            label="Username"
            rules={[{ required: true, message: 'Please enter a username' }]}
          >
            <Input />
          </Form.Item>
          
          <Form.Item
            name="password"
            label="Password"
            rules={[{ required: true, message: 'Please enter a password' }]}
            hasFeedback
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="confirmPassword"
            label="Confirm Password"
            dependencies={['password']}
            hasFeedback
            rules={[
              { required: true, message: 'Please confirm the password' },
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!value || getFieldValue('password') === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(new Error('The two passwords do not match'));
                },
              }),
            ]}
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="roles"
            label="Roles"
          >
            <Select
              mode="multiple"
              placeholder="Select roles"
              optionFilterProp="label"
            >
              {roles.map(role => (
                <Select.Option key={role.id} value={role.name} label={role.name}>
                  <div>
                    <div>{role.name}</div>
                    {role.description && (
                      <div className="text-xs text-gray-500">{role.description}</div>
                    )}
                  </div>
                </Select.Option>
              ))}
            </Select>
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Create
            </Button>
            <Button onClick={() => setShowCreateModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* Edit Modal */}
      <Modal
        title="Edit User"
        open={showEditModal}
        onCancel={() => setShowEditModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleUpdateUser}
        >
          <Form.Item
            name="username"
            label="Username"
            rules={[{ required: true, message: 'Please enter a username' }]}
          >
            <Input disabled />
          </Form.Item>
          
          <Form.Item
            name="password"
            label="New Password (leave blank to keep current)"
            hasFeedback
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="confirmPassword"
            label="Confirm New Password"
            dependencies={['password']}
            hasFeedback
            rules={[
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!getFieldValue('password') || !value || getFieldValue('password') === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(new Error('The two passwords do not match'));
                },
              }),
            ]}
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="roles"
            label="Roles"
          >
            <Select
              mode="multiple"
              placeholder="Select roles"
              optionFilterProp="label"
            >
              {roles.map(role => (
                <Select.Option key={role.id} value={role.name} label={role.name}>
                  <div>
                    <div>{role.name}</div>
                    {role.description && (
                      <div className="text-xs text-gray-500">{role.description}</div>
                    )}
                  </div>
                </Select.Option>
              ))}
            </Select>
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Update
            </Button>
            <Button onClick={() => setShowEditModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* View Modal */}
      <Modal
        title="User Details"
        open={showViewModal}
        onCancel={() => setShowViewModal(false)}
        footer={[
          <Button key="close" onClick={() => setShowViewModal(false)}>
            Close
          </Button>
        ]}
      >
        {selectedUser && (
          <>
            <p><strong>Username:</strong> {selectedUser.username}</p>
            <p><strong>Roles:</strong></p>
            <div className="mb-3">{formatRoles(selectedUser.roles)}</div>
            <p><strong>Created:</strong> {selectedUser.createdAt ? new Date(selectedUser.createdAt).toLocaleString() : 'N/A'}</p>
            <p><strong>Last Updated:</strong> {selectedUser.updatedAt ? new Date(selectedUser.updatedAt).toLocaleString() : 'N/A'}</p>
          </>
        )}
      </Modal>
    </div>
  );
};

export default UserManagementComponent;

File: src/components/MainTabs.tsx
import React, { useState } from 'react';
import { Tab } from '@headlessui/react';
import Settings from './Settings';
import { ApiClient } from '../api/types';
import { ClassificationForm } from './ClassificationForm';
import { HistoryTab } from './HistoryTab';
import BatchTab from './BatchTab/BatchTab';
import { BeakerIcon, DocumentTextIcon, ClockIcon, Cog6ToothIcon } from '@heroicons/react/24/outline';

function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(' ');
}

export interface MainTabsProps {
  apiClient: ApiClient;
}

export const MainTabs: React.FC<MainTabsProps> = ({ apiClient }) => {
  const [selectedIndex, setSelectedIndex] = useState(0);

  const tabs = [
    {
      name: 'Test',
      content: <ClassificationForm apiClient={apiClient} />,
      icon: BeakerIcon
    },
    {
      name: 'Batch',
      content: <BatchTab apiClient={apiClient} />,
      icon: DocumentTextIcon
    },
    {
      name: 'History',
      content: <HistoryTab apiClient={apiClient} />,
      icon: ClockIcon
    },
    {
      name: 'Settings',
      content: <Settings apiClient={apiClient} />,
      icon: Cog6ToothIcon
    },
  ];

  return (
    <div className="flex h-full bg-gray-50/50">
      <Tab.Group as="div" className="flex h-full w-full" vertical selectedIndex={selectedIndex} onChange={setSelectedIndex}>
        <Tab.List className="flex flex-col items-center gap-2 w-48 bg-white/80 backdrop-blur-sm shadow-sm py-6 px-3 m-4 rounded-xl">
          {tabs.map((tab) => {
            const Icon = tab.icon;
            return (
              <Tab
                key={tab.name}
                className={({ selected }) =>
                  classNames(
                    'group flex items-center w-40 gap-3 px-3 py-2 text-sm font-medium rounded-lg outline-none transition-all duration-200',
                    'focus:ring-1 focus:ring-offset-1 focus:ring-primary-200/30',
                    selected
                      ? 'text-primary-600 bg-primary-50/50 shadow-sm ring-1 ring-primary-100/50'
                      : 'text-secondary-400 hover:text-secondary-700 hover:bg-secondary-50/50 hover:shadow-sm'
                  )
                }
              >
                <Icon className={classNames(
                  'w-4 h-4 transition-all duration-200',
                  'group-hover:scale-105 group-hover:rotate-2'
                )} />
                {tab.name}
              </Tab>
            );
          })}
        </Tab.List>
        <Tab.Panels className="flex-1">
          {tabs.map((tab, idx) => (
            <Tab.Panel key={idx} className="h-full">
              <div className="h-full">
                {tab.content}
              </div>
            </Tab.Panel>
          ))}
        </Tab.Panels>
      </Tab.Group>
    </div>
  );
};

export default MainTabs;

File: src/langgraph/hooks/useLangGraphRunner.ts
// src/langgraph/hooks/useLangGraphRunner.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  LangGraphExecutionEvent,
  ExecuteGraphRequestFE,
  GraphExecutionStartEventFE,
  NodeStartEventFE,
  NodeEndEventFE,
  EdgeTakenEventFE,
  GraphExecutionEndEventFE,
  GraphErrorEventFE,
} from '../types/langgraph';
import { LangGraphSocketService, LangGraphSocketMessageHandler } from '../services/langGraphSocketService';

export type GraphExecutionStatus =
  | 'disconnected'
  | 'connecting'
  | 'connected' // Connected, waiting for initial message or graph start
  | 'starting'  // GraphExecutionStartEvent sent/received, graph is about to run
  | 'running'   // Actively receiving node/edge events
  | 'completed'
  | 'error'
  | 'closed';

export interface ExecutionState {
  activeNodeIds: Set<string>;
  completedNodeIds: Set<string>;
  errorNodeIds: Set<string>;
  traversedEdgeIds: Set<string>; // e.g., "source->target" or edge ID from graph def
  lastInputByNode: Record<string, any>;
  lastOutputByNode: Record<string, any>;
}

const initialExecutionState: ExecutionState = {
  activeNodeIds: new Set(),
  completedNodeIds: new Set(),
  errorNodeIds: new Set(),
  traversedEdgeIds: new Set(),
  lastInputByNode: {},
  lastOutputByNode: {},
};

export interface UseLangGraphRunnerResult {
  connectAndExecute: (
    graphId: string,
    initialArgs?: Record<string, any>,
    predefinedExecutionId?: string // For re-connecting to an existing run (if supported by backend)
  ) => void;
  disconnect: () => void;
  executionEvents: LangGraphExecutionEvent[];
  currentExecutionId: string | null;
  status: GraphExecutionStatus;
  error: string | null; // General WebSocket or connection error
  graphError: GraphErrorEventFE | null; // Specific error from graph execution
  currentGraphState: ExecutionState; // State to help visualize node/edge statuses
}

export const useLangGraphRunner = (
    baseWsUrl?: string // Optional: e.g., ws://localhost:8000 or wss://yourdomain.com
): UseLangGraphRunnerResult => {
  const [socketService, setSocketService] = useState<LangGraphSocketService | null>(null);
  const [executionEvents, setExecutionEvents] = useState<LangGraphExecutionEvent[]>([]);
  const [currentExecutionId, setCurrentExecutionId] = useState<string | null>(null);
  const [status, setStatus] = useState<GraphExecutionStatus>('disconnected');
  const [error, setError] = useState<string | null>(null);
  const [graphError, setGraphError] = useState<GraphErrorEventFE | null>(null);
  const [currentGraphState, setCurrentGraphState] = useState<ExecutionState>(initialExecutionState);

  // Ref to ensure that we don't set state on an unmounted component
  const mountedRef = useRef(true);
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  const resetExecutionVisualState = useCallback(() => {
    if (mountedRef.current) {
      setCurrentGraphState(initialExecutionState);
      setGraphError(null);
    }
  }, []);

  const handleNewEvent = useCallback((event: LangGraphExecutionEvent) => {
    if (!mountedRef.current) return;

    setExecutionEvents((prevEvents) => [...prevEvents, event]);
    setCurrentGraphState((prevState) => {
      const newState = {
        activeNodeIds: new Set(prevState.activeNodeIds),
        completedNodeIds: new Set(prevState.completedNodeIds),
        errorNodeIds: new Set(prevState.errorNodeIds),
        traversedEdgeIds: new Set(prevState.traversedEdgeIds),
        lastInputByNode: { ...prevState.lastInputByNode },
        lastOutputByNode: { ...prevState.lastOutputByNode },
      };

      switch (event.eventType) {
        case 'graph_execution_start':
          setStatus('starting');
          setCurrentExecutionId(event.executionId);
          // Reset visual state for a new run, even if it's the same graphId
          return initialExecutionState;
        case 'node_start':
          const nsEvent = event as NodeStartEventFE;
          newState.activeNodeIds.add(nsEvent.nodeId);
          newState.completedNodeIds.delete(nsEvent.nodeId); // In case of retries/loops
          newState.errorNodeIds.delete(nsEvent.nodeId);
          newState.lastInputByNode[nsEvent.nodeId] = nsEvent.inputData;
          if (status !== 'running') setStatus('running');
          break;
        case 'node_end':
          const neEvent = event as NodeEndEventFE;
          newState.activeNodeIds.delete(neEvent.nodeId);
          if (neEvent.status === 'success') {
            newState.completedNodeIds.add(neEvent.nodeId);
          } else {
            newState.errorNodeIds.add(neEvent.nodeId);
          }
          newState.lastOutputByNode[neEvent.nodeId] = neEvent.outputData;
          break;
        case 'edge_taken':
          const etEvent = event as EdgeTakenEventFE;
          // Create a unique ID for the edge, e.g., "source_target_label"
          // Note: Backend needs to send reliable edge identifiers or enough info to construct one
          const edgeId = `${etEvent.sourceNodeId}__${etEvent.targetNodeId}` + (etEvent.edgeLabel ? `__${etEvent.edgeLabel}` : '');
          newState.traversedEdgeIds.add(edgeId);
          break;
        case 'graph_execution_end':
          setStatus('completed');
          // Keep active/completed nodes as they are for final state view
          break;
        case 'graph_error':
          setGraphError(event as GraphErrorEventFE);
          setStatus('error');
          break;
        case 'pong':
          // console.debug('[useLangGraphRunner] Pong received:', event.serverTime);
          break;
      }
      return newState;
    });
  }, [status]); // status dependency to ensure setStatus('running') is correctly timed

  const handleSocketOpen = useCallback(() => {
    if (mountedRef.current) {
      setStatus('connected'); // Connected, now ready to send initial message
      setError(null);
    }
  }, []);

  const handleSocketError = useCallback((err: Event) => {
    if (mountedRef.current) {
      console.error('[useLangGraphRunner] WebSocket Error:', err);
      setError('WebSocket connection error. Please try again.');
      setStatus('error');
      resetExecutionVisualState();
    }
  }, [resetExecutionVisualState]);

  const handleSocketClose = useCallback((ev: CloseEvent) => {
    if (mountedRef.current) {
      console.log('[useLangGraphRunner] WebSocket Closed:', ev.code, ev.reason);
      if (status !== 'completed' && status !== 'error' && !ev.wasClean) {
        setError(`WebSocket closed unexpectedly: ${ev.reason || ev.code}`);
        setStatus('error'); // Or 'disconnected' if appropriate
      } else if (ev.wasClean && status !== 'completed' && status !== 'error') {
        setStatus('closed');
      }
      // Do not reset currentExecutionId or events here, they might be needed for display
      // Visual state (activeNodeIds etc.) is also kept for inspection of last state.
    }
  }, [status]);


  const connectAndExecute = useCallback((
    graphId: string,
    initialArgs: Record<string, any> = {},
    predefinedExecutionId?: string
  ) => {
    if (socketService) {
      console.warn('[useLangGraphRunner] Disconnecting existing socket before reconnecting.');
      socketService.close(1000, "New connection requested");
    }

    if (mountedRef.current) {
      setExecutionEvents([]); // Clear events from previous run
      resetExecutionVisualState();
      setStatus('connecting');
      setError(null);
      setGraphError(null);
      setCurrentExecutionId(predefinedExecutionId || null); // Set if provided, else it's set on GraphExecutionStartEvent
    }

    const newSocketService = new LangGraphSocketService({
      onMessage: handleNewEvent,
      onOpen: () => {
        handleSocketOpen(); // Sets status to 'connected'
        // Send initial message to start execution AFTER connection is open
        const initialMessage: ExecuteGraphRequestFE = { inputArgs: initialArgs || {} };
        newSocketService.send(initialMessage);
        // Status will move to 'starting' and then 'running' based on backend events
      },
      onError: handleSocketError,
      onClose: handleSocketClose,
      autoReconnect: false, // Typically, user initiates new execution explicitly
      baseWsUrl: baseWsUrl,
    });

    newSocketService.connect(graphId, predefinedExecutionId);
    if (mountedRef.current) {
      setSocketService(newSocketService);
    } else {
      // If component unmounted before socket could be set, close the new socket
      newSocketService.close();
    }
  }, [socketService, handleNewEvent, handleSocketOpen, handleSocketError, handleSocketClose, resetExecutionVisualState, baseWsUrl]);


  const disconnect = useCallback(() => {
    if (socketService) {
      socketService.close(1000, 'User disconnected'); // 1000 is normal closure
      if (mountedRef.current) {
          setSocketService(null); // Allow for a new service to be created on next connect
          if (status !== 'error' && status !== 'completed') { // Only set to 'closed' if not already in a terminal state
              setStatus('closed');
          }
      }
    }
  }, [socketService, status]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      mountedRef.current = false; // Mark as unmounted
      if (socketService) {
        console.log('[useLangGraphRunner] Cleaning up WebSocket on unmount.');
        socketService.close(1000, 'Component unmounted');
      }
    };
  }, [socketService]);

  return {
    connectAndExecute,
    disconnect,
    executionEvents,
    currentExecutionId,
    status,
    error,
    graphError,
    currentGraphState,
  };
};

File: src/components/UserManagement/UserManagementTab.tsx
// src/components/UserManagement/UserManagementTab.tsx
import React, { useState, useCallback, useMemo } from 'react';
import { Button, Input, Space, message } from 'antd';
import { PlusOutlined, SearchOutlined } from '@ant-design/icons';
import { ApiClient, User, CreateUserRequest, UpdateUserRequest } from '../../api/types';
import { useUsers } from './hooks/useUsers'; // Import the hook
import { UserTable } from './components/UserTable';
import { UserFormModal } from './components/UserFormModal'; // Correct import path
import debounce from 'lodash/debounce'; // Import debounce

interface UserManagementTabProps {
  apiClient: ApiClient;
}

const UserManagementTab: React.FC<UserManagementTabProps> = ({ apiClient }) => {
  const {
    users,
    roles, // Get available roles
    loading,
    loadingRoles,
    error,
    pagination,
    fetchUsers,
    createUser,
    updateUser,
    deleteUser,
  } = useUsers(apiClient); // Use the hook

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingUser, setEditingUser] = useState<User | undefined>(undefined);
  const [searchTerm, setSearchTerm] = useState('');

  // Debounced search handler
   const debouncedSearch = useCallback(
       debounce((value: string) => {
           fetchUsers(1, pagination.pageSize, value); // Reset to page 1 on search
       }, 500), // 500ms debounce delay
       [fetchUsers, pagination.pageSize]
   );

   const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
       const value = e.target.value;
       setSearchTerm(value);
       debouncedSearch(value);
   };


  const handleAddUser = () => {
    setEditingUser(undefined); // Clear editing state
    setIsModalOpen(true);
  };

  const handleEditUser = (user: User) => {
    setEditingUser(user);
    setIsModalOpen(true);
  };

  const handleDeleteUser = async (id: number) => {
    await deleteUser(id);
    // The hook handles refresh
  };

  const handleModalSubmit = async (data: CreateUserRequest | UpdateUserRequest): Promise<boolean> => {
    let success = false;
    if (editingUser) {
      const result = await updateUser(editingUser.id, data as UpdateUserRequest);
      success = !!result;
    } else {
      const result = await createUser(data as CreateUserRequest);
      success = !!result;
    }
    if (success) {
        setIsModalOpen(false); // Close modal on success
        setEditingUser(undefined);
    }
    return success; // Return success status to modal
  };

   const handleTableChange = (page: number, pageSize: number) => {
       fetchUsers(page, pageSize, searchTerm); // Fetch data for the new page/size
   };

   // Create a map of role names to descriptions for tooltips
   const rolesMap = useMemo(() => {
       const map = new Map<string, string>();
       roles.forEach(role => map.set(role.name, role.description || role.name));
       return map;
   }, [roles]);


  return (
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
        <div className="flex justify-between items-center">
           <Input
               placeholder="Search users..."
               prefix={<SearchOutlined />}
               value={searchTerm}
               onChange={handleSearchChange}
               style={{ width: 300 }}
               allowClear
           />
          <Button
            type="primary"
            icon={<PlusOutlined />}
            onClick={handleAddUser}
            disabled={loading || loadingRoles} // Disable if roles haven't loaded
          >
            Add User
          </Button>
        </div>

      <UserTable
        users={users}
        rolesMap={rolesMap} // Pass the roles map
        loading={loading}
        pagination={pagination}
        onEdit={handleEditUser}
        onDelete={handleDeleteUser}
        onPageChange={handleTableChange}
      />

      <UserFormModal
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false);
          setEditingUser(undefined); // Clear editing state on close
        }}
        onSubmit={handleModalSubmit}
        initialData={editingUser}
        availableRoles={roles} // Pass roles to modal
        loading={loading}
        loadingRoles={loadingRoles}
      />
    </Space>
  );
};

export default UserManagementTab;

File: src/components/__tests__/ConfigValue.test.tsx
import React from 'react';
import { render } from '@testing-library/react';
import '@testing-library/jest-dom';
import { RenderResult } from '@testing-library/react';
import ConfigValue from '../ConfigValue';

describe('ConfigValue', () => {
  let renderResult: RenderResult;

  const renderComponent = (props: { configKey: string; value: any; className?: string }) => {
    renderResult = render(<ConfigValue {...props} />);
    return renderResult;
  };

  it('renders "Not set" for null or undefined values', () => {
    const { getByText } = renderComponent({ configKey: 'test', value: null });
    expect(getByText('Not set')).toBeInTheDocument();

    renderResult.rerender(<ConfigValue configKey="test" value={undefined} />);
    expect(getByText('Not set')).toBeInTheDocument();
  });

  it('masks sensitive values', () => {
    const { getByText } = renderComponent({ configKey: 'password', value: 'secret' });
    expect(getByText('********')).toBeInTheDocument();

    renderResult.rerender(<ConfigValue configKey="apiKey" value="secret" />);
    expect(getByText('********')).toBeInTheDocument();
  });

  it('renders boolean values with correct styling', () => {
    const { container: trueContainer } = renderComponent({ configKey: 'enabled', value: true });
    const { container: falseContainer } = render(<ConfigValue configKey="enabled" value={false} />);

    const trueElement = trueContainer.firstElementChild;
    const falseElement = falseContainer.firstElementChild;

    expect(trueElement).toHaveClass('bg-green-100', 'text-green-800');
    expect(falseElement).toHaveClass('bg-red-100', 'text-red-800');
  });

  it('handles complex objects', () => {
    const { getByText } = renderComponent({ configKey: 'config', value: { test: true } });
    expect(getByText('Complex object')).toBeInTheDocument();
  });

  it('displays array length', () => {
    const { getByText } = renderComponent({ configKey: 'items', value: [1, 2, 3] });
    expect(getByText('Array[3]')).toBeInTheDocument();
  });

  it('renders string values', () => {
    const { getByText } = renderComponent({ configKey: 'name', value: 'test-value' });
    expect(getByText('test-value')).toBeInTheDocument();
  });

  it('applies custom className prop', () => {
    const { container } = renderComponent({
      configKey: 'test',
      value: 'value',
      className: 'custom-class'
    });
    expect(container.firstElementChild).toHaveClass('custom-class');
  });
});

File: src/components/Settings/SettingsTab.tsx
import React, { useState, useEffect } from 'react';
import { Tabs, Spin, Alert, Form, Input, InputNumber, Switch, Select, Descriptions, Tooltip } from 'antd';
import { QuestionCircleOutlined } from '@ant-design/icons';
import type { FormInstance } from 'antd/es/form';
import { ApiClient, LlmConfig, UpdateConfigRequest } from '../../api/types';
import ConfigValue, { getConfigLabel } from '../ConfigValue'; // Import helper too

const { TabPane } = Tabs;
const { Option } = Select;
const { Item: FormItem } = Form; // Alias Form.Item for clarity

// Define the props including edit state and handlers
export interface SettingsTabProps {
  apiClient: ApiClient;
  isEditing: boolean;
  onSave: (updatedConfig: UpdateConfigRequest) => Promise<void>; // Function to call with update payload
  form: FormInstance<any>; // Pass the form instance down
  initialConfig: LlmConfig | null; // Pass fetched config
  loading: boolean; // Pass loading state
  error: string | null; // Pass error state
}

// Helper to get description for a config key
const getConfigDescription = (keyPath: string[]): string | null => {
  const descriptions: Record<string, string> = {
    "server.logLevel": "Set the minimum level for server logs (debug, info, warn, error).",
    "server.requestTimeout": "Maximum duration for handling incoming HTTP requests (e.g., '60s', '5m').",
    "service.llmEndpoint": "The base URL of the Language Model API.",
    "service.llmApiKey": "Your API key for the LLM service. Leave blank to keep the existing key.",
    "service.llmModel": "The specific LLM model to use for classification.",
    "service.llmMaxTokens": "Maximum number of tokens the LLM can generate in a response.",
    "service.llmTemperature": "Controls randomness in LLM output (0.0 = deterministic, >1.0 = more creative).",
    "service.useTypePrompt": "Whether to include specific guidance for GOODS/SERVICE/OTHER in UNSPSC Segment prompts.",
    "service.maxSkipLogs": "Maximum number of 'skipped row' warnings to log during Excel loading.",
    "database.ragEnabled": "Enable/disable Retrieval-Augmented Generation using vector database context.",
    "database.ragServiceUrl": "The URL of the RAG vector database service.",
    "database.ragManualInfoCollection": "Name of the collection storing manually added RAG context.",
    "database.ragUnspscCollection": "Name of the collection storing UNSPSC category data for RAG.",
    "database.ragCommonCollection": "Name of the collection storing Common Categories data for RAG.",
    "validation.maxHistoryLimit": "Maximum number of classification history items to store.",
    "validation.tokenLimit": "Estimated maximum token limit supported by the configured LLM.",
    "validation.defaultTimeout": "Default timeout for external service calls (e.g., '15s').",
    "alert.emailSettings.smtpHost": "Hostname of the SMTP server for sending email alerts.",
    "alert.emailSettings.smtpPort": "Port number of the SMTP server.",
    "alert.emailSettings.smtpUser": "Username for SMTP authentication.",
    "alert.emailSettings.smtpPassword": "Password for SMTP authentication. Leave blank to keep the existing password.",
    "alert.emailSettings.fromEmail": "The 'From' email address for alerts.",
    "alert.webhookSettings.url": "The URL to send webhook alerts to.",
    "auth.enabled": "Enable or disable user authentication and authorization.",
    "auth.jwtExpirationHours": "Number of hours a user's login session (JWT token) remains valid.",
  };
  return descriptions[keyPath.join('.')] || null;
};

// --- Component ---
const SettingsTab: React.FC<SettingsTabProps> = ({
  apiClient, // Keep apiClient if needed for other things, otherwise remove
  isEditing,
  onSave,
  form,
  initialConfig, // Receive config from parent
  loading: parentLoading, // Use loading state from parent
  error: parentError, // Use error state from parent
}) => {
  const [activeTab, setActiveTab] = useState<string | undefined>(undefined);

  // Initialize form when initialConfig is available or edit mode changes
  useEffect(() => {
    if (initialConfig) {
      // Prepare initial values for the form, handling nested structure
      const formValues: any = {};
      Object.keys(initialConfig).forEach(topKey => {
        const section = initialConfig[topKey as keyof LlmConfig];
        if (section && typeof section === 'object') {
          formValues[topKey] = {};
          Object.keys(section).forEach(subKey => {
            // Handle sensitive fields - DO NOT put masked value in form
            const fullKey = `${topKey}.${subKey}`;
             if (['service.llmApiKey', 'database.password', 'alert.emailSettings.smtpPassword', 'auth.jwtSecret', 'auth.initialAdminPassword'].includes(fullKey)) {
               formValues[topKey][subKey] = ''; // Set to empty for editing
             } else {
               formValues[topKey][subKey] = section[subKey as keyof typeof section];
             }
          });
        }
      });
      form.setFieldsValue(formValues);

      // Set default active tab if not already set
      if (!activeTab) {
        const firstKey = getTopLevelKeys(initialConfig)[0];
        setActiveTab(firstKey);
      }
    } else {
      form.resetFields(); // Reset form if no config
    }
  }, [initialConfig, form, activeTab]); // Add activeTab dependency

  // Recursive function to render form items OR display values
  const renderConfigEntries = (data: any, parentPath: string[] = []): React.ReactNode[] => {
    if (data === null || typeof data !== 'object' || Array.isArray(data)) {
      return []; // Should not happen at top level sections
    }

    return Object.entries(data)
      .map(([key, value]) => {
        const currentPath = [...parentPath, key];
        const fullKey = currentPath.join('.');
        const label = getConfigLabel(key);
        const description = getConfigDescription(currentPath);

        // Determine input type based on key or value type
        let inputType: 'text' | 'password' | 'number' | 'boolean' | 'select' | 'duration' | 'textarea' | 'unsupported' = 'text';
        const lowerKey = key.toLowerCase();

        // Determine if the field should be editable
        const isReadOnly = ['host', 'port', 'user', 'name', 'dataPath', 'initialAdminUser', 'jwtSecret', 'initialAdminPassword'].includes(key) || parentPath.includes('unspscExcelLoader') || parentPath.includes('commonExcelLoader');
        const isSensitive = ['llmApiKey', 'password', 'smtpPassword'].includes(key);

        if (isReadOnly && isEditing) {
           // Display read-only value even in edit mode
           return (
             <FormItem key={fullKey} label={renderLabel(label, description)} name={currentPath} style={{ marginBottom: '10px' }}>
                <ConfigValue configKey={key} value={value} className="text-secondary-500 italic" />
                <span className="text-xs text-secondary-400 ml-2">(Read-only)</span>
             </FormItem>
           );
        }

        if (typeof value === 'boolean') {
          inputType = 'boolean';
        } else if (typeof value === 'number') {
          inputType = 'number';
        } else if (lowerKey.includes('password') || lowerKey.includes('apikey') || lowerKey.includes('secret')) {
           inputType = 'password';
        } else if (key === 'logLevel') {
           inputType = 'select';
        } else if (key.includes('Timeout') || key.includes('duration')) { // Simple check for duration-like fields
          inputType = 'duration';
        } else if (typeof value === 'string' && value.length > 100) { // Treat long strings as textarea
          inputType = 'textarea';
        } else if (typeof value === 'object' || Array.isArray(value)) {
           inputType = 'unsupported'; // Don't render form items for nested objects/arrays directly here
        }

        if (inputType === 'unsupported') {
          // In read-only mode, show nested details
          if (!isEditing) {
            return (
              <Descriptions.Item key={fullKey} label={<span title={fullKey}>{label}</span>} span={1}>
                <div className="nested-config pl-4 border-l-2 border-secondary-200">
                  {renderConfigEntries(value, currentPath).map((node, idx) => <div key={idx}>{node}</div>)}
                </div>
              </Descriptions.Item>
            );
          }
          return null; // Don't show form item for complex types in edit mode here
        }

        // --- Render Edit Mode Form Item ---
        if (isEditing) {
           let fieldComponent: React.ReactNode;
           const commonProps = {
             disabled: parentLoading || isReadOnly, // Disable input if loading or read-only
             placeholder: isSensitive ? "Leave blank to keep current" : `Enter ${label}`
           };

          switch (inputType) {
            case 'boolean':
              fieldComponent = <Switch disabled={parentLoading} />;
              break;
            case 'number':
              fieldComponent = <InputNumber {...commonProps} style={{ width: '100%' }} />;
              break;
            case 'password':
               fieldComponent = <Input.Password {...commonProps} autoComplete="new-password" />;
               break;
            case 'select': // Example for logLevel
               if (key === 'logLevel') {
                 fieldComponent = (
                   <Select {...commonProps} placeholder="Select log level">
                     <Option value="debug">Debug</Option>
                     <Option value="info">Info</Option>
                     <Option value="warn">Warn</Option>
                     <Option value="error">Error</Option>
                   </Select>
                 );
               } else {
                  fieldComponent = <Input {...commonProps} />; // Fallback
               }
               break;
            case 'duration':
              fieldComponent = <Input {...commonProps} placeholder="e.g., 60s, 5m, 1h" />;
              break;
            case 'textarea':
               fieldComponent = <Input.TextArea {...commonProps} rows={3} />;
               break;
            default: // text
               fieldComponent = <Input {...commonProps} />;
          }

          // Use FormItem for layout and validation (add rules later if needed)
          return (
            <FormItem
              key={fullKey}
              name={currentPath} // Use array for nested keys
              label={renderLabel(label, description)}
              valuePropName={inputType === 'boolean' ? 'checked' : 'value'} // Important for Switch
              style={{ marginBottom: '10px' }}
            >
              {fieldComponent}
            </FormItem>
          );
        } else {
          // --- Render Read-Only Mode ---
          return (
            <Descriptions.Item key={fullKey} label={<span title={fullKey}>{label}</span>} span={1} labelStyle={{ width: '30%' }}>
              <ConfigValue configKey={key} value={value} />
            </Descriptions.Item>
          );
        }
      })
      .filter(Boolean); // Remove null entries (like unsupported types in edit mode)
  };

   // Helper to render label with tooltip
   const renderLabel = (label: string, description: string | null) => (
     <span>
       {label}
       {description && (
         <Tooltip title={description} overlayStyle={{ maxWidth: '300px' }}>
           <QuestionCircleOutlined style={{ marginLeft: 4, color: 'rgba(0,0,0,.45)', cursor: 'help' }} />
         </Tooltip>
       )}
     </span>
   );

   // Get top-level keys for Tabs
   const getTopLevelKeys = (cfg: LlmConfig | null): string[] => {
      if (!cfg) return [];
      const desiredOrder = ['server', 'service', 'database', 'auth', 'validation', 'alert'];
      const keys = Object.keys(cfg).filter(key =>
        typeof cfg[key as keyof LlmConfig] === 'object' && cfg[key as keyof LlmConfig] !== null
      );
      keys.sort((a, b) => {
         const indexA = desiredOrder.indexOf(a);
         const indexB = desiredOrder.indexOf(b);
         if (indexA === -1 && indexB === -1) return a.localeCompare(b);
         if (indexA === -1) return 1;
         if (indexB === -1) return -1;
         return indexA - indexB;
      });
      return keys;
    };

  // --- Render Logic ---

  if (parentLoading && !initialConfig) { // Show loading only on initial fetch
    return (
      <div className="flex justify-center items-center py-10">
        <Spin size="large" tip="Loading configuration..." />
      </div>
    );
  }

  if (parentError) {
    return (
      <Alert
        message="Error Loading Configuration"
        description={parentError}
        type="error"
        showIcon
      />
    );
  }

  if (!initialConfig) {
    return <Alert message="No configuration data available." type="warning" showIcon />;
  }

  const topLevelKeys = getTopLevelKeys(initialConfig);

  return (
    <Form
      form={form}
      layout="vertical"
      name="settingsForm"
      // onFinish is handled by the onSave prop passed from parent
      // initialValues are set via form.setFieldsValue in useEffect
    >
      <Tabs
         activeKey={activeTab}
         onChange={setActiveTab}
         tabPosition="top"
      >
         {topLevelKeys.map(topKey => {
            const sectionData = initialConfig[topKey as keyof LlmConfig];
            if (!sectionData || typeof sectionData !== 'object') return null; // Skip non-objects

            const sectionLabel = getConfigLabel(topKey);

            return (
               <TabPane tab={sectionLabel} key={topKey}>
                 <div className="py-4 px-2">
                   {isEditing
                     ? renderConfigEntries(sectionData, [topKey]) // Render FormItems
                     : ( // Render Descriptions for read-only
                       <Descriptions bordered column={1} size="small" className="config-descriptions">
                         {renderConfigEntries(sectionData, [topKey])}
                       </Descriptions>
                       )
                   }
                 </div>
               </TabPane>
            );
         })}
      </Tabs>
    </Form>
  );
};

export default SettingsTab;

File: src/components/UserManagement/hooks/useUsers.ts
// src/components/UserManagement/hooks/useUsers.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { message } from 'antd';
import {
  ApiClient, User, Role, CreateUserRequest, UpdateUserRequest,
  UserListResponse, RoleListResponse
} from '../../../api/types';

export interface UseUsersResult {
  users: User[];
  roles: Role[]; // Available roles for assignment
  loading: boolean;
  loadingRoles: boolean;
  error: string | null;
  totalUsers: number;
  pagination: { current: number; pageSize: number; total: number };
  fetchUsers: (page?: number, pageSize?: number, search?: string) => Promise<void>;
  createUser: (data: CreateUserRequest) => Promise<User | null>;
  updateUser: (id: number, data: UpdateUserRequest) => Promise<User | null>;
  deleteUser: (id: number) => Promise<boolean>;
}

const DEFAULT_PAGE_SIZE = 10;

export function useUsers(apiClient: ApiClient): UseUsersResult {
  const mountedRef = useRef(true);
  const [users, setUsers] = useState<User[]>([]);
  const [roles, setRoles] = useState<Role[]>([]); // Store available roles
  const [totalUsers, setTotalUsers] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(DEFAULT_PAGE_SIZE);
  const [loading, setLoading] = useState(true);
  const [loadingRoles, setLoadingRoles] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const currentSearchRef = useRef<string | undefined>(undefined); // Keep track of search term

  // Safe state setters
  const safeSetState = <T>(setter: React.Dispatch<React.SetStateAction<T>>) =>
    (value: T | ((prevState: T) => T)) => {
      if (mountedRef.current) {
        setter(value);
      }
    };

  const safeSetUsers = safeSetState(setUsers);
  const safeSetRoles = safeSetState(setRoles);
  const safeSetTotalUsers = safeSetState(setTotalUsers);
  const safeSetCurrentPage = safeSetState(setCurrentPage);
  const safeSetPageSize = safeSetState(setPageSize);
  const safeSetLoading = safeSetState(setLoading);
  const safeSetLoadingRoles = safeSetState(setLoadingRoles);
  const safeSetError = safeSetState(setError);

  // Fetch Users Function
  const fetchUsers = useCallback(async (
    page = currentPage,
    limit = pageSize,
    search?: string
  ) => {
    if (!mountedRef.current) return;
    safeSetLoading(true);
    safeSetError(null);
    currentSearchRef.current = search; // Store current search

    try {
      const offset = (page - 1) * limit;
      const response = await apiClient.getUsers({ limit, offset, search });
      // Check if the request is still the latest one (based on search term)
      if (mountedRef.current && currentSearchRef.current === search) {
        safeSetUsers(response.items || []);
        safeSetTotalUsers(response.totalCount || 0);
        safeSetCurrentPage(page);
        safeSetPageSize(limit);
      }
    } catch (err) {
       if (mountedRef.current && currentSearchRef.current === search) {
           console.error('Failed to fetch users:', err);
           const errorMsg = err instanceof Error ? err.message : 'Failed to load users';
           safeSetError(errorMsg);
           message.error(errorMsg); // Show Ant Design message
           safeSetUsers([]);
           safeSetTotalUsers(0);
       }
    } finally {
      if (mountedRef.current && currentSearchRef.current === search) {
          safeSetLoading(false);
      }
    }
  }, [apiClient, currentPage, pageSize, safeSetLoading, safeSetError, safeSetUsers, safeSetTotalUsers, safeSetCurrentPage, safeSetPageSize]);

  // Fetch Available Roles Function
  const fetchRoles = useCallback(async () => {
    if (!mountedRef.current) return;
    safeSetLoadingRoles(true);
    try {
        // Fetch all roles (assuming pagination isn't strictly needed for dropdown)
        // Adjust if your backend needs specific parameters or handles large role lists
      const response: RoleListResponse = await apiClient.getRoles({ limit: 500 }); // Fetch a large number
      if (mountedRef.current) {
        safeSetRoles(response.items || []);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('Failed to fetch roles:', err);
        message.error('Failed to load available roles for assignment.');
        safeSetRoles([]); // Set empty on error
      }
    } finally {
       if (mountedRef.current) {
           safeSetLoadingRoles(false);
       }
    }
  }, [apiClient, safeSetLoadingRoles, safeSetRoles]);


  // Initial Fetch & Fetch on Param Change
  useEffect(() => {
    fetchUsers(1, pageSize); // Fetch first page on mount/filter change
  }, [fetchUsers, pageSize]); // Rerun only when fetchUsers changes (due to apiClient) or pageSize

   // Fetch roles on mount
   useEffect(() => {
       fetchRoles();
   }, [fetchRoles]);


  // CRUD Operations
  const createUser = useCallback(async (data: CreateUserRequest): Promise<User | null> => {
    safeSetLoading(true); // Indicate loading during create
    safeSetError(null);
    try {
      const newUser = await apiClient.createUser(data);
      message.success(`User "${newUser.username}" created successfully.`);
      await fetchUsers(1, pageSize); // Refresh list from page 1
      return newUser;
    } catch (err) {
      console.error('Failed to create user:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to create user';
      safeSetError(errorMsg);
      message.error(errorMsg);
      return null;
    } finally {
       safeSetLoading(false);
    }
  }, [apiClient, fetchUsers, pageSize, safeSetLoading, safeSetError]);

  const updateUser = useCallback(async (id: number, data: UpdateUserRequest): Promise<User | null> => {
     safeSetLoading(true);
     safeSetError(null);
    try {
      const updatedUser = await apiClient.updateUser(id, data);
      message.success(`User "${updatedUser.username}" updated successfully.`);
      // Refresh only the current page for a potentially smoother experience
      await fetchUsers(currentPage, pageSize, currentSearchRef.current);
      return updatedUser;
    } catch (err) {
      console.error('Failed to update user:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to update user';
      safeSetError(errorMsg);
      message.error(errorMsg);
      return null;
    } finally {
       safeSetLoading(false);
    }
  }, [apiClient, fetchUsers, currentPage, pageSize, safeSetLoading, safeSetError]);

  const deleteUser = useCallback(async (id: number): Promise<boolean> => {
     safeSetLoading(true);
     safeSetError(null);
    try {
      await apiClient.deleteUser(id);
      message.success(`User deleted successfully.`);
       // Check if the deleted item was the last on the current page
       const newTotal = totalUsers - 1;
       const newTotalPages = Math.ceil(newTotal / pageSize);
       const pageToFetch = (currentPage > newTotalPages && newTotalPages > 0) ? newTotalPages : currentPage;
       // Refresh potentially adjusted page
       await fetchUsers(pageToFetch, pageSize, currentSearchRef.current);
       if (pageToFetch !== currentPage) safeSetCurrentPage(pageToFetch); // Update page state if changed
      return true;
    } catch (err) {
      console.error('Failed to delete user:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to delete user';
      safeSetError(errorMsg);
      message.error(errorMsg);
      return false;
    } finally {
       safeSetLoading(false);
    }
  }, [apiClient, fetchUsers, currentPage, pageSize, totalUsers, safeSetLoading, safeSetError, safeSetCurrentPage]);

  // Unmount cleanup
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  return {
    users,
    roles, // Provide roles
    loading,
    loadingRoles, // Provide roles loading state
    error,
    totalUsers,
    pagination: {
      current: currentPage,
      pageSize: pageSize,
      total: totalUsers,
    },
    fetchUsers,
    createUser,
    updateUser,
    deleteUser,
  };
}

File: src/components/Sidebar/LeftSidebarItem.component.tsx
// src/components/Sidebar/LeftSidebarItem.component.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import { Badge } from 'antd';
import { LeftSidebarItem as LeftSidebarItemType } from './LeftSidebar.interface';

interface LeftSidebarItemProps {
  data: LeftSidebarItemType;
}

const LeftSidebarItem: React.FC<LeftSidebarItemProps> = ({
  data: { title, redirect_url, dataTestId, icon: Icon, isBeta, onClick },
}) => {

  // Label and optional badge content
  const labelContent = (
    <>
      {/* This span's visibility/opacity is controlled by CSS */}
      <span className="left-panel-label">{title}</span>
      {isBeta && (
        <Badge
          className="service-beta-tag ml-1" // Add small margin if needed
          count="Beta"
          size="small"
        />
      )}
    </>
  );

  // The icon is now rendered by the parent Antd Menu.
  // This component only provides the content for the 'label' prop.
  // We render either a NavLink or a button *containing* the label content.

  return redirect_url ? (
    <NavLink
      className={({ isActive }) =>
        // Link itself shouldn't need complex flex styles now
        `left-panel-item-link block w-full ${isActive ? 'active' : ''}`
      }
      data-testid={dataTestId}
      to={redirect_url}
      title={title} // Add title attribute for accessibility on hover
    >
      {labelContent}
    </NavLink>
  ) : (
    <button
      className="left-panel-item-button block w-full text-left bg-transparent border-none cursor-pointer p-0"
      data-testid={dataTestId}
      type="button"
      onClick={onClick}
      title={title} // Add title attribute for accessibility on hover
    >
      {labelContent}
    </button>
  );
};

export default LeftSidebarItem;

File: src/components/RagInfoTab/hooks/useRagInfo.ts
// src/components/RagInfoTab/hooks/useRagInfo.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  ApiClient,
  RagInfoItem,
  RagInfoPage,
  RagInfoRequestParams,
  CreateRagInfoRequest,
  UpdateRagInfoRequest,
} from '../../../api/types'; // Adjust path as needed

const PAGE_SIZE = 10; // Or your preferred page size

export interface UseRagInfoResult {
  items: RagInfoItem[];
  loading: boolean;
  error: string | undefined;
  totalCount: number;
  totalPages: number;
  currentPage: number;
  searchTerm: string;
  setCurrentPage: (page: number) => void;
  setSearchTerm: (term: string) => void;
  refreshList: () => Promise<void>;
  createItem: (data: CreateRagInfoRequest) => Promise<RagInfoItem | null>;
  updateItem: (id: string, data: UpdateRagInfoRequest) => Promise<RagInfoItem | null>;
  deleteItem: (id: string) => Promise<boolean>;
  fetchAllForExport: (search?: string) => Promise<RagInfoItem[]>; // New method for export
}

export function useRagInfo(apiClient: ApiClient): UseRagInfoResult {
  const mountedRef = useRef(true);
  const [items, setItems] = useState<RagInfoItem[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [currentPage, setCurrentPage] = useState(1);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | undefined>(undefined);
  const [searchTerm, setSearchTerm] = useState('');

  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Safe state setters
  const safeSetItems = useCallback((data: RagInfoItem[]) => { if (mountedRef.current) setItems(data); }, []);
  const safeSetTotalCount = useCallback((count: number) => { if (mountedRef.current) setTotalCount(count); }, []);
  const safeSetTotalPages = useCallback((pages: number) => { if (mountedRef.current) setTotalPages(pages); }, []);
  const safeSetCurrentPage = useCallback((page: number) => { if (mountedRef.current) setCurrentPage(page); }, []);
  const safeSetLoading = useCallback((isLoading: boolean) => { if (mountedRef.current) setLoading(isLoading); }, []);
  const safeSetError = useCallback((err: string | undefined) => { if (mountedRef.current) setError(err); }, []);

  const fetchList = useCallback(async (page: number, search: string) => {
    safeSetLoading(true);
    safeSetError(undefined);
    console.log(`Fetching RAG Info - Page: ${page}, Search: "${search}"`);
    try {
      const params: RagInfoRequestParams = {
        page,
        limit: PAGE_SIZE,
        search: search.trim() || undefined,
      };
      const result = await apiClient.getRagInfoList(params);
      safeSetItems(result.items);
      safeSetTotalCount(result.totalCount);
      safeSetTotalPages(result.totalPages);
      // Ensure current page from response is reflected, though usually driven by request
      if (result.currentPage !== page) {
        console.warn(`API response page ${result.currentPage} differs from requested page ${page}`);
        // Optionally force set page based on response: safeSetCurrentPage(result.currentPage);
      }
    } catch (err) {
      console.error('Failed to fetch RAG info list:', err);
      safeSetError(err instanceof Error ? err.message : 'Failed to load data');
      safeSetItems([]);
      safeSetTotalCount(0);
      safeSetTotalPages(1);
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, safeSetItems, safeSetTotalCount, safeSetTotalPages, safeSetLoading, safeSetError]);

  // New function to fetch all items for export
  const fetchAllForExport = useCallback(async (search?: string): Promise<RagInfoItem[]> => {
    console.log(`Fetching all RAG info items for export. Search filter: "${search || ''}"`);
    
    try {
      // First, try to get a count of all items with the optional search filter
      const countParams: RagInfoRequestParams = {
        page: 1,
        limit: 1, // Just need count, not actual items
        search: search?.trim(),
      };
      
      const countResult = await apiClient.getRagInfoList(countParams);
      const totalItems = countResult.totalCount;
      
      if (totalItems === 0) {
        return []; // No items to export
      }
      
      // Calculate how many pages we need to fetch with a larger page size for efficiency
      const exportPageSize = 100; // Use a larger page size for export
      const pagesToFetch = Math.ceil(totalItems / exportPageSize);
      
      // Fetch all pages in parallel
      const requests: Promise<RagInfoPage>[] = [];
      for (let i = 1; i <= pagesToFetch; i++) {
        const params: RagInfoRequestParams = {
          page: i,
          limit: exportPageSize,
          search: search?.trim(),
        };
        requests.push(apiClient.getRagInfoList(params));
      }
      
      const results = await Promise.all(requests);
      
      // Combine all items from all pages
      const allItems: RagInfoItem[] = [];
      results.forEach(result => {
        allItems.push(...result.items);
      });
      
      console.log(`Successfully fetched ${allItems.length} items for export`);
      return allItems;
    } catch (err) {
      console.error('Failed to fetch all items for export:', err);
      throw new Error(err instanceof Error ? err.message : 'Failed to export data');
    }
  }, [apiClient]);

  // Effect to fetch data when page or search term changes (debounced)
  useEffect(() => {
    if (debounceTimeoutRef.current) {
      clearTimeout(debounceTimeoutRef.current);
    }
    debounceTimeoutRef.current = setTimeout(() => {
        // Reset to page 1 when search term changes
        const pageToFetch = searchTerm !== (debounceTimeoutRef.current as any)?.lastSearchTerm ? 1 : currentPage;
        if (pageToFetch === 1 && currentPage !== 1) {
            safeSetCurrentPage(1); // Reset page state visually
        }
        fetchList(pageToFetch, searchTerm);
        (debounceTimeoutRef.current as any).lastSearchTerm = searchTerm; // Store last search term
    }, 300); // 300ms debounce

    return () => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
    };
  }, [currentPage, searchTerm, fetchList, safeSetCurrentPage]);

   // Cleanup on unmount
   useEffect(() => {
       mountedRef.current = true;
       return () => {
           mountedRef.current = false;
           if (debounceTimeoutRef.current) {
               clearTimeout(debounceTimeoutRef.current);
           }
       };
   }, []);

  const refreshList = useCallback(async () => {
    await fetchList(currentPage, searchTerm);
  }, [fetchList, currentPage, searchTerm]);

  const createItem = useCallback(async (data: CreateRagInfoRequest): Promise<RagInfoItem | null> => {
    safeSetLoading(true);
    safeSetError(undefined);
    try {
      const newItem = await apiClient.createRagInfo(data);
      await refreshList(); // Refresh list after creation
      return newItem;
    } catch (err) {
      safeSetError(err instanceof Error ? err.message : 'Failed to create item');
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, refreshList, safeSetLoading, safeSetError]);

  const updateItem = useCallback(async (id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem | null> => {
    safeSetLoading(true);
    safeSetError(undefined);
    try {
      const updatedItem = await apiClient.updateRagInfo(id, data);
      // Update item in the local list optimistically or refresh
       setItems(prevItems => prevItems.map(item => item.id === id ? updatedItem : item));
      // await refreshList(); // Or refresh for simplicity
      return updatedItem;
    } catch (err) {
      safeSetError(err instanceof Error ? err.message : 'Failed to update item');
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, /* refreshList */ safeSetLoading, safeSetError]);

  const deleteItem = useCallback(async (id: string): Promise<boolean> => {
    safeSetLoading(true);
    safeSetError(undefined);
    try {
      await apiClient.deleteRagInfo(id);
      // Remove item locally or refresh
      setItems(prevItems => prevItems.filter(item => item.id !== id));
      // Decrement total count (be careful with pagination edge cases)
      setTotalCount(prev => Math.max(0, prev - 1));
      // Optional: Check if current page becomes empty and go back one page
      // await refreshList(); // Or refresh for simplicity
      return true;
    } catch (err) {
      safeSetError(err instanceof Error ? err.message : 'Failed to delete item');
      return false;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, /* refreshList */ safeSetLoading, safeSetError]);


  return {
    items,
    loading,
    error,
    totalCount,
    totalPages,
    currentPage,
    searchTerm,
    setCurrentPage: safeSetCurrentPage, // Expose safe setter
    setSearchTerm, // Direct setter is fine for input state
    refreshList,
    createItem,
    updateItem,
    deleteItem,
    fetchAllForExport, // Expose the new method for export
  };
}

File: src/components/Sidebar/LeftSidebar.component.tsx
// src/components/Sidebar/LeftSidebar.component.tsx
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import { Button, Col, Menu, MenuProps, Modal, Row, Typography } from 'antd';
import classNames from 'classnames';
import { noop } from 'lodash';
import { useLocation } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Import useAuth hook

// Import constants and types
import {
  SIDEBAR_ITEMS as BASE_SIDEBAR_ITEMS,
  BOTTOM_SIDEBAR_ITEMS,
  SIDEBAR_NESTED_KEYS,
  RAG_INFO_SIDEBAR_ITEM,
  CHAT_SIDEBAR_ITEM,
  ADMIN_SIDEBAR_ITEMS,
  LANGGRAPH_VIS_SIDEBAR_ITEM, // Import LangGraph item
} from '../../constants/LeftSidebar.constants';
import { SidebarItem as SidebarItemEnum } from '../../enum/sidebar.enum';
import { LeftSidebarItem as LeftSidebarItemType, LeftSidebarProps } from './LeftSidebar.interface';
import LeftSidebarItem from './LeftSidebarItem.component';
import './left-sidebar.css';

const LeftSidebar: React.FC<LeftSidebarProps> = ({
  isSidebarCollapsed = true,
  onLogout = () => {},
  ragEnabled = false // Default to false and let the prop override it
}) => {
  const location = useLocation();
  const { authEnabled, checkPermission } = useAuth(); // Get auth state and check function
  const [showConfirmLogoutModal, setShowConfirmLogoutModal] = useState(false);
  
  // Add debug useEffect
  useEffect(() => {
    console.log('LeftSidebar - ragEnabled:', ragEnabled);
  }, [ragEnabled]);

  const selectedKeys = useMemo(() => {
    const pathname = location.pathname;
    const matchedParent = Object.keys(SIDEBAR_NESTED_KEYS).find(key => pathname.startsWith(key));
    const parentKey = matchedParent ? SIDEBAR_NESTED_KEYS[matchedParent] : null;
    if (parentKey) return [parentKey];
    const directMatch = pathname.split('/').slice(0, 2).join('/');
    return [directMatch];
  }, [location.pathname]);

  const handleLogoutClick = useCallback(() => { setShowConfirmLogoutModal(true); }, []);
  const hideConfirmationModal = () => { setShowConfirmLogoutModal(false); };
  const handleLogout = useCallback(() => { onLogout(); setShowConfirmLogoutModal(false); }, [onLogout]);

  // Filter menu items based on permissions
  const filterItemsByPermission = useCallback((items: LeftSidebarItemType[]): MenuProps['items'] => {
    return items
      .filter(item => !authEnabled || !item.requiredPermission || checkPermission(item.requiredPermission)) // Filter top-level
      .map(item => ({
        key: item.key,
        label: <LeftSidebarItem data={item} />,
        icon: item.icon ? React.createElement(item.icon) : undefined,
        // Recursively filter children if needed
        children: item.children
          ?.filter(child => !authEnabled || !child.requiredPermission || checkPermission(child.requiredPermission))
          .map((childItem: LeftSidebarItemType) => ({
            key: childItem.key,
            label: <LeftSidebarItem data={childItem} />,
            icon: childItem.icon ? React.createElement(childItem.icon) : undefined,
          })),
      }));
  }, [authEnabled, checkPermission]);

  // Map menu items with conditional RAG and Admin items
  const topMenuItems: MenuProps['items'] = useMemo(() => {
    let items: LeftSidebarItemType[] = [...BASE_SIDEBAR_ITEMS]; // Start with base items from constants

    // Determine the insertion index for Chat and RAG
    const historyIndex = items.findIndex(item => item?.key === SidebarItemEnum.HISTORY);
    let insertionPoint = historyIndex !== -1 ? historyIndex + 1 : items.length;

    // Insert Chat Item
    items.splice(insertionPoint, 0, CHAT_SIDEBAR_ITEM);
    insertionPoint++; // Move insertion point for next item

    // Insert RAG item if enabled
    if (ragEnabled === true) {
      console.log("RAG is enabled, adding RAG menu item");
      items.splice(insertionPoint, 0, RAG_INFO_SIDEBAR_ITEM);
      insertionPoint++; // Move insertion point for next item
    } else {
      console.log("RAG is not enabled, not adding RAG menu item");
    }

    // Insert LangGraph item
    items.splice(insertionPoint, 0, LANGGRAPH_VIS_SIDEBAR_ITEM);
    // insertionPoint++; // Not needed if LangGraph is the last dynamic item before admin items

    // Add Admin items (conditionally displayed based on permissions in the filter below)
    items = [...items, ...ADMIN_SIDEBAR_ITEMS];

    // Filter based on permissions
    return filterItemsByPermission(items);
  }, [ragEnabled, filterItemsByPermission]);

  const bottomMenuItems: MenuProps['items'] = useMemo(
    () => filterItemsByPermission(BOTTOM_SIDEBAR_ITEMS.map(item => ({
      ...item,
      onClick: item.key === SidebarItemEnum.LOGOUT ? handleLogoutClick : item.onClick || noop,
    }))),
    [handleLogoutClick, filterItemsByPermission]
  );

  return (
    <div
      className={classNames(
        'flex flex-col justify-between h-full left-sidebar-container',
        { 'sidebar-open': !isSidebarCollapsed }
      )}
      data-testid="left-sidebar"
    >
      <Row>
        <Col className="w-full">
          <Menu
            items={topMenuItems}
            mode="inline"
            theme="light"
            inlineCollapsed={isSidebarCollapsed}
            className="left-sidebar-menu"
            selectedKeys={selectedKeys}
            style={{ border: 'none' }}
          />
        </Col>
      </Row>

      <Row className="py-2">
        <Col span={24}>
          <Menu
            items={bottomMenuItems}
            mode="inline"
            theme="light"
            inlineCollapsed={isSidebarCollapsed}
            className="left-sidebar-menu"
            selectable={false}
            style={{ border: 'none' }}
          />
        </Col>
      </Row>

      {showConfirmLogoutModal && (
        <Modal
          centered
          title="Logout Confirmation"
          open={showConfirmLogoutModal}
          onCancel={hideConfirmationModal}
          footer={[
            <Button key="cancel" onClick={hideConfirmationModal}>
              Cancel
            </Button>,
            <Button key="logout" type="primary" danger onClick={handleLogout} data-testid="confirm-logout">
              Logout
            </Button>,
          ]}
        >
          <Typography.Text>Are you sure you want to log out?</Typography.Text>
        </Modal>
      )}
    </div>
  );
};

export default LeftSidebar;

File: src/components/ConfigValue.tsx
/**
 * ConfigValue is a reusable component for rendering configuration values of different types.
 * It handles special cases like sensitive data masking, boolean styling, and complex object display.
 *
 * @component
 * @example
 * ```tsx
 * <ConfigValue configKey="apiKey" value="secret" />        // Renders: ********
 * <ConfigValue configKey="enabled" value={true} />         // Renders: True (with green styling)
 * <ConfigValue configKey="items" value={[1, 2, 3]} />     // Renders: Array[3]
 * ```
 */
import React from 'react';

// Helper function to generate user-friendly labels from keys
export const getConfigLabel = (key: string): string => {
  // Replace underscores/camelCase with spaces and capitalize words
  const result = key
    .replace(/_/g, ' ') // Replace underscores with spaces
    .replace(/([A-Z])/g, ' $1') // Add space before uppercase letters
    .replace(/^./, (str) => str.toUpperCase()) // Capitalize first letter
    .trim();

  // Specific replacements for acronyms or common terms
  return result
    .replace(/Llm/g, 'LLM')
    .replace(/Api/g, 'API')
    .replace(/Id/g, 'ID')
    .replace(/Url/g, 'URL')
    .replace(/Db/g, 'DB')
    .replace(/Jwt/g, 'JWT')
    .replace(/Rag /g, 'RAG ') // Keep RAG capitalized
    .replace(/Unspsc/g, 'UNSPSC');
};

interface ConfigValueProps {
  /** The configuration key, used to determine if value should be masked */
  configKey: string;
  /** The value to render */
  value: any;
  /** Optional className for styling override */
  className?: string;
}

const ConfigValue: React.FC<ConfigValueProps> = ({ value, configKey, className = '' }): JSX.Element => {
  // Function to check if a value should be masked (for sensitive data)
  const shouldMaskValueByKey = (key: string): boolean => {
    const lowerKey = key.toLowerCase();
    const sensitiveKeys = ['password', 'apikey', 'secret', 'token']; // Add 'token'
    return sensitiveKeys.some(sensitiveKey => lowerKey.includes(sensitiveKey));
  };

  const isRedactedValue = (val: any): boolean => {
    return typeof val === 'string' && val.toUpperCase().includes('[REDACTED]');
  };

  if (value === null || value === undefined) {
    return <span className={`text-secondary-400 italic ${className}`}>Not set</span>;
  }

  // Check if backend already redacted it OR if key indicates sensitivity
  if (isRedactedValue(value) || shouldMaskValueByKey(configKey)) {
    return <span className={`text-secondary-700 font-mono ${className}`}>••••••••</span>; // Consistent masking
  }

  if (typeof value === 'boolean') {
    return (
      <span className={`px-2 py-0.5 text-xs rounded-full font-medium border ${className} ${
        value
          ? 'bg-green-100 text-green-800 border-green-200'
          : 'bg-red-100 text-red-800 border-red-200'
      }`}>
        {value ? 'Enabled' : 'Disabled'}
      </span>
    );
  }

   if (typeof value === 'object' && value !== null) {
     // Don't display complex objects directly, parent component will handle recursion
     return <span className={`text-secondary-500 italic ${className}`}>Object</span>;
   }

   // Render arrays as comma-separated list (or count)
   if (Array.isArray(value)) {
     if (value.length === 0) {
       return <span className={`text-secondary-400 italic ${className}`}>Empty List</span>;
     }
     const displayLimit = 5;
     const displayValue = value.slice(0, displayLimit).map(item => typeof item === 'object' ? '[Object]' : String(item)).join(', ');
     return (
       <span className={`text-secondary-700 ${className}`} title={value.join(', ')}>
         {displayValue}{value.length > displayLimit ? `... (${value.length} items)` : ''}
       </span>
     );
   }

  // Default: render as string
  return <span className={`text-secondary-700 ${className}`}>{String(value)}</span>;
};

export default ConfigValue;

File: src/components/UserManagement/components/UserFormModal.tsx
// src/components/UserManagement/components/UserFormModal.tsx
import React, { useEffect, useState } from 'react'; // Add useState import
import { Modal, Form, Input, Select, Button, Spin, Alert, message } from 'antd';
import { User, Role, CreateUserRequest, UpdateUserRequest } from '../../../api/types';

interface UserFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: CreateUserRequest | UpdateUserRequest) => Promise<boolean>; // Returns success status
  initialData?: User;
  availableRoles: Role[]; // Pass available roles for selection
  loading: boolean; // Loading state for submission
  loadingRoles: boolean; // Loading state for roles dropdown
}

const { Option } = Select;

export const UserFormModal: React.FC<UserFormModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  initialData,
  availableRoles,
  loading,
  loadingRoles,
}) => {
  const [form] = Form.useForm();
  const [formError, setFormError] = useState<string | null>(null);

  const isEditMode = !!initialData;

  useEffect(() => {
    if (isOpen) {
      setFormError(null); // Clear errors when opening
      if (isEditMode && initialData) {
        form.setFieldsValue({
          username: initialData.username,
          roles: initialData.roles || [],
          // Don't set password field for edit mode unless changing password
        });
      } else {
        form.resetFields();
      }
    }
  }, [isOpen, initialData, form, isEditMode]);

  const handleFinish = async (values: any) => {
    setFormError(null);
    const roles = values.roles || []; // Ensure roles is an array

    let success = false;
    if (isEditMode && initialData) {
      const updateData: UpdateUserRequest = {
        username: values.username !== initialData.username ? values.username : undefined,
        password: values.password || undefined, // Only include password if provided
        roles: roles, // Always send roles to potentially update
      };
      // Filter out undefined fields before sending
      const filteredUpdateData = Object.fromEntries(
          Object.entries(updateData).filter(([_, v]) => v !== undefined)
      ) as UpdateUserRequest;

      // Check if anything actually changed
      if (Object.keys(filteredUpdateData).length === 0 && JSON.stringify(roles) === JSON.stringify(initialData.roles || [])) {
         message.info("No changes detected.");
         onClose(); // Close if no changes
         return;
      }

      success = await onSubmit(filteredUpdateData);
    } else {
      const createData: CreateUserRequest = {
        username: values.username,
        password: values.password,
        roles: roles,
      };
      success = await onSubmit(createData);
    }

    if (success) {
      onClose(); // Close modal on successful submission
    } else {
      // Error message is usually shown via Ant message in the hook
      setFormError("Failed to save user. Please try again.");
    }
  };

  const filterOption = (input: string, option: any) => {
    const childText = option?.children;
    return childText && typeof childText === 'string' 
      ? childText.toLowerCase().includes(input.toLowerCase()) 
      : false;
  };

  return (
    <Modal
      title={isEditMode ? `Edit User: ${initialData?.username}` : 'Create New User'}
      open={isOpen}
      visible={isOpen} /* Added for backward compatibility with Ant Design v4 */
      onCancel={onClose}
      confirmLoading={loading}
      destroyOnClose // Reset form state when closed
      footer={[
        <Button key="back" onClick={onClose} disabled={loading}>
          Cancel
        </Button>,
        <Button key="submit" type="primary" loading={loading} onClick={() => form.submit()}>
          {isEditMode ? 'Save Changes' : 'Create User'}
        </Button>,
      ]}
      width={600}
    >
      <Spin spinning={loading || loadingRoles}>
        {formError && <Alert message={formError} type="error" showIcon closable onClose={() => setFormError(null)} className="mb-4" />}
        <Form
          form={form}
          layout="vertical"
          onFinish={handleFinish}
          name="userForm"
          initialValues={{ roles: isEditMode ? initialData?.roles : [] }} // Set initial roles
        >
          <Form.Item
            name="username"
            label="Username"
            rules={[{ required: true, message: 'Please input the username!' }]}
          >
            <Input placeholder="Enter username" disabled={isEditMode} />
            {/* Username usually not editable */}
          </Form.Item>

          <Form.Item
            name="password"
            label={isEditMode ? 'New Password (leave blank to keep current)' : 'Password'}
            rules={[{ required: !isEditMode, message: 'Password is required for new users!' }]}
            hasFeedback
          >
            <Input.Password placeholder={isEditMode ? 'Enter new password' : 'Enter password'} />
          </Form.Item>

          {isEditMode && (
            <Form.Item
              name="confirmPassword"
              label="Confirm New Password"
              dependencies={['password']}
              hasFeedback
              rules={[
                ({ getFieldValue }) => ({
                  validator(_, value) {
                    if (!getFieldValue('password') || !value || getFieldValue('password') === value) {
                      return Promise.resolve();
                    }
                    return Promise.reject(new Error('The two passwords that you entered do not match!'));
                  },
                }),
              ]}
            >
              <Input.Password placeholder="Confirm new password" />
            </Form.Item>
          )}

          <Form.Item
            name="roles"
            label="Roles"
             rules={[{ type: 'array' }]} // Antd rule for array type
          >
             <Select
               mode="multiple"
               allowClear
               style={{ width: '100%' }}
               placeholder="Select roles"
               loading={loadingRoles}
               disabled={loadingRoles}
               filterOption={filterOption}
             >
               {availableRoles.map(role => (
                 <Option key={role.id} value={role.name} label={role.name}>
                   <div className="flex flex-col">
                      <span>{role.name}</span>
                      {role.description && <span className="text-xs text-gray-500">{role.description}</span>}
                   </div>
                 </Option>
               ))}
             </Select>
          </Form.Item>

        </Form>
      </Spin>
    </Modal>
  );
};

File: src/components/RoleManagement/RoleManagementComponent.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Modal, Form, Input, message, Space, Select, Tag, Tooltip, Row, Col, Alert } from 'antd';
import { useAuth } from '../../context/AuthContext';
import { EditOutlined, DeleteOutlined, EyeOutlined, PlusOutlined } from '@ant-design/icons';
import { 
  ApiClient, 
  CreateRoleRequest,
  UpdateRoleRequest,
  Role,
  Permission
} from '../../api/types';

// Define the types needed for Role Management functionality
export interface RoleManagementComponentProps {
  apiClient: ApiClient;
}

export const RoleManagementComponent: React.FC<RoleManagementComponentProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  // Component state
  const [roles, setRoles] = useState<Role[]>([]);
  const [permissions, setPermissions] = useState<Permission[]>([]);
  const [loading, setLoading] = useState(false);
  const [loadingPermissions, setLoadingPermissions] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showViewModal, setShowViewModal] = useState(false);
  const [selectedRole, setSelectedRole] = useState<Role | null>(null);
  const [pagination, setPagination] = useState({ current: 1, pageSize: 10, total: 0 });
  const [form] = Form.useForm();
  
  // State for tracking selected permissions directly
  const [selectedPermissions, setSelectedPermissions] = useState<string[]>([]);
  
  // Load roles and permissions when component mounts
  useEffect(() => {
    loadRoles();
    loadPermissions();
  }, []);
  
  // Reset selected permissions when modals close
  useEffect(() => {
    if (!showCreateModal && !showEditModal) {
      setSelectedPermissions([]);
    }
  }, [showCreateModal, showEditModal]);
  
  const loadRoles = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await apiClient.getRoles({ limit: 500 }); // Get all roles, adjust if needed
      setRoles(response.items || []);
      setPagination({
        ...pagination,
        total: response.totalCount || 0
      });
    } catch (err) {
      console.error('Failed to load roles:', err);
      setError('Failed to load roles');
    } finally {
      setLoading(false);
    }
  };
  
  const loadPermissions = async () => {
    setLoadingPermissions(true);
    
    try {
      const response = await apiClient.getPermissions();
      setPermissions(response.items || []);
    } catch (err) {
      console.error('Failed to load permissions:', err);
      message.error('Failed to load permissions. Permission selection may be incomplete.');
    } finally {
      setLoadingPermissions(false);
    }
  };
  
  const handleCreateRole = async (data: any) => {
    // Check if user has permission to create roles
    if (!checkPermission('roles:create')) {
      setError('You do not have permission to create roles');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: CreateRoleRequest = {
        name: data.name,
        description: data.description || undefined,
        permissions: selectedPermissions // Use the directly managed state
      };
      
      await apiClient.createRole(request);
      message.success('Role created successfully');
      setShowCreateModal(false);
      form.resetFields();
      setSelectedPermissions([]);
      loadRoles(); // Refresh the list
    } catch (err) {
      console.error('Failed to create role:', err);
      setError('Failed to create role');
    } finally {
      setLoading(false);
    }
  };
  
  const handleUpdateRole = async (data: any) => {
    // Check if user has permission to update roles
    if (!checkPermission('roles:update')) {
      setError('You do not have permission to update roles');
      return;
    }
    
    if (!selectedRole) {
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: UpdateRoleRequest = {
        name: data.name !== selectedRole.name ? data.name : undefined,
        description: data.description !== selectedRole.description ? data.description : undefined,
        permissions: selectedPermissions // Use the directly managed state
      };
      
      // Filter out undefined fields for cleaner request
      const filteredRequest = Object.fromEntries(
        Object.entries(request).filter(([_, v]) => v !== undefined)
      ) as UpdateRoleRequest;

      // Ensure permissions are always sent
      if (!filteredRequest.permissions) {
        filteredRequest.permissions = selectedPermissions;
      }
      
      await apiClient.updateRole(selectedRole.id, filteredRequest);
      message.success('Role updated successfully');
      setShowEditModal(false);
      form.resetFields();
      setSelectedPermissions([]);
      loadRoles(); // Refresh the list
    } catch (err) {
      console.error('Failed to update role:', err);
      setError('Failed to update role');
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeleteRole = async (id: number) => {
    // Check if user has permission to delete roles
    if (!checkPermission('roles:delete')) {
      setError('You do not have permission to delete roles');
      return;
    }
    
    setLoading(true);
    
    try {
      await apiClient.deleteRole(id);
      message.success('Role deleted successfully');
      loadRoles(); // Refresh the list
    } catch (err) {
      console.error('Failed to delete role:', err);
      setError('Failed to delete role');
    } finally {
      setLoading(false);
    }
  };
  
  const showDeleteConfirm = (id: number, name: string) => {
    // Don't allow deletion of core roles
    if (name === 'admin' || name === 'classifier') {
      message.error('Core system roles cannot be deleted');
      return;
    }
    
    Modal.confirm({
      title: `Are you sure you want to delete ${name}?`,
      content: 'This action cannot be undone. Users with only this role will lose permissions.',
      okText: 'Yes',
      okType: 'danger',
      cancelText: 'No',
      onOk() {
        handleDeleteRole(id);
      },
    });
  };
  
  const openCreateModal = () => {
    form.resetFields();
    setSelectedPermissions([]);
    setShowCreateModal(true);
  };
  
  const openEditModal = (role: Role) => {
    setSelectedRole(role);
    
    // Map role permissions to just the codes for the form
    const permissionCodes = role.permissions ? role.permissions.map(p => p.code) : [];
    
    form.setFieldsValue({
      name: role.name,
      description: role.description || '',
    });
    
    // Set selected permissions directly in state
    setSelectedPermissions(permissionCodes);
    
    setShowEditModal(true);
  };
  
  const openViewModal = (role: Role) => {
    setSelectedRole(role);
    setShowViewModal(true);
  };
  
  const isCoreRole = (name: string): boolean => {
    return name === 'admin' || name === 'classifier';
  };
  
  const formatPermissions = (perms: Permission[] | undefined) => {
    if (!perms || perms.length === 0) {
      return <Tag>No Permissions</Tag>;
    }
    
    const displayCount = 3; // Max permissions to show directly
    const hiddenCount = perms.length - displayCount;
    
    return (
      <Space size={[0, 4]} wrap>
        {perms.slice(0, displayCount).map(perm => (
          <Tooltip key={perm.id} title={perm.description || perm.code}>
            <Tag color="blue" style={{ cursor: 'help' }}>{perm.code}</Tag>
          </Tooltip>
        ))}
        {hiddenCount > 0 && (
          <Tooltip title={perms.slice(displayCount).map(p => p.code).join(', ')}>
            <Tag>+{hiddenCount} more</Tag>
          </Tooltip>
        )}
      </Space>
    );
  };
  
  const handlePermissionChange = (category: string, selected: string[]) => {
    // Get all permissions for this category
    const categoryPermissions = permissions
      .filter(p => (p.code.split(':')[0] || 'other') === category)
      .map(p => p.code);
    
    // Remove all permissions from this category from the selected list
    const filteredPermissions = selectedPermissions.filter(
      code => !categoryPermissions.includes(code)
    );
    
    // Add newly selected permissions from this category
    const newSelectedPermissions = [...filteredPermissions, ...selected];
    setSelectedPermissions(newSelectedPermissions);
  };
  
  // Group permissions by category for better organization
  const groupPermissionsByCategory = (perms: Permission[]) => {
    const grouped: Record<string, Permission[]> = {};
    
    perms.forEach(perm => {
      const category = perm.code.split(':')[0] || 'other';
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(perm);
    });
    
    return Object.entries(grouped).sort(([catA], [catB]) => {
      if (catA === 'other') return 1;
      if (catB === 'other') return -1;
      return catA.localeCompare(catB);
    });
  };

  const columns = [
    {
      title: 'Role Name',
      dataIndex: 'name',
      key: 'name',
      sorter: (a: Role, b: Role) => a.name.localeCompare(b.name),
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
    },
    {
      title: 'Permissions',
      dataIndex: 'permissions',
      key: 'permissions',
      render: (permissions: Permission[]) => formatPermissions(permissions),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: Role) => (
        <Space size="small">
          <Button 
            type="text" 
            icon={<EyeOutlined />} 
            onClick={() => openViewModal(record)}
          />
          {checkPermission('roles:update') && (
            <Button 
              type="text" 
              icon={<EditOutlined />} 
              onClick={() => openEditModal(record)}
            />
          )}
          {checkPermission('roles:delete') && !isCoreRole(record.name) && (
            <Button 
              type="text" 
              danger 
              icon={<DeleteOutlined />} 
              onClick={() => showDeleteConfirm(record.id, record.name)}
            />
          )}
        </Space>
      ),
    },
  ];
  
  return (
    <div className="role-management-container">
      {error && <div className="error-message mb-4 p-3 text-red-700 bg-red-50 border border-red-200 rounded">{error}</div>}
      
      <div className="actions-container" style={{ marginBottom: '16px' }}>
        {checkPermission('roles:create') && (
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={openCreateModal}
          >
            Add New Role
          </Button>
        )}
      </div>
      
      <Table
        dataSource={roles}
        columns={columns}
        rowKey="id"
        loading={loading}
        pagination={false} // Typically roles won't require pagination
      />
      
      {/* Create Modal - Using direct state for permissions instead of form fields */}
      <Modal
        title="Add New Role"
        open={showCreateModal}
        onCancel={() => setShowCreateModal(false)}
        footer={null}
        width={700} // Wider modal for permissions list
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleCreateRole}
        >
          <Form.Item
            name="name"
            label="Role Name"
            rules={[{ required: true, message: 'Please enter a role name' }]}
          >
            <Input placeholder="Enter role name (e.g., data_analyst)" />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
          >
            <Input.TextArea rows={2} placeholder="Description of the role's purpose and access level" />
          </Form.Item>
          
          <div className="form-section">
            <label className="ant-form-item-label">
              <span className="ant-form-item-label-text">Permissions</span>
            </label>
            <div className="ant-form-item-explain">Select permissions for this role</div>
            <div className="permissions-section" style={{ marginTop: '8px' }}>
              {groupPermissionsByCategory(permissions).map(([category, perms]) => {
                // Get the currently selected permissions for this category
                const categoryPermissions = selectedPermissions.filter(code => 
                  perms.some(p => p.code === code)
                );
                
                return (
                  <div key={category} className="mb-4">
                    <div className="font-medium text-gray-600 capitalize mb-2">
                      {category.replace(/_/g, ' ')} Permissions
                    </div>
                    <Select
                      mode="multiple"
                      placeholder={`Select ${category} permissions`}
                      style={{ width: '100%' }}
                      allowClear
                      options={perms.map(perm => ({
                        label: perm.code,
                        value: perm.code,
                        title: perm.description || perm.code,
                      }))}
                      value={categoryPermissions}
                      onChange={(values) => handlePermissionChange(category, values)}
                      listHeight={200}
                      maxTagCount={5}
                      optionFilterProp="label"
                    />
                  </div>
                );
              })}
              
              {selectedPermissions.length === 0 && (
                <div className="ant-form-item-explain ant-form-item-explain-error">
                  Please select at least one permission
                </div>
              )}
            </div>
          </div>
          
          <Form.Item style={{ marginTop: '16px' }}>
            <Button 
              type="primary" 
              htmlType="submit" 
              loading={loading} 
              style={{ marginRight: 8 }}
              disabled={selectedPermissions.length === 0}
            >
              Create
            </Button>
            <Button onClick={() => setShowCreateModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* Edit Modal - Using direct state for permissions instead of form fields */}
      <Modal
        title={`Edit Role: ${selectedRole?.name}`}
        open={showEditModal}
        onCancel={() => setShowEditModal(false)}
        footer={null}
        width={700} // Wider modal for permissions list
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleUpdateRole}
        >
          {selectedRole && isCoreRole(selectedRole.name) && (
            <Alert
              message="Core Role"
              description="This is a core system role. Some properties cannot be modified to prevent system disruption."
              type="warning"
              showIcon
              className="mb-4"
            />
          )}
          
          <Form.Item
            name="name"
            label="Role Name"
            rules={[{ required: true, message: 'Please enter a role name' }]}
          >
            <Input disabled={selectedRole ? isCoreRole(selectedRole.name) : false} />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
          >
            <Input.TextArea rows={2} />
          </Form.Item>
          
          <div className="form-section">
            <label className="ant-form-item-label">
              <span className="ant-form-item-label-text">Permissions</span>
            </label>
            <div className="permissions-section">
              {groupPermissionsByCategory(permissions).map(([category, perms]) => {
                // Get the currently selected permissions for this category
                const categoryPermissions = selectedPermissions.filter(code => 
                  perms.some(p => p.code === code)
                );
                
                return (
                  <div key={category} className="mb-4">
                    <div className="font-medium text-gray-600 capitalize mb-2">
                      {category.replace(/_/g, ' ')} Permissions
                    </div>
                    <Select
                      mode="multiple"
                      placeholder={`Select ${category} permissions`}
                      style={{ width: '100%' }}
                      allowClear
                      options={perms.map(perm => ({
                        label: perm.code,
                        value: perm.code,
                        title: perm.description || perm.code,
                        disabled: selectedRole && isCoreRole(selectedRole.name) ? 
                          (perm.code === 'roles:manage' || perm.code === 'users:manage') : undefined
                      }))}
                      value={categoryPermissions}
                      onChange={(values) => handlePermissionChange(category, values)}
                      listHeight={200}
                      maxTagCount={5}
                      optionFilterProp="label"
                    />
                  </div>
                );
              })}
            </div>
          </div>
          
          <Form.Item style={{ marginTop: '16px' }}>
            <Button 
              type="primary" 
              htmlType="submit" 
              loading={loading} 
              style={{ marginRight: 8 }}
              disabled={selectedPermissions.length === 0}
            >
              Update
            </Button>
            <Button onClick={() => setShowEditModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* View Modal */}
      <Modal
        title="Role Details"
        open={showViewModal}
        onCancel={() => setShowViewModal(false)}
        footer={[
          <Button key="close" onClick={() => setShowViewModal(false)}>
            Close
          </Button>
        ]}
        width={600}
      >
        {selectedRole && (
          <>
            <p><strong>Name:</strong> {selectedRole.name}</p>
            <p><strong>Description:</strong> {selectedRole.description || 'No description'}</p>
            <p><strong>Permissions:</strong></p>
            
            {selectedRole.permissions && selectedRole.permissions.length > 0 ? (
              <div className="mb-3 border p-3 rounded bg-gray-50" style={{ maxHeight: '200px', overflow: 'auto' }}>
                {groupPermissionsByCategory(selectedRole.permissions).map(([category, perms]) => (
                  <div key={category} className="mb-3 last:mb-0">
                    <div className="font-medium capitalize mb-1">{category.replace(/_/g, ' ')}:</div>
                    <div className="pl-2">
                      {perms.map(perm => (
                        <div key={perm.id} className="mb-1">
                          <Tag color="blue">{perm.code}</Tag>
                          {perm.description && <span className="text-sm text-gray-600 ml-2">{perm.description}</span>}
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-gray-500">This role has no assigned permissions</div>
            )}
          </>
        )}
      </Modal>
    </div>
  );
};

export default RoleManagementComponent;

File: src/components/Settings.tsx
import React, { useState, useEffect, ReactNode, useMemo } from 'react';
import { LlmConfig } from '../api/types';
import ConfigValue from './ConfigValue';

interface SettingsProps {
  apiClient: {
    getConfig(): Promise<LlmConfig>;
    updateConfig(config: LlmConfig): Promise<void>;
  };
}

interface SectionGroups {
  rag: Record<string, any>;
  basic: Record<string, any>;
}

const Settings: React.FC<SettingsProps> = ({ apiClient }): JSX.Element => {
  const [config, setConfig] = useState<LlmConfig | null>(null);
  const [notification, setNotification] = useState<{ type: 'success' | 'error', message: string } | null>(null);
  const [expandedSections, setExpandedSections] = useState<{[key: string]: boolean}>({
    server: true,
    service: true,
    database: true,
    validation: true,
    alert: true
  });

  // Memoized labels for config keys
  const configLabels = useMemo<Record<string, string>>(() => ({
    ragEnabled: 'RAG Enabled',
    ragServiceUrl: 'RAG Service URL',
    ragManualInfoCollection: 'RAG Manual Info Collection',
    ragUnspscCollection: 'RAG UNSPSC Collection',
    ragCommonCollection: 'RAG Common Collection'
  }), []);

  // Function to get a user-friendly label for a config key
  const getConfigLabel = (key: string): string => configLabels[key] || key;

  // Function to toggle section expansion
  const toggleSection = (section: string): void => {
    setExpandedSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  useEffect(() => {
    const loadConfig = async () => {
      try {
        const data = await apiClient.getConfig();
        setConfig(data);
      } catch (error) {
        console.error('Error loading config:', error);
        setNotification({
          type: 'error',
          message: 'Failed to load settings'
        });
      }
    };
    
    loadConfig();
  }, [apiClient]);

  // Group related settings
  const groupSettings = (obj: any): SectionGroups => {
    const groups: SectionGroups = {
      rag: {},
      basic: {},
    };

    if (!obj) return groups;

    Object.entries(obj).forEach(([key, value]) => {
      if (key.toLowerCase().startsWith('rag')) {
        groups.rag[key] = value;
      } else {
        groups.basic[key] = value;
      }
    });

    return groups;
  };

  // Recursive function to render nested config entries
  const renderEntries = (obj: any, indent: number = 0): JSX.Element[] => {
    if (obj === null || obj === undefined) return [];

    // For database section, use special grouping
    if (indent === 0 && config?.database && obj === config.database) {
      const groups = groupSettings(obj);
      const hasRagSettings = Object.keys(groups.rag).length > 0;
      const result: JSX.Element[] = [];

      if (hasRagSettings) {
        result.push(
          <div key="rag-header" className="mt-2 mb-3">
            <h4 className="text-sm font-semibold text-primary-600 mb-2">RAG Configuration</h4>
            {Object.entries(groups.rag).map(([key, value]) => (
              <div key={key} className="grid grid-cols-2 gap-x-2 py-1">
                <div className="text-sm font-medium text-secondary-700">{getConfigLabel(key)}:</div>
                <div className="text-sm">
                  <ConfigValue configKey={key} value={value} />
                </div>
              </div>
            ))}
          </div>
        );
      }

      if (Object.keys(groups.basic).length > 0) {
        result.push(
          <div key="basic-header" className={`mt-4 ${!hasRagSettings ? 'mt-2' : ''}`}>
            <h4 className="text-sm font-semibold text-secondary-600 mb-2">Database Settings</h4>
            {Object.entries(groups.basic).map(([key, value]) => {
              const isObj = typeof value === 'object' && value !== null;
              return (
                <div key={key} className="grid grid-cols-2 gap-x-2 py-1">
                  <div className="text-sm font-medium text-secondary-700">{getConfigLabel(key)}:</div>
                  <div className="text-sm">
                    {!isObj ? <ConfigValue configKey={key} value={value} /> : ''}
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      return result;
    }

    // For other sections, render nested entries
    const entries: JSX.Element[] = [];
    Object.entries(obj).forEach(([key, value]) => {
      const isObj = typeof value === 'object' && value !== null;
      const marginStyle = { marginLeft: `${indent * 1}rem` };

      entries.push(
        <div key={`${key}-${indent}`} className="grid grid-cols-2 gap-x-2 py-1" style={marginStyle}>
          <div className="text-sm font-medium text-secondary-700">{getConfigLabel(key)}:</div>
          <div className="text-sm">
            {!isObj ? <ConfigValue configKey={key} value={value} /> : ''}
          </div>
        </div>
      );

      if (Array.isArray(value)) {
        value.forEach((item, idx) => {
          entries.push(
            <div key={`${key}-${idx}`} style={{ marginLeft: `${(indent + 1) * 1}rem` }}>
              <div className="text-sm font-medium text-secondary-700">[{idx}]</div>
              {typeof item === 'object' && item !== null ?
                renderEntries(item, indent + 2) :
                <div className="text-sm">
                  <ConfigValue configKey={key} value={item} />
                </div>}
            </div>
          );
        });
      } else if (isObj) {
        entries.push(...renderEntries(value, indent + 1));
      }
    });

    return entries;
  };

  // Function to render a configuration section
  const renderConfigSection = (title: string, configSection: any, sectionKey: string): JSX.Element => {
    if (!configSection) return <></>;
    
    return (
      <div className="mb-6 bg-white shadow-card rounded-card">
        <div 
          className="flex items-center justify-between p-4 border-b cursor-pointer"
          onClick={() => toggleSection(sectionKey)}
        >
          <h3 className="text-lg font-medium text-secondary-900">{title}</h3>
          <button className="text-gray-500">
            {expandedSections[sectionKey] ? '▼' : '▶'}
          </button>
        </div>
        
        {expandedSections[sectionKey] && (
          <div className="p-4">
            {renderEntries(configSection)}
          </div>
        )}
      </div>
    );
  };

  if (!config) {
    return (
      <div className="max-w-8xl mx-auto space-y-10 p-4">
        <div className="bg-white shadow-card rounded-card p-8">
          <p className="text-secondary-700">Loading configuration...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-8xl mx-auto space-y-6" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
      <div className="bg-white shadow-card rounded-card p-6 w-full">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-semibold text-secondary-900">System Configuration</h2>
        </div>

        {notification && (
          <div className={`mb-6 rounded-card px-4 py-3 ${
            notification.type === 'success'
              ? 'bg-green-50/50 border border-green-200 text-green-700'
              : 'bg-red-50/50 border border-red-200 text-red-700'
          }`}>
            <p className="text-sm">{notification.message}</p>
          </div>
        )}

        <div className="text-sm text-gray-600 mb-6">
          <p>This is a read-only view of the current system configuration. Sensitive information is masked with asterisks.</p>
        </div>

        {renderConfigSection('Server Configuration', config.server, 'server')}
        {renderConfigSection('Service Configuration', config.service, 'service')}
        {renderConfigSection('Database Configuration', config.database, 'database')}
        {renderConfigSection('Validation Configuration', config.validation, 'validation')}
        {renderConfigSection('Alert Configuration', config.alert, 'alert')}
      </div>
    </div>
  );
};

export default Settings;

File: src/components/RagInfoTab/components/RagInfoPagination.tsx
// src/components/RagInfoTab/components/RagInfoPagination.tsx
import React from 'react';

interface RagInfoPaginationProps {
    currentPage: number;
    totalPages: number;
    totalCount: number;
    pageSize: number; // Pass pageSize if needed for display
    loading: boolean;
    onPageChange: (page: number) => void;
}

export const RagInfoPagination: React.FC<RagInfoPaginationProps> = ({
    currentPage, totalPages, totalCount, pageSize, loading, onPageChange
}) => {
    // Don't show pagination if only one page or no results
    if (!totalCount || totalPages <= 1) {
        return null;
    }

    const firstItem = (currentPage - 1) * pageSize + 1;
    const lastItem = Math.min(currentPage * pageSize, totalCount);

    return (
        <div className="mt-6 flex items-center justify-between">
            {/* Results Count Text */}
            <p className="text-sm text-secondary-600">
                Showing <span className="font-medium">{firstItem}</span>-
                <span className="font-medium">{lastItem}</span> of{' '}
                <span className="font-medium">{totalCount}</span> results
            </p>
            {/* Pagination Buttons */}
            <div className="flex items-center gap-1">
                <button
                    onClick={() => onPageChange(1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >First</button>
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Previous</button>
                <span className="text-sm text-secondary-600 px-2">
                    Page {currentPage} of {totalPages}
                </span>
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Next</button>
                <button
                    onClick={() => onPageChange(totalPages)}
                    disabled={currentPage === totalPages || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Last</button>
            </div>
        </div>
    );
};

File: src/components/UserManagement/components/UserTable.tsx
// src/components/UserManagement/components/UserTable.tsx
import React from 'react';
import { Table, Space, Button, Tag, Popconfirm, Tooltip } from 'antd';
import { EditOutlined, DeleteOutlined } from '@ant-design/icons';
import { User } from '../../../api/types';
import { formatDate } from '../../../utils/dateFormat'; // Assuming you have this

const DEFAULT_PAGE_SIZE = 10;

interface UserTableProps {
  users: User[];
  rolesMap: Map<string, string>; // Map role name to description for tooltips
  loading: boolean;
  pagination: { current: number; pageSize: number; total: number };
  onEdit: (user: User) => void;
  onDelete: (id: number) => void;
  onPageChange: (page: number, pageSize: number) => void;
}

export const UserTable: React.FC<UserTableProps> = ({
  users,
  rolesMap,
  loading,
  pagination,
  onEdit,
  onDelete,
  onPageChange,
}) => {

  const columns = [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
      width: 80,
      sorter: (a: User, b: User) => a.id - b.id,
    },
    {
      title: 'Username',
      dataIndex: 'username',
      key: 'username',
      sorter: (a: User, b: User) => a.username.localeCompare(b.username),
    },
    {
      title: 'Roles',
      dataIndex: 'roles',
      key: 'roles',
      render: (roles: string[]) => (
        <Space wrap size={[0, 8]}>
          {roles?.map(roleName => (
             <Tooltip key={roleName} title={rolesMap.get(roleName) || 'Role description not found'}>
                <Tag color="blue">{roleName}</Tag>
             </Tooltip>
          ))}
          {(!roles || roles.length === 0) && <Tag>No Roles</Tag>}
        </Space>
      ),
    },
    {
      title: 'Created At',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (date: string) => {
        const { displayText, fullText } = formatDate(date);
        return <span title={fullText}>{displayText}</span>;
      },
       sorter: (a: User, b: User) => new Date(a.createdAt || 0).getTime() - new Date(b.createdAt || 0).getTime(),
    },
     {
      title: 'Updated At',
      dataIndex: 'updatedAt',
      key: 'updatedAt',
      render: (date: string) => {
        const { displayText, fullText } = formatDate(date);
        return <span title={fullText}>{displayText}</span>;
      },
       sorter: (a: User, b: User) => new Date(a.updatedAt || 0).getTime() - new Date(b.updatedAt || 0).getTime(),
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 120,
      render: (_: any, record: User) => (
        <Space size="small">
          <Tooltip title="Edit User">
            <Button
              type="text"
              icon={<EditOutlined />}
              onClick={() => onEdit(record)}
              aria-label={`Edit user ${record.username}`}
            />
          </Tooltip>
          <Popconfirm
            title={`Delete user "${record.username}"?`}
            description="This action cannot be undone."
            onConfirm={() => onDelete(record.id)}
            okText="Delete"
            okType="danger"
            cancelText="Cancel"
          >
            <Tooltip title="Delete User">
              <Button
                type="text"
                danger
                icon={<DeleteOutlined />}
                aria-label={`Delete user ${record.username}`}
              />
            </Tooltip>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <Table
      rowKey="id"
      columns={columns}
      dataSource={users}
      loading={loading}
      pagination={{
        current: pagination.current,
        pageSize: pagination.pageSize,
        total: pagination.total,
        showSizeChanger: true,
        pageSizeOptions: ['10', '20', '50', '100'],
        showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} users`,
      }}
      onChange={(p) => onPageChange(p.current ?? 1, p.pageSize ?? DEFAULT_PAGE_SIZE)}
      scroll={{ x: 'max-content' }} // Enable horizontal scroll if needed
      size="small"
    />
  );
};

File: src/components/RoleManagement/components/PermissionAssignmentModal.tsx
// src/components/RoleManagement/components/PermissionAssignmentModal.tsx
import React, { useEffect, useState, useMemo } from 'react';
import { Modal, Form, Button, Spin, Alert, Checkbox, Row, Col, Tooltip, Input, Empty, Tag } from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { Role, Permission, UpdateRoleRequest } from '../../../api/types'; 

interface PermissionAssignmentModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (roleId: number, permissionCodes: string[]) => Promise<boolean>; // Takes role ID and codes, returns success
    role: Role | null; // The role being edited
    availablePermissions: Permission[];
    loading: boolean; // Loading state for the submission process
    loadingPermissions: boolean; // Loading state for fetching permissions
}

const { Search } = Input;

export const PermissionAssignmentModal: React.FC<PermissionAssignmentModalProps> = ({
    isOpen,
    onClose,
    onSubmit,
    role,
    availablePermissions,
    loading,
    loadingPermissions,
}) => {
    const [form] = Form.useForm();
    const [formError, setFormError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');

    const isCoreRole = role?.name === 'admin' || role?.name === 'classifier'; // Basic check for core roles

    // Set initial form values when the modal opens or the role changes
    useEffect(() => {
        if (isOpen && role) {
            setFormError(null);
            form.setFieldsValue({
                // Get the codes from the role's permissions array
                permissions: (role.permissions || []).map(p => p.code),
            });
        } else if (!isOpen) {
            form.resetFields(); // Reset form when closing
            setSearchTerm(''); // Reset search term
        }
    }, [isOpen, role, form]);

    // Filter permissions based on search term
    const filteredPermissions = useMemo(() => {
        if (!searchTerm) {
            return availablePermissions;
        }
        const lowerSearch = searchTerm.toLowerCase();
        return availablePermissions.filter(
            (perm) =>
                perm.code.toLowerCase().includes(lowerSearch) ||
                (perm.description && perm.description.toLowerCase().includes(lowerSearch))
        );
    }, [availablePermissions, searchTerm]);

    const handleFinish = async (values: { permissions: string[] }) => {
        if (!role) return;
        setFormError(null);
        const selectedPermissionCodes = values.permissions || [];

        try {
            const success = await onSubmit(role.id, selectedPermissionCodes);
            if (success) {
                onClose(); // Close modal on successful submission from parent
            } else {
                // Error handling might be done in the parent hook via message.error
                setFormError("Failed to update role permissions. Please try again.");
            }
        } catch (error) {
             console.error("Error submitting permissions:", error);
             setFormError(error instanceof Error ? error.message : "An unexpected error occurred.");
        }
    };

    // Group permissions by category (e.g., 'classify:', 'users:') for better organization
    const groupedPermissions = useMemo(() => {
        const groups: Record<string, Permission[]> = {};
        filteredPermissions.forEach(perm => {
            const category = perm.code.split(':')[0] || 'other';
            if (!groups[category]) {
                groups[category] = [];
            }
            groups[category].push(perm);
        });
         // Sort categories alphabetically, put 'other' last
         return Object.entries(groups).sort(([catA], [catB]) => {
            if (catA === 'other') return 1;
            if (catB === 'other') return -1;
            return catA.localeCompare(catB);
        });
    }, [filteredPermissions]);

    return (
        <Modal
            title={`Manage Permissions for Role: "${role?.name}"`}
            open={isOpen}
            onCancel={onClose}
            confirmLoading={loading}
            destroyOnClose
            width={800} // Wider modal for better permission layout
            footer={[
                <Button key="back" onClick={onClose} disabled={loading}>
                    Cancel
                </Button>,
                <Button key="submit" type="primary" loading={loading} onClick={() => form.submit()}>
                    Save Permissions
                </Button>,
            ]}
        >
            <Spin spinning={loadingPermissions || loading} tip={loadingPermissions ? "Loading permissions..." : "Saving..."}>
                {formError && <Alert message={formError} type="error" showIcon closable onClose={() => setFormError(null)} className="mb-4" />}

                {isCoreRole && (
                    <Alert
                        message="Core Role"
                        description={`Modifying permissions for the core "${role?.name}" role is restricted and may have unintended consequences.`}
                        type="warning"
                        showIcon
                        className="mb-4"
                    />
                )}

                <Input
                    placeholder="Search permissions by code or description..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    allowClear
                    className="mb-4"
                    prefix={<SearchOutlined />}
                />

                <Form
                    form={form}
                    layout="vertical"
                    onFinish={handleFinish}
                    name="permissionAssignmentForm"
                    style={{ maxHeight: '60vh', overflowY: 'auto', paddingRight: '10px' }} // Make the form scrollable
                >
                    <Form.Item name="permissions" noStyle>
                        <Checkbox.Group style={{ width: '100%' }}>
                            {groupedPermissions.length > 0 ? (
                                groupedPermissions.map(([category, perms]) => (
                                     <div key={category} className="mb-4 pb-2 border-b border-gray-200 last:border-b-0">
                                         <div className="mb-2 font-medium text-gray-600 capitalize">{category.replace(/_/g,' ')}</div>
                                        <Row gutter={[16, 8]}>
                                            {perms.sort((a, b) => a.code.localeCompare(b.code)).map(perm => (
                                                <Col xs={24} sm={12} key={perm.id}>
                                                    <Tooltip title={perm.description || perm.code} placement="right">
                                                        <Checkbox value={perm.code} disabled={loading || isCoreRole}>
                                                            <Tag color="blue">{perm.code}</Tag>
                                                        </Checkbox>
                                                    </Tooltip>
                                                </Col>
                                            ))}
                                        </Row>
                                    </div>
                                ))
                            ) : (
                                <Empty description={loadingPermissions ? "Loading permissions..." : "No permissions found matching your search."} />
                            )}
                        </Checkbox.Group>
                    </Form.Item>
                </Form>
            </Spin>
        </Modal>
    );
};

File: src/components/Layout/PageLayout.tsx
import React, { useState, useEffect } from 'react';
import { Outlet } from 'react-router-dom';
import LeftSidebar from '../Sidebar/LeftSidebar.component';

interface PageLayoutProps {
  ragEnabled: boolean;
  onLogout: () => void; // Add logout handler prop
}

const PageLayout: React.FC<PageLayoutProps> = ({ ragEnabled, onLogout }) => {
  const [sidebarExpanded, setSidebarExpanded] = useState(false);
  
  // Add debug logging for ragEnabled prop
  useEffect(() => {
    console.log('[PageLayout] ragEnabled prop value:', ragEnabled);
  }, [ragEnabled]);
  
  const handleMouseEnter = () => {
    setSidebarExpanded(true);
  };
  
  const handleMouseLeave = () => {
    setSidebarExpanded(false);
  };

  return (
    <div className="app-container">
      <header className="app-header">
        <h1 className="app-title">CDP Classifier</h1>
      </header>
      
      <div className="app-content">
        <div 
          className="sidebar-wrapper"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
        >
          <LeftSidebar 
            isSidebarCollapsed={!sidebarExpanded} 
            onLogout={onLogout} // Pass the logout handler down
            ragEnabled={ragEnabled}
          />
        </div>
        
        <main className={`main-content ${sidebarExpanded ? 'sidebar-expanded' : ''}`}>
          <Outlet />
        </main>
      </div>
    </div>
  );
};

export default PageLayout;

File: src/components/RagInfoTab/components/RagInfoTable.tsx
// src/components/RagInfoTab/components/RagInfoTable.tsx
import React from 'react';
import { RagInfoItem } from '../../../api/types'; // Adjust path
import { formatDate } from '../../../utils/dateFormat'; // Adjust path

interface RagInfoTableProps {
    items: RagInfoItem[];
    loading: boolean;
    onEdit: (item: RagInfoItem) => void;
    onDelete: (item: RagInfoItem) => void;
    canEdit: boolean; // Add permission props
    canDelete: boolean; // Add permission props
}

export const RagInfoTable: React.FC<RagInfoTableProps> = ({
    items,
    loading,
    onEdit,
    onDelete,
    canEdit,
    canDelete
}) => {
    if (loading && items.length === 0) {
        return <div className="text-center py-8 text-secondary-500">Loading...</div>;
    }

    if (!loading && items.length === 0) {
        return <div className="text-center py-8 text-secondary-500">No information found.</div>;
    }

    return (
        <div className="overflow-x-auto rounded-card border border-secondary-200">
            <table className="min-w-full divide-y divide-secondary-200">
                <thead className="bg-secondary-50">
                    <tr>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Key</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Description</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Created At</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Updated At</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Actions</th>
                    </tr>
                </thead>
                <tbody className="bg-white divide-y divide-secondary-200">
                    {items.map((item) => (
                        <tr key={item.id} className="hover:bg-secondary-50">
                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-secondary-900">{item.key}</td>
                            <td className="px-6 py-4 text-sm text-secondary-600 max-w-md truncate" title={item.description}>{item.description}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-500">
                                <span title={formatDate(item.createdAt).fullText}>
                                    {formatDate(item.createdAt).displayText}
                                </span>
                            </td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-500">
                                <span title={formatDate(item.updatedAt).fullText}>
                                    {formatDate(item.updatedAt).displayText}
                                </span>
                             </td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm space-x-2">
                                <button
                                    onClick={() => onEdit(item)}
                                    className={`btn py-1 px-2 text-xs ${
                                        canEdit 
                                        ? 'btn-secondary hover:bg-secondary-50' 
                                        : 'btn-disabled opacity-50 cursor-not-allowed'
                                    }`}
                                    aria-label={`Edit item ${item.key}`}
                                    disabled={loading || !canEdit}
                                    title={!canEdit ? "Permission denied" : `Edit item ${item.key}`}
                                > Edit </button>
                                <button
                                    onClick={() => onDelete(item)}
                                    className={`btn py-1 px-2 text-xs ${
                                        canDelete
                                        ? 'btn-secondary text-red-600 border-red-200 hover:bg-red-50'
                                        : 'btn-disabled opacity-50 cursor-not-allowed text-red-300'
                                    }`}
                                    aria-label={`Delete item ${item.key}`}
                                    disabled={loading || !canDelete}
                                    title={!canDelete ? "Permission denied" : `Delete item ${item.key}`}
                                > Delete </button>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

File: src/components/RoleManagement/RoleManagementTab.tsx
// src/components/RoleManagement/RoleManagementTab.tsx
import React, { useState, useCallback } from 'react';
import { Button, Space, message, Alert } from 'antd';
import { PlusOutlined } from '@ant-design/icons';
import { ApiClient, Role, CreateRoleRequest, UpdateRoleRequest, Permission } from '../../api/types';
import { useRoles } from './hooks/useRoles';
import { RoleTable } from './components/RoleTable';
import { RoleFormModal } from './components/RoleFormModal';

interface RoleManagementTabProps {
  apiClient: ApiClient;
}

const RoleManagementTab: React.FC<RoleManagementTabProps> = ({ apiClient }) => {
  const {
    roles,
    permissions,
    loading,
    loadingPermissions,
    error,
    // totalRoles, // Add if using pagination
    fetchRoles, // Use to refresh
    createRole,
    updateRole,
    deleteRole,
  } = useRoles(apiClient);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingRole, setEditingRole] = useState<Role | undefined>(undefined);

  const handleAddRole = () => {
    setEditingRole(undefined);
    setIsModalOpen(true);
  };

  const handleEditRole = (role: Role) => {
    // Ensure we have the permissions loaded for the role being edited
    // The hook should ideally fetch roles with their permissions,
    // but if not, you might need an extra fetch here or pass all permissions.
    console.log("Editing Role:", role);
    setEditingRole(role);
    setIsModalOpen(true);
  };

  const handleDeleteRole = async (id: number) => {
      // Confirmation is handled within the RoleTable component via Popconfirm
      await deleteRole(id);
      // Hook refreshes the list
  };

  const handleModalSubmit = async (data: CreateRoleRequest | UpdateRoleRequest): Promise<boolean> => {
    let success = false;
    if (editingRole) {
      success = !!await updateRole(editingRole.id, data as UpdateRoleRequest);
    } else {
      success = !!await createRole(data as CreateRoleRequest);
    }
    if (success) {
      setIsModalOpen(false);
      setEditingRole(undefined);
    }
    return success; // Let modal know if it succeeded
  };

  const handleModalClose = () => {
      setIsModalOpen(false);
      setEditingRole(undefined);
  }

  return (
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
      <div className="flex justify-end items-center">
        {/* Optional: Add Search/Filter for Roles */}
        <Button
          type="primary"
          icon={<PlusOutlined />}
          onClick={handleAddRole}
          disabled={loading || loadingPermissions} // Disable if loading roles or permissions
          loading={loading || loadingPermissions}
        >
          Add Role
        </Button>
      </div>

       {error && (
            <Alert message={`Error: ${error}`} type="error" showIcon className="mb-4" />
       )}

      <RoleTable
        roles={roles}
        loading={loading}
        onEdit={handleEditRole}
        onDelete={handleDeleteRole}
        // Pass pagination props if implemented
      />

      {/* Render modal only when needed */}
      {isModalOpen && (
          <RoleFormModal
            key={editingRole ? `edit-${editingRole.id}` : 'create'} // Force re-render on edit/create change
            isOpen={isModalOpen}
            onClose={handleModalClose}
            onSubmit={handleModalSubmit}
            initialData={editingRole}
            availablePermissions={permissions} // Pass all available permissions
            loading={loading} // Pass general loading state for submit button
            loadingPermissions={loadingPermissions} // Pass permission loading state
          />
      )}
    </Space>
  );
};

export default RoleManagementTab;

File: src/components/BatchTab/BatchSummary.tsx
import React from 'react';
import { BatchClassificationResult, ClassificationError, BatchItemResult } from '../../api/types';
import { saveAs } from 'file-saver';
import { formatDate } from '../../utils/dateFormat';
import { 
  isSuccessfulItem, 
  isFailedItem, 
  isPartialItem 
} from '../BatchJobsTab/utils/batchJobUtils';

interface BatchSummaryProps {
  result: BatchClassificationResult;
  originalData: {
    headers: string[];
    rows: string[][];
  };
}

// Helper function to get error message from either string or ClassificationError
const getErrorMessage = (error: string | ClassificationError | undefined): string => {
  if (!error) return '';
  if (typeof error === 'string') return error;
  return error.message || 'Unknown error';
};

// Function to split multi-keys into array (separated by |)
const splitMultiKey = (key: string = ''): string[] => {
  if (!key) return [''];
  return key.split('|').map(k => k.trim());
};

// Determines the maximum number of key parts across all items
const getMaxKeyParts = (results: BatchItemResult[]): number => {
  let maxParts = 1; // Default to at least one key column
  
  for (const item of results) {
    if (item.key) {
      const keyParts = splitMultiKey(item.key);
      maxParts = Math.max(maxParts, keyParts.length);
    }
  }
  
  return maxParts;
};

const BatchSummary: React.FC<BatchSummaryProps> = ({ result, originalData }) => {
  const results = result.Results || result.results || [];
  const successCount = results.filter(r => isSuccessfulItem(r)).length;
  const partialCount = results.filter(r => isPartialItem(r)).length;
  const failureCount = results.filter(r => isFailedItem(r)).length;

  // Check if any result has a key field
  const hasKeys = results.some(r => r.key);
  // Calculate maximum number of key parts
  const maxKeyParts = hasKeys ? getMaxKeyParts(results) : 0;

  const downloadResults = () => {
    try {
      // Get level codes from the first successful result
      const firstSuccess = results.find(r => r.result);
      
      if (!firstSuccess || !firstSuccess.result) {
        alert('No successful results to download');
        return;
      }
      
      // Verify the levels object exists
      const levels = firstSuccess.result.levels || {};
      console.log('Levels found:', Object.keys(levels).join(', '));
      
      if (Object.keys(levels).length === 0) {
        alert('Warning: No classification levels found in the results');
      }
      
      // Define the level order (if available)
      const levelOrder: Record<string, number> = {
        'segment': 1,
        'family': 2,
        'class': 3,
        'commodity': 4
      };
      
      // Get all possible level codes
      const levelCodes = Object.keys(levels).sort((a, b) =>
        (levelOrder[a] ?? 999) - (levelOrder[b] ?? 999)
      );
      
      // Create a clean CSV with the right number of columns for each row
      
      // Step 1: Analyze original data to understand the structure
      console.log('Original headers length:', originalData.headers.length);
      
      // Step 2: Create CSV content manually to ensure perfect alignment
      // Start with building the header row
      let csvContent = '';
      
      // Add Key columns based on the maximum number of key parts found
      if (hasKeys) {
        for (let i = 0; i < maxKeyParts; i++) {
          csvContent += `Key_${i+1},`;
        }
      }
      
      // Add original headers
      for (let i = 0; i < originalData.headers.length; i++) {
        const header = originalData.headers[i];
        const escapedHeader = escapeCsvValue(header);
        csvContent += escapedHeader + ',';
      }
      
      // Add classification status
      csvContent += 'Classification_Status,';

      // Add RAG context column if any result uses RAG
      const useRagColumn = results.some(r => r.result?.ragContextUsed);
      if (useRagColumn) {
        csvContent += 'RAG_Context,';
      }
      
      // Add level headers
      for (const level of levelCodes) {
        csvContent += `${level}_Code,${level}_Name,`;
      }
      
      // Add error column and end the header row
      csvContent += 'Error\n';
      
      // Add data rows
      for (let rowIdx = 0; rowIdx < results.length; rowIdx++) {
        const res = results[rowIdx];
        const originalRow = rowIdx < originalData.rows.length 
          ? originalData.rows[rowIdx] 
          : Array(originalData.headers.length).fill('');
          
        // Add key fields if present - split by | and add to separate columns
        if (hasKeys) {
          const keyParts = splitMultiKey(res.key || '');
          // Fill in key columns - add empty strings for missing parts
          for (let i = 0; i < maxKeyParts; i++) {
            csvContent += escapeCsvValue(keyParts[i] || '') + ',';
          }
        }
        
        // Add original data cells
        for (let colIdx = 0; colIdx < originalData.headers.length; colIdx++) {
          const cellValue = colIdx < originalRow.length ? originalRow[colIdx] : '';
          csvContent += escapeCsvValue(cellValue) + ',';
        }
        
        // Add status using consistent logic
        let status = 'Failed';
        if (isSuccessfulItem(res)) {
          status = 'Success';
        } else if (isPartialItem(res)) {
          status = 'Partial';
        }
        csvContent += escapeCsvValue(status) + ',';

        // Add RAG context if applicable
        if (useRagColumn) {
          csvContent += escapeCsvValue(res.result?.ragContext || '') + ',';
        }
        
        // Add level values
        for (const level of levelCodes) {
          const levelData = res.result?.levels?.[level];
          csvContent += escapeCsvValue(levelData?.code || '') + ',';
          csvContent += escapeCsvValue(levelData?.name || '') + ',';
        }
        
        // Add error message, including both explicit errors and level-specific error cases
        let errorMessage = '';
        if (res.error) {
          errorMessage = getErrorMessage(res.error);
        } else if (res.result?.error) {
          errorMessage = getErrorMessage(res.result.error);
        } else if (!res.result) {
          errorMessage = 'No classification result received';
        } else if (Object.keys(res.result.levels || {}).length === 0) {
          errorMessage = 'No category levels found';
        } else if (isPartialItem(res)) {
          errorMessage = 'Partial classification, some levels missing';
        }
        csvContent += escapeCsvValue(errorMessage);
        
        // End the row
        if (rowIdx < results.length - 1) {
          csvContent += '\n';
        }
      }
      
      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      
      // Create and download the file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
      saveAs(blob, `batch_classification_${timestamp}.csv`);
      
      console.log('Download initiated with file size:', blob.size, 'bytes');
      console.log('Multi-key columns used:', maxKeyParts);
    } catch (error) {
      console.error('Error generating CSV:', error);
      alert(`Error generating download: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };
  
  // Helper function to escape CSV values
  const escapeCsvValue = (value: any): string => {
    if (value === null || value === undefined) return '';
    
    const stringValue = String(value);
    const needsQuoting = stringValue.includes(',') || 
                        stringValue.includes('"') || 
                        stringValue.includes('\n') ||
                        stringValue.includes('\r');
    
    if (!needsQuoting) return stringValue;
    
    // Double up quotes and wrap in quotes
    return `"${stringValue.replace(/"/g, '""')}"`;
  };

  return (
    <div className="rounded-lg border border-secondary-200 bg-white p-6 shadow-sm">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-medium text-secondary-900">Processing Complete</h3>
      
        <span 
          className="text-sm text-secondary-600" 
          title={formatDate(result.timestamp).fullText}
        >
          {formatDate(result.timestamp).displayText}
        </span>
      </div>
      <div className="grid grid-cols-3 gap-4 mb-6">
        <div className="rounded-md bg-green-50 p-4">
          <div className="text-green-800 text-sm font-medium">Successful</div>
          <div className="text-2xl font-bold text-green-600">{successCount}</div>
        </div>
        <div className="rounded-md bg-yellow-50 p-4">
          <div className="text-yellow-800 text-sm font-medium">Partial</div>
          <div className="text-2xl font-bold text-yellow-600">{partialCount}</div>
        </div>
        <div className="rounded-md bg-red-50 p-4">
          <div className="text-red-800 text-sm font-medium">Failed</div>
          <div className="text-2xl font-bold text-red-600">{failureCount}</div>
        </div>
      </div>

      <button
        onClick={downloadResults}
        className="w-full py-3 px-4 rounded-card text-white font-medium transition-colors bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
      >
        Download Results
      </button>

      {(failureCount > 0 || partialCount > 0) && (
        <div className="mt-4">
          <h4 className="text-sm font-medium text-secondary-900 mb-2">Items with Issues:</h4>
          <div className="max-h-40 overflow-y-auto">
            {results.map((res, idx) => {
              // Show failed and partial items
              if (!isFailedItem(res) && !isPartialItem(res)) return null;

              const isProblem = isFailedItem(res);
              const bgColor = isProblem ? 'bg-red-50' : 'bg-yellow-50';
              const textColor = isProblem ? 'text-red-600' : 'text-yellow-700';
              const statusText = isProblem ? 'Failed' : 'Partial';

              return (
                <div key={idx} className={`text-sm ${textColor} mb-2 p-2 ${bgColor} rounded-md`}>
                  <div className="font-medium flex justify-between">
                    <span>Row {idx + 1} - {statusText}</span>
                    {res.key && <span className="text-xs bg-amber-100 text-amber-800 px-2 py-1 rounded">Key: {res.key}</span>}
                  </div>
                  <div className="text-xs mt-1">
                    <span className="font-medium">Description:</span> {res.description || `Item ${idx + 1}`}
                  </div>
                  <div className="text-xs mt-1">
                    <span className="font-medium">Issue:</span>{' '}
                    {res.error
                      ? getErrorMessage(res.error)
                      : res.result?.error
                      ? getErrorMessage(res.result.error)
                      : !res.result
                      ? 'Invalid classification result'
                      : isPartialItem(res)
                      ? 'Partial classification - some levels may be missing or have errors'
                      : 'Unknown issue'}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
};

export default BatchSummary;

File: src/components/Sidebar/left-sidebar.css
/* Make sure this is in your left-sidebar.css */
.left-sidebar-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 70px;
    border-radius: 0;
    border-right: 1px solid #e8e8e8;
    background: white;
    transition: width 0.3s cubic-bezier(0.2, 0, 0, 1) 0s !important;
    overflow: hidden;
    height: 100%;
  }
  
  .sidebar-open {
    width: 180px !important;
  }

  /* --- Antd Menu Item Styling --- */
  .left-sidebar-menu .ant-menu-item,
  .left-sidebar-menu .ant-menu-submenu-title {
    display: flex !important;
    align-items: center !important;
    /* Use min-height instead of fixed height for flexibility, adjust value as needed */
    min-height: 40px !important;
    height: auto !important; /* Allow height to adjust naturally if content wraps, used with min-height */
    padding-top: 8px !important;
    padding-bottom: 8px !important;
    line-height: normal !important;
    padding-left: 20px !important;
  }
  
  /* --- Icon Styling (Ensure Consistent Size) --- */
  /* Target the container AND the SVG for robustness */
  .left-sidebar-menu .ant-menu-item-icon,
  .left-sidebar-menu .ant-menu-submenu-title .ant-menu-item-icon {
    /* Ensure container doesn't shrink and centers icon */
    flex-shrink: 0;
    display: inline-flex !important; /* Use inline-flex for better alignment control */
    align-items: center;
    justify-content: center;
    /* Define container size slightly larger than icon if needed */
    /* width: 24px !important; */
    /* height: 24px !important; */
    line-height: 1 !important; /* Crucial */
    margin-right: 10px !important; /* Ensure consistent space */
  }
  
  .left-sidebar-menu .ant-menu-item-icon svg, /* Target SVG directly */
  .left-sidebar-menu .ant-menu-submenu-title .ant-menu-item-icon svg { /* Target SVG in submenu title */
    width: 20px !important;  /* <<< SET YOUR DESIRED ICON WIDTH */
    height: 20px !important; /* <<< SET YOUR DESIRED ICON HEIGHT */
    /* font-size: 20px !important; */ /* Font-size less reliable for SVG */
    display: block !important; /* Helps prevent extra space */
    flex-shrink: 0; /* Prevent shrinking */
    transition: none !important; /* No size transitions */
    vertical-align: middle; /* Align vertically */
  }

  /* Style Antd Label Container (.ant-menu-title-content contains our LeftSidebarItem output) */
  .left-sidebar-menu .ant-menu-item-icon + .ant-menu-title-content {
    /* margin-left: 10px !important; */ /* Space now handled by icon container's margin-right */
    flex-grow: 1;
    overflow: hidden;
    display: flex;
    align-items: center;
    line-height: normal !important; /* Ensure consistency */
    vertical-align: middle; /* Align vertically */
  }

  /* --- Label Styling (Focus on visibility/opacity) --- */
  .left-panel-label {
    display: inline-block; /* Keep it in the flow */
    white-space: nowrap;
    vertical-align: middle; /* Align with icon */
    /* Control visibility via opacity and visibility */
    visibility: hidden;
    opacity: 0;
    /* Adjust transition for smoothness */
    transition: opacity 0.2s 0.1s ease-in-out !important; /* Added slight delay back */
  }

  .sidebar-open .left-panel-label {
    visibility: visible;
    opacity: 1;
    /* transition-delay: 0.1s !important; */ /* Delay now in main transition */
  }

  /* --- Bottom Menu Specific --- */
  .left-sidebar-menu.bottom-menu.ant-menu-light.ant-menu-root.ant-menu-inline {
    border-top: none !important;
    box-shadow: none !important;
  }
  .left-sidebar-menu.bottom-menu .ant-menu-item:first-child {
     border-top: none !important;
     margin-top: 0 !important;
  }
  .left-sidebar-menu.bottom-menu .ant-menu-item {
      border-top: none !important;
  }
  .left-sidebar-container > .ant-row:last-child {
       border-top: none !important;
  }

  .custom-menu.ant-menu-root.ant-menu-inline {
    background: white;
    border: 0px;
  
    .ant-menu-item::after {
      left: 0;
      right: unset;
    }
  
    .ant-menu-item-group-title {
      font-size: 12px;
      padding: 12px 16px;
      color: grey;
    }
  
    .ant-menu-item-icon + span {
      margin-left: 8px;
    }
  
    .ant-menu-item {
      height: 30px;
      line-height: 30px;
      margin-top: 2px;
      padding: 0 16px !important;
    }
  
    .ant-menu-item:hover,
    .ant-menu-item-selected {
      .side-panel-icons {
        color: black;
      }
    }
  
    .ant-menu-item-selected {
      .ant-menu-title-content {
        font-weight: 600;
  
        .ant-badge {
          color: black;
        }
      }
    }
  
    .ant-menu-item-active {
      .ant-menu-title-content {
        .ant-badge {
          color: black;
        }
      }
    }
  
    .ant-menu-item:not(:last-child) {
      margin-bottom: 0px;
    }
  
    .ant-menu:not(.ant-menu-horizontal) .ant-menu-item-selected {
      border-right: 1px solid transparent;
    }
  }
  
  .custom-menu-with-description {
    &.custom-menu.ant-menu-root.ant-menu-inline .ant-menu-item {
      height: 50px;
      margin-top: 4px;
    }
  
    &.custom-menu.ant-menu-root.ant-menu-inline
      .ant-menu-item-selected
      .ant-menu-title-content {
      font-weight: 400;
    }
  }

  /* Add consistent transitions for all menu items */
  .left-sidebar-menu .ant-menu-item,
  .left-sidebar-menu .ant-menu-item-only-child,
  .left-sidebar-menu .ant-menu-item-group-title,
  .left-sidebar-menu .ant-menu-item-group-list,
  .left-sidebar-menu .ant-menu-sub,
  .left-sidebar-menu .ant-menu-inline,
  .left-sidebar-menu .ant-menu-title-content,
  .left-sidebar-menu .ant-menu-submenu,
  .left-sidebar-menu .ant-menu-submenu-inline,
  .left-sidebar-menu .ant-menu-submenu-title {
    transition: all 0.3s cubic-bezier(0.2, 0, 0, 1) 0s !important;
  }

  /* Ensure consistent hover behavior */
  .left-sidebar-menu .ant-menu-item:hover,
  .left-sidebar-menu .ant-menu-submenu:hover {
    background-color: rgba(0, 0, 0, 0.025) !important;
  }

  /* Fix the hover-out behavior */
  .left-sidebar-container:not(.sidebar-open) .ant-menu-submenu-inline:hover,
  .left-sidebar-container:not(.sidebar-open) .ant-menu-item:hover {
    width: auto !important;
    opacity: 1 !important;
    visibility: visible !important;
  }

  /* Ensure submenu items collapse instead of disappearing */
  .left-sidebar-container:not(.sidebar-open) .ant-menu-submenu-arrow {
    opacity: 0 !important;
    transition: all 0.3s cubic-bezier(0.2, 0, 0, 1) 0s !important;
  }

  /* For submenu when sidebar IS open */
  .sidebar-open .ant-menu-submenu-inline {
    visibility: visible !important;
    opacity: 1 !important;
    width: 180px !important; /* Maintain consistent width when expanded */
  }

  /* Make sure submenu arrows are visible when sidebar is open */
  .sidebar-open .ant-menu-submenu-arrow {
    visibility: visible !important;
    opacity: 1 !important;
    display: inline-block !important;
  }

  /* For submenu when sidebar is NOT open */
  .left-sidebar-container:not(.sidebar-open) .ant-menu-submenu-inline {
    visibility: hidden !important;
    opacity: 1 !important; /* Change to 0 to truly hide */
    width: 90px !important;
  }

  /* For menu title content when sidebar is open */
  .sidebar-open .ant-menu-title-content {
    visibility: visible !important;
    opacity: 1 !important;
    display: inline-block !important;
  }



File: src/components/Sidebar/LeftSidebar.interface.ts
import React from 'react';

/**
 * Type definition for icon components, explicitly including both SVG components and Ant Design icons
 */
export type SvgComponent = 
  | React.ComponentType<React.SVGProps<SVGSVGElement>> 
  | React.ForwardRefExoticComponent<any>;

/**
 * Interface for sidebar menu items
 */
export interface LeftSidebarItem {
  key: string;
  isBeta?: boolean;
  title: string;
  redirect_url?: string;
  icon: SvgComponent;
  dataTestId: string;
  disableExpandIcon?: boolean;
  children?: Array<LeftSidebarItem>;
  onClick?: () => void;
  requiredPermission?: string; // Permission code required to see this item
}

/**
 * Interface for the LeftSidebar component props
 */
export interface LeftSidebarProps {
  isSidebarCollapsed?: boolean;
  onLogout?: () => void;
  ragEnabled?: boolean; // Added for conditional RAG items
}

File: src/components/RagInfoTab/components/RagInfoFilters.tsx
// src/components/RagInfoTab/components/RagInfoFilters.tsx
import React from 'react';

interface RagInfoFiltersProps {
    searchTerm: string;
    onSearchChange: (term: string) => void;
    loading: boolean;
}

export const RagInfoFilters: React.FC<RagInfoFiltersProps> = ({
    searchTerm,
    onSearchChange,
    loading
}) => {
    return (
        <div className="mb-4">
            <label htmlFor="ragSearch" className="label">
                Search Key / Description
            </label>
            <input
                type="text"
                id="ragSearch"
                placeholder="Search..."
                className="input" // Use global style from index.css
                value={searchTerm}
                onChange={(e) => onSearchChange(e.target.value)}
                disabled={loading}
            />
        </div>
    );
};

File: src/components/BatchTab/BatchProgress.tsx
import React from 'react';

interface BatchProgressProps {
  current: number;
  total: number;
  currentKey?: string; // Add new prop for the current key being processed
}

const BatchProgress: React.FC<BatchProgressProps> = ({ current, total, currentKey }) => {
  // Ensure we don't divide by zero and get a valid percentage
  const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
  
  // Determine if processing is truly complete
  const isComplete = total > 0 && current === total;
  
  // Check if processing has actually started
  const hasStarted = current > 0;

  return (
    <div className="w-96">
      {/* Progress text */}
      <div className="flex justify-between mb-1">
        <span className="text-sm font-medium text-secondary-700">
          {hasStarted ? `Processing... (${current}/${total} items)` : `Initializing... (0/${total} items)`}
        </span>
        <span className="text-sm font-medium text-secondary-700">
          {percentage}%
        </span>
      </div>

      {/* Progress bar */}
      <div className="w-full bg-secondary-200 rounded-full h-2.5">
        <div
          className="bg-primary-600 h-2.5 rounded-full transition-all duration-500 ease-in-out"
          style={{ width: `${percentage}%` }}
        />
      </div>

      {/* Current key being processed - only show if key is provided */}
      {currentKey && hasStarted && !isComplete && (
        <div className="mt-1 text-xs text-secondary-600">
          Current key: <span className="font-medium">{currentKey}</span>
        </div>
      )}

      {/* Status message - only show when truly complete */}
      {isComplete && (
        <div className="mt-1 text-xs text-secondary-500">
          <span className="text-green-600">Processing complete</span>
        </div>
      )}
    </div>
  );
};

export default BatchProgress;

File: src/components/RagInfoTab/index.ts
// src/components/RagInfoTab/index.ts
export { RagInfoTab } from './RagInfoTab';

File: src/components/Layout/Breadcrumb.tsx
import React, { useMemo } from 'react';
import { Breadcrumb as AntBreadcrumb } from 'antd';
import { useLocation, Link } from 'react-router-dom';

/**
 * Map of paths to their display names
 */
const PATH_LABELS: Record<string, string> = {
  '/': 'Home',
  '/test': 'Test',
  '/batch': 'Batch',
  '/history': 'History',
  '/settings': 'Settings'
};

/**
 * Breadcrumb component that shows the current location in the application
 */
const Breadcrumb: React.FC = () => {
  const location = useLocation();

  const breadcrumbItems = useMemo(() => {
    // Split the path into segments
    const pathSegments = location.pathname.split('/').filter(Boolean);
    
    // Start with home
    const items = [{
      title: <Link to="/">Home</Link>,
    }];

    // Build up the path progressively
    let currentPath = '';
    pathSegments.forEach(segment => {
      currentPath += `/${segment}`;
      const label = PATH_LABELS[currentPath] || segment.charAt(0).toUpperCase() + segment.slice(1);
      
      items.push({
        title: currentPath === location.pathname ? 
          <span>{label}</span> : 
          <Link to={currentPath}>{label}</Link>,
      });
    });

    return items;
  }, [location.pathname]);

  return (
    <AntBreadcrumb 
      className="px-4 py-2 bg-white shadow-sm"
      items={breadcrumbItems}
    />
  );
};

export default Breadcrumb;

File: src/pages/TestPage.tsx
import React from 'react'; // Remove unused useState and related hooks if not needed elsewhere
import { ClassificationForm } from '../components/ClassificationForm';
import { ApiClient } from '../api/types';
// Remove useAuth if checkPermission is no longer needed here
// import { useAuth } from '../context/AuthContext';

interface TestPageProps {
  apiClient: ApiClient;
}

const TestPage: React.FC<TestPageProps> = ({ apiClient }) => {
  // Remove state and handlers related to the deleted button
  // const { checkPermission } = useAuth();
  // const [isLoading, setIsLoading] = useState(false);
  // const [description, setDescription] = useState('');

  // const handleSubmit = () => { ... }; // This handler is no longer needed

  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Test Classification</h1>
        <p className="text-secondary-600">
          Use this tool to test classification of individual items
        </p>
      </div>

      {/* The ClassificationForm component already contains the necessary inputs and its own submit button */}
      <ClassificationForm apiClient={apiClient} />

      {/* The redundant button has been removed from here */}

    </div>
  );
};

export default TestPage;

File: src/components/BatchTab/PreviewTable.tsx
import React from 'react';
import { PreviewData, ColumnConfig } from './types';
import { BatchItemResult, ClassificationError } from '../../api/types';

interface PreviewTableProps {
  data: PreviewData;
  columnConfig: ColumnConfig | null;
  batchResults?: BatchItemResult[];
  isProcessing?: boolean;
}

const PreviewTable: React.FC<PreviewTableProps> = ({ data, columnConfig, batchResults, isProcessing }) => {
  const { headers, rows } = data;
  const previewRows = rows.slice(0, 5); // Show only first 5 rows

  // Generate keys for preview display
  const getGeneratedKey = (row: string[]): string => {
    if (!columnConfig || !columnConfig.keyColumns || columnConfig.keyColumns.length === 0) {
      return '';
    }
    
    const keyParts = columnConfig.keyColumns.map(keyCol => {
      const keyIndex = headers.indexOf(keyCol);
      return keyIndex >= 0 ? row[keyIndex] : '';
    }).filter(Boolean); // Remove empty values
    
    return keyParts.join('|'); // Join with pipe delimiter for multiple key parts
  };

  // Helper function to get error message from either string or ClassificationError
  const getErrorMessage = (error: string | ClassificationError | undefined): string => {
    if (!error) return '';
    if (typeof error === 'string') return error;
    return error.message || 'Unknown error';
  };

  const isHighlightedColumn = (header: string): boolean => {
    if (!columnConfig) return false;
    return (
      header === columnConfig.sourceColumn ||
      header === columnConfig.contextColumn ||
      columnConfig.keyColumns?.includes(header) || // Include key columns in highlighting
      columnConfig.resultColumns?.some(col =>
        col.codeColumn === header || col.nameColumn === header
      )
    );
  };

  const getColumnType = (header: string): string | null => {
    if (!columnConfig) return null;
    if (header === columnConfig.sourceColumn) return 'Source';
    if (header === columnConfig.contextColumn) return 'Context';
    if (columnConfig.keyColumns?.includes(header)) return 'Key'; // Identify key columns
    
    const resultCol = columnConfig.resultColumns?.find(
      col => col.codeColumn === header || col.nameColumn === header
    );
    if (resultCol) {
      return header === resultCol.codeColumn
        ? `${resultCol.levelName} Code`
        : `${resultCol.levelName} Name`;
    }
    
    return null;
  };

  const getCellClassName = (header: string): string => {
    const baseClass = 'px-4 py-2 whitespace-nowrap text-sm';
    
    if (!columnConfig) return `${baseClass} text-secondary-500`;
    
    // Special styling for key columns
    if (columnConfig.keyColumns?.includes(header)) {
      return `${baseClass} bg-amber-50 text-secondary-900 font-medium`;
    }
    
    if (isHighlightedColumn(header)) {
      return `${baseClass} bg-primary-50 text-secondary-900`;
    }
    
    return `${baseClass} text-secondary-500`;
  };

  const getHeaderClassName = (header: string): string => {
    const baseClass = 'px-4 py-2 text-left text-xs font-medium tracking-wider';
    
    if (!columnConfig) return `${baseClass} bg-secondary-50 text-secondary-500`;
    
    // Special styling for key columns
    if (columnConfig.keyColumns?.includes(header)) {
      return `${baseClass} bg-amber-50 text-amber-700`;
    }
    
    if (isHighlightedColumn(header)) {
      return `${baseClass} bg-primary-50 text-primary-700`;
    }
    
    return `${baseClass} bg-secondary-50 text-secondary-500`;
  };

  const getProcessingStatus = (index: number) => {
    if (!batchResults) return null;
    
    const result = batchResults[index];
    if (!result) return (
      isProcessing && (
      <div className="flex items-center space-x-2 text-secondary-600">
        <svg className="animate-pulse h-4 w-4" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none"/>
        </svg>
        <span className="ml-2">Waiting...</span>
      </div>
      )
    );

    // Check if the result is actually successful (has valid levels)
    const isSuccess = result.result?.levels && 
      Object.values(result.result.levels).some(level => level.code && level.name);

    // If it has a result but no valid levels, it's a failure
    if (result.result && !isSuccess) return (
      <div className="flex items-center space-x-2 text-red-600">
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <span className="ml-2">Error: Invalid classification</span>
      </div>
    );

    if (result.error) return (
      <div className="flex items-center space-x-2 text-red-600">
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <div className="flex flex-col">
          <span className="ml-2">Error</span>
          {result.error && (
            <span 
              className="ml-2 text-xs text-red-500 max-w-sm truncate" 
              title={getErrorMessage(result.error)}
            >
              {getErrorMessage(result.error)}
            </span>
          )}
        </div>
      </div>
    );

    if (isSuccess) return (
      <div className="flex items-center space-x-2 text-green-600">
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
        </svg>
        <span className="ml-2">Completed</span>
      </div>
    );

    return (
      isProcessing && (
      <div className="flex items-center space-x-2 text-primary-600">
        <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span className="ml-2">Processing...</span>
      </div>
      )
    );
  };

  return (
    <div className="overflow-x-auto rounded-lg border border-secondary-200">
      <table className="min-w-full divide-y divide-secondary-200">
        <thead>
          <tr>
            {/* Processing Status column */}
            <th className="w-48 px-4 py-2 bg-secondary-50 text-left text-xs font-medium text-secondary-500 tracking-wider">Status</th>
            
            {/* Generated Key column - only show if key columns are selected */}
            {columnConfig?.keyColumns && columnConfig.keyColumns.length > 0 && (
              <th className="w-64 px-4 py-2 bg-amber-50 text-left text-xs font-medium text-amber-700 tracking-wider">
                <div className="flex flex-col">
                  <span>Generated Key</span>
                  <span className="mt-1 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800">
                    Composite Key
                  </span>
                </div>
              </th>
            )}
            
            {headers.map((header: string, index: number) => (
              <th
                key={index}
                className={getHeaderClassName(header)}
              >
                <div className="flex flex-col">
                  <span>{header}</span>
                  {isHighlightedColumn(header) && (
                    <span className="mt-1 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-primary-100 text-primary-800">
                      {getColumnType(header)}
                    </span>
                  )}
                </div>
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-secondary-200">
          {previewRows.map((row: string[], rowIndex: number) => (
            <tr key={rowIndex}>
              {/* Status cell */}
              <td className="w-48 px-4 py-2 whitespace-nowrap border-r border-secondary-200">
                {getProcessingStatus(rowIndex)}
              </td>
              
              {/* Generated Key cell - only show if key columns are selected */}
              {columnConfig?.keyColumns && columnConfig.keyColumns.length > 0 && (
                <td className="w-64 px-4 py-2 whitespace-nowrap border-r border-secondary-200 bg-amber-50 font-medium">
                  {getGeneratedKey(row)}
                </td>
              )}
              
              {row.map((cell: string, cellIndex: number) => (
                <td
                  key={cellIndex}
                  className={getCellClassName(headers[cellIndex])}
                >
                  {cell}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>

      {previewRows.length === 0 ? (
        <div className="text-center py-4 text-secondary-500">
          No preview data available
        </div>
      ) : (
        <div className="bg-secondary-50 px-4 py-2 text-sm text-secondary-500">
          Showing first {previewRows.length} of {rows.length} rows
        </div>
      )}
    </div>
  );
};

export default PreviewTable;

File: src/components/RagInfo/RagInfoComponent.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Modal, Form, Input, message, Space } from 'antd';
import { useAuth } from '../../context/AuthContext';
import { EditOutlined, DeleteOutlined, EyeOutlined, PlusOutlined } from '@ant-design/icons';
import { 
  ApiClient, 
  CreateRagInfoRequest,
  UpdateRagInfoRequest,
  RagInfoRequestParams
} from '../../api/types';

// Define the types needed for RAG functionality
export interface RagInfoComponentProps {
  apiClient: ApiClient;
}

// Updated RagInfoData interface to match API types while adding UI-specific fields
interface RagInfoData {
  id: string;
  key: string; 
  description: string;
  createdAt: string;
  updatedAt: string;
}

interface RagFormData {
  key: string;
  description: string;
}

export const RagInfoComponent: React.FC<RagInfoComponentProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  // Component state
  const [ragInfoItems, setRagInfoItems] = useState<RagInfoData[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showViewModal, setShowViewModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState<RagInfoData | null>(null);
  const [form] = Form.useForm();
  
  // Load RAG info items when component mounts
  useEffect(() => {
    loadRagInfo();
  }, []);
  
  const loadRagInfo = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Use the correct API method for listing all items
      const params: RagInfoRequestParams = { limit: 100 };
      const response = await apiClient.getRagInfoList(params);
      
      // Map the API response directly to our component's data structure
      const transformedItems = response.items.map(item => ({
        ...item
      }));
      
      setRagInfoItems(transformedItems || []);
    } catch (err) {
      console.error('Failed to load RAG information:', err);
      setError('Failed to load information items');
    } finally {
      setLoading(false);
    }
  };
  
  const handleCreateInfo = async (data: RagFormData) => {
    // Check if user has permission to create RAG info
    if (!checkPermission('rag:create')) {
      setError('You do not have permission to create RAG information');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: CreateRagInfoRequest = {
        key: data.key,
        description: data.description
      };
      
      await apiClient.createRagInfo(request);
      message.success('RAG information created successfully');
      setShowCreateModal(false);
      form.resetFields();
      loadRagInfo(); // Refresh the list
    } catch (err) {
      console.error('Failed to create RAG information:', err);
      setError('Failed to create information item');
    } finally {
      setLoading(false);
    }
  };
  
  const handleUpdateInfo = async (data: RagFormData) => {
    // Check if user has permission to update RAG info
    if (!checkPermission('rag:update')) {
      setError('You do not have permission to update RAG information');
      return;
    }
    
    if (!selectedItem) {
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: UpdateRagInfoRequest = {
        key: data.key,
        description: data.description
      };
      
      await apiClient.updateRagInfo(selectedItem.id, request);
      message.success('RAG information updated successfully');
      setShowEditModal(false);
      form.resetFields();
      loadRagInfo(); // Refresh the list
    } catch (err) {
      console.error('Failed to update RAG information:', err);
      setError('Failed to update information item');
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeleteInfo = async (id: string) => {
    // Check if user has permission to delete RAG info
    if (!checkPermission('rag:delete')) {
      setError('You do not have permission to delete RAG information');
      return;
    }
    
    setLoading(true);
    
    try {
      await apiClient.deleteRagInfo(id);
      message.success('RAG information deleted successfully');
      loadRagInfo(); // Refresh the list
    } catch (err) {
      console.error('Failed to delete RAG information:', err);
      setError('Failed to delete information item');
    } finally {
      setLoading(false);
    }
  };
  
  const showDeleteConfirm = (id: string) => {
    Modal.confirm({
      title: 'Are you sure you want to delete this item?',
      content: 'This action cannot be undone.',
      okText: 'Yes',
      okType: 'danger',
      cancelText: 'No',
      onOk() {
        handleDeleteInfo(id);
      },
    });
  };
  
  const openCreateModal = () => {
    form.resetFields();
    setShowCreateModal(true);
  };
  
  const openEditModal = (item: RagInfoData) => {
    setSelectedItem(item);
    form.setFieldsValue({
      key: item.key,
      description: item.description
    });
    setShowEditModal(true);
  };
  
  const openViewModal = (item: RagInfoData) => {
    setSelectedItem(item);
    setShowViewModal(true);
  };
  
  const columns = [
    {
      title: 'Key',
      dataIndex: 'key',
      key: 'key',
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
    },
    {
      title: 'Created At',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: 'Updated At',
      dataIndex: 'updatedAt',
      key: 'updatedAt',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: RagInfoData) => (
        <Space size="small">
          <Button 
            type="text" 
            icon={<EyeOutlined />} 
            onClick={() => openViewModal(record)}
          />
          {checkPermission('rag:update') && (
            <Button 
              type="text" 
              icon={<EditOutlined />} 
              onClick={() => openEditModal(record)}
            />
          )}
          {checkPermission('rag:delete') && (
            <Button 
              type="text" 
              danger 
              icon={<DeleteOutlined />} 
              onClick={() => showDeleteConfirm(record.id)}
            />
          )}
        </Space>
      ),
    },
  ];
  
  return (
    <div className="rag-info-container">
      {error && <div className="error-message">{error}</div>}
      
      <div className="actions-container" style={{ marginBottom: '16px' }}>
        {checkPermission('rag:create') && (
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={openCreateModal}
          >
            Add New Information
          </Button>
        )}
      </div>
      
      <Table
        dataSource={ragInfoItems}
        columns={columns}
        rowKey="id"
        loading={loading}
        pagination={{ pageSize: 10 }}
      />
      
      {/* Create Modal */}
      <Modal
        title="Add New RAG Information"
        open={showCreateModal}
        onCancel={() => setShowCreateModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleCreateInfo}
        >
          <Form.Item
            name="key"
            label="Key"
            rules={[{ required: true, message: 'Please enter a key' }]}
          >
            <Input />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
            rules={[{ required: true, message: 'Please enter a description' }]}
          >
            <Input.TextArea rows={6} />
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Create
            </Button>
            <Button onClick={() => setShowCreateModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* Edit Modal */}
      <Modal
        title="Edit RAG Information"
        open={showEditModal}
        onCancel={() => setShowEditModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleUpdateInfo}
        >
          <Form.Item
            name="key"
            label="Key"
            rules={[{ required: true, message: 'Please enter a key' }]}
          >
            <Input />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
            rules={[{ required: true, message: 'Please enter a description' }]}
          >
            <Input.TextArea rows={6} />
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Update
            </Button>
            <Button onClick={() => setShowEditModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* View Modal */}
      <Modal
        title="RAG Information Details"
        open={showViewModal}
        onCancel={() => setShowViewModal(false)}
        footer={[
          <Button key="close" onClick={() => setShowViewModal(false)}>
            Close
          </Button>
        ]}
      >
        {selectedItem && (
          <>
            <p><strong>Key:</strong> {selectedItem.key}</p>
            <p><strong>Description:</strong></p>
            <pre style={{ 
              whiteSpace: 'pre-wrap', 
              backgroundColor: '#f5f5f5', 
              padding: '10px', 
              borderRadius: '4px',
              maxHeight: '300px',
              overflow: 'auto'
            }}>
              {selectedItem.description}
            </pre>
            <p><strong>Created:</strong> {new Date(selectedItem.createdAt).toLocaleString()}</p>
            <p><strong>Last Updated:</strong> {new Date(selectedItem.updatedAt).toLocaleString()}</p>
          </>
        )}
      </Modal>
    </div>
  );
};

export default RagInfoComponent;

File: src/components/BatchTab/FileUpload.tsx
import React, { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import * as XLSX from 'xlsx';
import Papa from 'papaparse';
import type { PreviewData } from './types';

export interface FileUploadProps {
  onFileUpload: (file: File, sheetName?: string) => void;
}

export const parseFile = async (file: File, sheetName?: string): Promise<PreviewData> => {
  return new Promise((resolve, reject) => {
    if (file.type === 'text/csv') {
      Papa.parse(file, {
        complete: (result) => {
          if (!result.data || result.data.length === 0) {
            return reject(new Error('CSV file is empty or invalid'));
          }
          
          resolve({
            headers: result.data[0] as string[],
            rows: result.data.slice(1) as string[][],
            fileName: file.name,
            fileType: 'csv'
          });
        },
        error: (error) => reject(error)
      });
    } else {
      // Excel files
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = e.target?.result;
          const workbook = XLSX.read(data, { type: 'binary' });
          
          // If no sheet is specified, use the first one
          const selectedSheet = sheetName || workbook.SheetNames[0];
          
          if (!workbook.SheetNames.includes(selectedSheet)) {
            return reject(new Error(`Sheet "${selectedSheet}" not found in workbook`));
          }
          
          const worksheet = workbook.Sheets[selectedSheet];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          
          if (!jsonData || jsonData.length === 0) {
            return reject(new Error('Excel sheet is empty or invalid'));
          }
          
          resolve({
            headers: jsonData[0] as string[],
            rows: jsonData.slice(1) as string[][],
            fileName: file.name,
            fileType: 'excel'
          });
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = (error) => reject(error);
      reader.readAsBinaryString(file);
    }
  });
};

const FileUpload: React.FC<FileUploadProps> = ({ onFileUpload }) => {
  const [currentFile, setCurrentFile] = useState<File | null>(null);
  const [sheetOptions, setSheetOptions] = useState<string[]>([]);
  const [selectedSheet, setSelectedSheet] = useState<string>('');

  const processExcelFile = async (file: File) => {
    try {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = e.target?.result;
          const workbook = XLSX.read(data, { type: 'binary' });
          const sheets = workbook.SheetNames;
          
          if (sheets.length === 1) {
            // If there's only one sheet, just use it directly
            setCurrentFile(file);
            onFileUpload(file, sheets[0]);
          } else if (sheets.length > 1) {
            // If there are multiple sheets, show selector
            setSheetOptions(sheets);
            setSelectedSheet(sheets[0]);
            setCurrentFile(file);
          } else {
            throw new Error('No sheets found in the Excel file');
          }
        } catch (error) {
          console.error('Error processing Excel file:', error);
          alert('Failed to process Excel file: ' + (error instanceof Error ? error.message : 'Unknown error'));
        }
      };
      reader.onerror = (error) => {
        console.error('Error reading file:', error);
        alert('Failed to read file');
      };
      reader.readAsBinaryString(file);
    } catch (error) {
      console.error('Error reading Excel file:', error);
      alert('Failed to read Excel file. Please check if the file is valid.');
    }
  };

  const handleSheetSelect = async () => {
    if (!currentFile || !selectedSheet) return;

    try {
      await parseFile(currentFile, selectedSheet);
      onFileUpload(currentFile, selectedSheet);
      setSheetOptions([]); // Hide selector after selection
    } catch (error) {
      console.error('Error parsing file:', error);
      alert('Failed to parse file: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  };

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (!file) return;

    // Validate file type
    if (!isValidFileType(file)) {
      alert('Please upload a CSV or Excel file');
      return;
    }

    // Validate file size (50MB limit)
    if (file.size > 50 * 1024 * 1024) {
      alert('File size must be less than 50MB');
      return;
    }
    
    // Reset state
    setSheetOptions([]);
    
    // Handle Excel files with potential multiple sheets
    if (file.type.includes('excel') || file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
      processExcelFile(file);
    } else {
      // For CSV files, process directly
      try {
        await parseFile(file);
        setCurrentFile(file);
        onFileUpload(file);
      } catch (error) {
        console.error('Error parsing file:', error);
        alert('Failed to parse file: ' + (error instanceof Error ? error.message : 'Unknown error'));
      }
    }
  }, [onFileUpload]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'text/csv': ['.csv'],
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
      'application/vnd.ms-excel': ['.xls']
    },
    multiple: false
  });

  return (
    <>
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer
          ${isDragActive 
            ? 'border-primary-500 bg-primary-50' 
            : 'border-secondary-300 hover:border-primary-400'
          }`}
      >
        <input {...getInputProps()} />
        <div className="space-y-2">
          {currentFile && sheetOptions.length === 0 ? (
            <div>
              <svg 
                className="mx-auto h-12 w-12 text-green-500"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth={2} 
                  d="M5 13l4 4L19 7" 
                />
              </svg>
              <div className="mt-2">
                <p className="text-sm font-medium text-secondary-900">{currentFile.name}</p>
                <p className="text-xs text-secondary-500">
                  {(currentFile.size / 1024 / 1024).toFixed(2)} MB
                </p>
                <p className="text-xs text-primary-500 mt-2">
                  Click or drop to replace file
                </p>
              </div>
            </div>
          ) : (
            <>
              <svg 
                className="mx-auto h-12 w-12 text-secondary-400"
                stroke="currentColor"
                fill="none"
                viewBox="0 0 48 48"
                aria-hidden="true"
              >
                <path
                  d="M24 8v24m12-12H12"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
              <div className="text-secondary-600">
                {isDragActive ? (
                  <p>Drop the file here...</p>
                ) : (
                  <p>
                    Drag and drop a file here, or{' '}
                    <span className="text-primary-500">browse</span>
                  </p>
                )}
              </div>
              <p className="text-sm text-secondary-500">
                Supported formats: CSV, Excel (.xlsx, .xls)
              </p>
            </>
          )}
        </div>
      </div>

      {/* Sheet selector only shown when multiple sheets are detected */}
      {sheetOptions.length > 1 && (
        <div className="mt-4 p-4 border border-secondary-200 rounded-lg bg-secondary-50">
          <h4 className="text-sm font-medium text-secondary-900 mb-2">
            This Excel file contains multiple sheets. Please select one to process:
          </h4>
          <div className="flex space-x-4">
            <select
              value={selectedSheet}
              onChange={(e) => setSelectedSheet(e.target.value)}
              className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
            >
              {sheetOptions.map((sheet) => (
                <option key={sheet} value={sheet}>
                  {sheet}
                </option>
              ))}
            </select>
            <button
              onClick={handleSheetSelect}
              className="px-4 py-2 rounded-card text-white font-medium bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
            >
              Use This Sheet
            </button>
          </div>
        </div>
      )}
    </>
  );
};

// Utility functions
const isValidFileType = (file: File): boolean => {
  const validTypes = [
    'text/csv',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-excel'
  ];
  
  // Also check file extension for cases where MIME type isn't reliable
  const fileExtension = file.name.split('.').pop()?.toLowerCase() ?? '';
  const validExtensions = ['csv', 'xlsx', 'xls'];
  
  return validTypes.includes(file.type) || 
    validExtensions.includes(fileExtension);
};

export default FileUpload;

File: src/components/BatchJobsTab/utils/batchJobUtils.ts
// src/components/BatchJobsTab/utils/batchJobUtils.ts
import { BatchClassificationResult, BatchItemResult, CategoryLevel, ClassificationError } from '../../../api/types';

// Define types for execution and result statuses
export type ExecutionStatusType = 'pending' | 'processing' | 'completed' | 'error';
export type ResultStatusType = 'successful' | 'partial' | 'failed' | 'N/A';
export type ExecutionStatusFilterType = 'all' | ExecutionStatusType;
export type ResultStatusFilterType = 'all' | Exclude<ResultStatusType, 'N/A'>;

// Function to check if a single classification level is valid (has code and name)
const isValidLevel = (level: CategoryLevel | undefined | null): boolean => {
    // Check if level exists, is an object, and has non-empty code and name strings
    return !!level &&
           typeof level === 'object' &&
           typeof level.code === 'string' && level.code.length > 0 &&
           typeof level.name === 'string' && level.name.length > 0;
};

// Function to check if an item has been processed (has either a result or error)
export const isProcessedItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item) return false;
    return (!!item.result || !!item.error);
};

// Function to ensure a key preserves decimal format (if it exists in original form)
export const preserveDecimalInKey = (key: string | undefined | null): string => {
    if (!key) return '';
    
    // If the key already ends with '.0', return it as is
    if (key.endsWith('.0')) return key;
    
    // Check if the key might be a normalized version of a decimal key (missing the .0)
    // Multi-part keys are typically delimited by pipe (|) character
    if (key.includes('|')) {
        const parts = key.split('|');
        // If the last part is a number without decimal, add .0 to restore original format
        const lastPart = parts[parts.length - 1];
        if (/^\d+$/.test(lastPart)) {
            parts[parts.length - 1] = `${lastPart}.0`;
            return parts.join('|');
        }
    }
    return key;
};

// Function to check if a result item represents a fully successful classification
export const isSuccessfulItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item || !item.result || item.error) {
        return false; // Explicit error or no result means not successful
    }
    // Check the explicit status from the backend result if available
    if (item.result.status === 'failed' || item.result.status === 'partial') {
        return false;
    }
    // Check if it has levels and at least one level is valid
    // A successful item should ideally have *all* expected levels, but for robustness,
    // let's stick to the backend 'success' status or having at least one valid level if status is missing.
    if (item.result.status === 'success') {
        return true;
    }
    // Fallback: If status is missing, consider successful if it has levels and at least one is valid
    return !!item.result.levels && Object.values(item.result.levels).some(isValidLevel);
};

// Function to check if a result item represents a failed classification attempt
export const isFailedItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item) return false; // If item doesn't exist, don't count as failed from this perspective
    if (item.error) return true; // Explicit top-level error means failure
    if (item.result && item.result.status === 'failed') {
        return true; // Explicit 'failed' status from backend result
    }
    // If there's a result object, but it contains no valid levels at all, treat as failure
    if (item.result && (!item.result.levels || Object.values(item.result.levels).length === 0 || Object.values(item.result.levels).every(level => !isValidLevel(level)))) {
         // Consider logging this case: console.warn('Treating item as failed due to no valid levels:', item);
        return true;
    }
    return false; // Otherwise, it's not considered a failure (could be success or partial)
};

// Function to check if a result item is partial
export const isPartialItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item || item.error) return false; // Cannot be partial if errored or non-existent
    if (!item.result) return false; // Cannot be partial without a result object

    // Explicit 'partial' status from backend is the clearest indicator
    if (item.result.status === 'partial') {
        return true;
    }

    // Implicit partial: If status isn't explicitly 'success' or 'failed',
    // and it's not considered a full failure (has *some* valid level),
    // but also not considered fully successful (e.g., missing some levels or backend didn't mark as 'success')
    // This relies heavily on the backend providing the status correctly.
    // For now, let's primarily rely on the explicit status or the derivation below.

    // Derive partial status if not explicitly set: Not fully successful AND not fully failed
    return !isSuccessfulItem(item) && !isFailedItem(item);
};


/**
 * Determines the Execution Status based on the job's top-level status field
 */
export const getExecutionStatus = (job: BatchClassificationResult): ExecutionStatusType => {
    // Handle potential case difference from backend ('Results' vs 'results')
    const resultsArray = job.results || job.Results || [];
    // Trust the totalItems from the backend, only add nullish coalescing for TypeScript safety
    const totalItems = job.totalItems ?? 0;
    const processedCount = resultsArray.filter(r => r.result || r.error).length;

    // Prioritize job-level status if available and valid
    if (job.status && ['pending', 'processing', 'completed', 'error'].includes(job.status)) {
        // Trust the server's status - don't override it
        return job.status as ExecutionStatusType;
    }

    // Infer status if job.status is missing or invalid
    if (totalItems === 0) return 'completed'; // Or 'error' if empty is unexpected
    if (processedCount === 0) return 'pending';
    if (processedCount < totalItems) return 'processing';
    return 'completed'; // All items have some result/error entry
};

/**
 * Calculates the Result Status based on the content of the results array for a finished job
 * Returns 'N/A' if the job execution is not finished
 */
export const calculateResultStatus = (job: BatchClassificationResult): ResultStatusType => {
    const executionStatus = getExecutionStatus(job);

    // Only return N/A for pending jobs - allow processing jobs to show interim result status
    if (executionStatus === 'pending') {
        return 'N/A';
    }

    const resultsArray = job.results || job.Results || [];
    
    // Take totalItems from backend if present, otherwise use array length
    // Use type assertion to handle the case where the server returns 'total_items'
    const serverTotalItems = job.totalItems ?? (job as any).total_items;
    const totalItems = serverTotalItems ?? resultsArray.length;

    // Handle empty results case
    if (resultsArray.length === 0) {
        return executionStatus === 'error' ? 'failed' : 'N/A';
    }

    // Count different result types
    let successCount = 0;
    let partialCount = 0;
    let failedCount = 0;

    for (const item of resultsArray) {
        if (isSuccessfulItem(item)) {
            successCount++;
        } else if (isFailedItem(item)) {
            failedCount++;
        } else {
            partialCount++;
        }
    }
    
    console.log(`Job ${job.id} status counts: S=${successCount}, F=${failedCount}, P=${partialCount}, Total=${totalItems}`);

    // Determine overall status based on processed items
    if (successCount === totalItems) {
        return 'successful';
    } else if (failedCount === totalItems) {
        return 'failed';
    } else if (successCount > 0 || partialCount > 0) {
        // If there's any success or partial success, it's partial overall
        return 'partial';
    } else {
        // If we have results but couldn't categorize them, default to failed
        return 'failed';
    }
};

// Helper function to get error message
export const getFormattedErrorMessage = (error: string | ClassificationError | undefined): string => {
    if (!error) return '';
    if (typeof error === 'string') return error;
    if (typeof error === 'object' && error !== null) {
        // Check for common error message structures
        if ('message' in error && typeof error.message === 'string') {
            return error.message;
        }
        if ('error' in error && typeof error.error === 'string') {
             return error.error;
        }
        // Attempt to stringify if specific fields aren't found
        try { return JSON.stringify(error); } catch { /* ignore stringify error */ }
    }
    return 'Unknown error format';
};

File: src/components/RoleManagement/hooks/useRoles.ts
// src/components/RoleManagement/hooks/useRoles.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { message } from 'antd';
import {
  ApiClient, Role, Permission, CreateRoleRequest, UpdateRoleRequest,
  RoleListResponse, PermissionListResponse
} from '../../../api/types'; // Adjust path as needed

export interface UseRolesResult {
  roles: Role[];
  permissions: Permission[]; // All available permissions
  loading: boolean;
  loadingPermissions: boolean;
  error: string | null;
  totalRoles: number;
  // Add pagination state if needed for roles list
  // pagination: { current: number; pageSize: number; total: number };
  fetchRoles: () => Promise<void>; // Reload roles list
  fetchPermissions: () => Promise<void>; // Reload permissions
  createRole: (data: CreateRoleRequest) => Promise<Role | null>;
  updateRole: (id: number, data: UpdateRoleRequest) => Promise<Role | null>;
  deleteRole: (id: number) => Promise<boolean>;
}

export function useRoles(apiClient: ApiClient): UseRolesResult {
  const mountedRef = useRef(true);
  const [roles, setRoles] = useState<Role[]>([]);
  const [permissions, setPermissions] = useState<Permission[]>([]);
  const [totalRoles, setTotalRoles] = useState(0);
  const [loading, setLoading] = useState(true);
  const [loadingPermissions, setLoadingPermissions] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Safe state setters
  const safeSetState = <T,>(setter: React.Dispatch<React.SetStateAction<T>>) =>
    (value: T | ((prevState: T) => T)) => {
      if (mountedRef.current) {
        setter(value);
      }
    };
  const safeSetRoles = safeSetState(setRoles);
  const safeSetPermissions = safeSetState(setPermissions);
  const safeSetTotalRoles = safeSetState(setTotalRoles);
  const safeSetLoading = safeSetState(setLoading);
  const safeSetLoadingPermissions = safeSetState(setLoadingPermissions);
  const safeSetError = safeSetState(setError);

  const fetchRoles = useCallback(async () => {
    if (!mountedRef.current) return;
    safeSetLoading(true);
    safeSetError(null);
    try {
      // Fetch roles (assuming a reasonable limit for now, add pagination if needed)
      const response = await apiClient.getRoles({ limit: 500 });
      if (mountedRef.current) {
        // Ensure permissions array exists on each role
        const rolesWithPerms = (response.items || []).map(role => ({
            ...role,
            permissions: role.permissions || [] // Default to empty array
        }));
        safeSetRoles(rolesWithPerms);
        safeSetTotalRoles(response.totalCount || 0);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('Failed to fetch roles:', err);
        const msg = err instanceof Error ? err.message : 'Failed to load roles';
        safeSetError(msg);
        message.error(msg);
        safeSetRoles([]);
        safeSetTotalRoles(0);
      }
    } finally {
      if (mountedRef.current) safeSetLoading(false);
    }
  }, [apiClient, safeSetLoading, safeSetError, safeSetRoles, safeSetTotalRoles]);

  const fetchPermissions = useCallback(async () => {
    if (!mountedRef.current) return;
    safeSetLoadingPermissions(true);
    safeSetError(null); // Clear general error when loading permissions
    try {
      const response = await apiClient.getPermissions();
      if (mountedRef.current) {
        safeSetPermissions(response.items || []);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('Failed to fetch permissions:', err);
        const msg = err instanceof Error ? err.message : 'Failed to load permissions list';
        safeSetError(msg); // Set error specific to permissions loading
        message.error(msg);
        safeSetPermissions([]); // Set empty on error
      }
    } finally {
      if (mountedRef.current) safeSetLoadingPermissions(false);
    }
  }, [apiClient, safeSetLoadingPermissions, safeSetPermissions, safeSetError]);

  useEffect(() => {
    fetchRoles();
    fetchPermissions();
  }, [fetchRoles, fetchPermissions]);

  const createRole = useCallback(async (data: CreateRoleRequest): Promise<Role | null> => {
    safeSetLoading(true); safeSetError(null);
    try {
      const newRole = await apiClient.createRole(data);
      message.success(`Role "${newRole.name}" created successfully.`);
      await fetchRoles(); // Refresh list
      return newRole;
    } catch (err) {
      console.error('Failed to create role:', err);
      const msg = err instanceof Error ? err.message : 'Failed to create role';
      safeSetError(msg);
      message.error(msg);
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, fetchRoles, safeSetLoading, safeSetError]);

  const updateRole = useCallback(async (id: number, data: UpdateRoleRequest): Promise<Role | null> => {
    safeSetLoading(true); safeSetError(null);
    try {
      const updatedRole = await apiClient.updateRole(id, data);
      message.success(`Role "${updatedRole.name}" updated successfully.`);
      await fetchRoles(); // Refresh list
      return updatedRole;
    } catch (err) {
      console.error('Failed to update role:', err);
      const msg = err instanceof Error ? err.message : 'Failed to update role';
      safeSetError(msg);
      message.error(msg);
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, fetchRoles, safeSetLoading, safeSetError]);

  const deleteRole = useCallback(async (id: number): Promise<boolean> => {
    safeSetLoading(true); safeSetError(null);
    try {
      await apiClient.deleteRole(id);
      message.success(`Role deleted successfully.`);
      await fetchRoles(); // Refresh list
      return true;
    } catch (err) {
      console.error('Failed to delete role:', err);
      const msg = err instanceof Error ? err.message : 'Failed to delete role';
      safeSetError(msg);
      message.error(msg);
      return false;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, fetchRoles, safeSetLoading, safeSetError]);

  useEffect(() => { // Mount cleanup
    mountedRef.current = true;
    return () => { mountedRef.current = false; };
  }, []);

  return {
    roles,
    permissions,
    loading,
    loadingPermissions,
    error,
    totalRoles,
    // pagination: { current: 1, pageSize: 500, total: totalRoles }, // Add pagination if needed
    fetchRoles,
    fetchPermissions,
    createRole,
    updateRole,
    deleteRole,
  };
}

File: src/components/BatchTab/BatchTab.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { BatchClassificationRequest, BatchClassificationResult, BatchItemResult } from '../../api/types';
import FileUpload from './FileUpload';
import ColumnSelector from './ColumnSelector';
import BatchProgress from './BatchProgress';
import PreviewTable from './PreviewTable';
import BatchSummary from './BatchSummary';
import { BatchTabProps, ColumnConfig as ColumnConfigBase, PreviewData, SystemConfig } from './types';
import Papa from 'papaparse'; // Make sure papaparse is installed
import * as XLSX from 'xlsx'; // Make sure xlsx is installed
import { useAuth } from '../../context/AuthContext'; // Import useAuth hook

// Define a more specific type for the state if needed
interface BatchColumnConfig extends Omit<ColumnConfigBase, 'resultColumns' | 'keyColumns'> {
  keyColumnNames: string[];
}

// Helper function to check if a result has valid classification
const isValidClassification = (result: BatchItemResult): boolean => {
  try {
    if (!result?.result?.levels) {
      console.debug('Missing result or levels:', { result });
      return false;
    }

    // Check if any level has both code and name
    return Object.values(result.result.levels).some(level => 
      level && typeof level === 'object' &&
      typeof level.code === 'string' && level.code.length > 0 &&
      typeof level.name === 'string' && level.name.length > 0
    );
  } catch (error) {
    console.error('Error validating classification:', error);
    return false;
  }
};

// Parse file function to handle uploaded files (CSV/Excel)
const parseFile = async (file: File): Promise<PreviewData> => {
  return new Promise((resolve, reject) => {
    const fileType = file.name.split('.').pop()?.toLowerCase();
    
    if (fileType === 'csv') {
      // Parse CSV
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          if (results.errors && results.errors.length > 0) {
            console.error('CSV parsing errors:', results.errors);
            reject(new Error('Failed to parse CSV file'));
            return;
          }
          
          // Get headers from first row
          const headers = results.meta.fields || [];
          
          // Convert data to array of string arrays
          const rows = results.data.map((row: any) => {
            return headers.map(header => row[header] || '');
          });
          
          resolve({
            headers,
            rows,
            fileName: file.name,
            fileType: 'csv'
          });
        },
        error: (error) => {
          console.error('CSV parsing error:', error);
          reject(error);
        }
      });
    } else if (fileType === 'xlsx' || fileType === 'xls') {
      // Parse Excel
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target?.result as ArrayBuffer);
          const workbook = XLSX.read(data, { type: 'array' });
          
          // Get first sheet
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          
          // Convert to JSON
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }) as any[][];
          
          // Extract headers from first row
          const headers = jsonData[0].map(h => String(h));
          
          // Extract data rows, starting from second row
          const rows = jsonData.slice(1).map(row => {
            // Ensure all cells are strings and handle missing cells
            return headers.map((_, i) => row[i] !== undefined ? String(row[i]) : '');
          });
          
          resolve({
            headers,
            rows,
            fileName: file.name,
            fileType: 'excel'
          });
        } catch (error) {
          console.error('Excel parsing error:', error);
          reject(error);
        }
      };
      
      reader.onerror = (error) => {
        console.error('File reading error:', error);
        reject(error);
      };
      
      reader.readAsArrayBuffer(file);
    } else {
      reject(new Error('Unsupported file format. Please upload a CSV or Excel file.'));
    }
  });
};

export const BatchTab: React.FC<BatchTabProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();

  const [file, setFile] = useState<File | null>(null);
  const [previewData, setPreviewData] = useState<PreviewData | null>(null);
  const [sourceColumn, setSourceColumn] = useState<string>('');
  const [contextColumn, setContextColumn] = useState<string | undefined>(undefined);
  const [selectedKeyColumns, setSelectedKeyColumns] = useState<string[]>([]); // Store key names
  const [isProcessing, setIsProcessing] = useState(false);
  const [processedItems, setProcessedItems] = useState<number>(0);
  const [batchId, setBatchId] = useState<string | null>(null);
  const [batchResults, setBatchResults] = useState<BatchItemResult[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [completedBatch, setCompletedBatch] = useState<BatchClassificationResult | null>(null);
  const [rowsToProcess, setRowsToProcess] = useState<number>(5);
  const [processAll, setProcessAll] = useState<boolean>(false);
  const [batchTotalItems, setBatchTotalItems] = useState<number>(0);

  // Pagination states
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize] = useState(10);
  const [totalPages, setTotalPages] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [availableSystems, setAvailableSystems] = useState<SystemConfig[]>([]);
  const [selectedSystem, setSelectedSystem] = useState<SystemConfig | null>(null);

  // Load classification systems on mount
  useEffect(() => {
    const loadSystems = async () => {
      try {
        const systems = await apiClient.getClassificationSystems();
        const systemConfigs = await Promise.all(
          systems.map(async (system: { code: any; }) => {
            const details = await apiClient.getClassificationSystem(system.code);
            return details;
          })
        );
        setAvailableSystems(systemConfigs);
      } catch (error) {
        console.error('Error loading classification systems:', error);
        setError('Failed to load classification systems');
      }
    };
    loadSystems();
  }, [apiClient]);

  // Effect for polling batch status
  useEffect(() => {
    let intervalId: NodeJS.Timeout;

    const pollBatchStatus = async () => {
      if (!batchId || !isProcessing) return;

      try {
        setError(null);
        console.log('Polling batch status:', batchId);
        const status = await apiClient.getBatchStatus(batchId);
        console.log('Received status:', status);

        if (!status) {
          throw new Error('No status received from server');
        }

        // Fix case sensitivity issue - server returns lowercase 'results'
        const resultsArray = status.results || [];
        console.log('Got results array with', resultsArray.length, 'items');

        // Clone and validate results
        const results = resultsArray.map((r: BatchItemResult) => ({
          description: r.description || '',
          additional_context: r.additional_context || '',
          key: r.key || '', // Ensure key field is preserved
          error: r.error || null,
          result: r.result ? {
            ...r.result,
            levels: r.result.levels ? { ...r.result.levels } : {}
          } : null
        }));

        // Update batch results
        const totalItems = results.length;
        setTotalCount(totalItems);
        setTotalPages(Math.ceil(totalItems / pageSize));
        
        // Calculate paginated results
        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const paginatedResults = results.slice(startIndex, endIndex);
        setBatchResults(paginatedResults);

        // Count valid results
        const validResults = results.filter(isValidClassification);
        console.log('Processing status:', {
          total: totalItems,
          valid: validResults.length,
          currentPage,
          totalPages: Math.ceil(totalItems / pageSize)
        });
        
        // Check if results have key fields
        const hasKeys = results.some((r: { key: any; }) => r.key);
        console.log('Batch contains key fields:', hasKeys);
        
        // Count only items that have been actually processed (either success or error)
        const processedCount = results.filter((r: { result: { status: string }; }) =>
          r.result && r.result.status && r.result.status !== 'pending'
        ).length;
        setProcessedItems(processedCount);

        if (status.status === 'completed' || status.status === 'error') {
          console.log('Batch processing finished:', status.status);

          // Set completed batch state
          setCompletedBatch({
            id: status.id || batchId,
            status: status.status,
            timestamp: status.timestamp || new Date().toISOString(),
            results: results
          });

          // Clear processing state
          setIsProcessing(false);
          setBatchId(null);
        }
      } catch (error) {
        console.error('Error polling batch status:', error);
        setError('Failed to get batch status');
        setIsProcessing(false);
        setBatchId(null);
        setCompletedBatch(null);
        setBatchResults([]);
      }
    };

    if (isProcessing && batchId) {
      intervalId = setInterval(pollBatchStatus, 2000);
    }

    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [batchId, isProcessing, apiClient, currentPage, pageSize]);

  const handleFileUpload = async (uploadedFile: File) => {
    setFile(uploadedFile);
    setError(null);
    setBatchResults([]);
    setCompletedBatch(null);
    setProcessedItems(0);

    try {
      const result = await parseFile(uploadedFile);
      setPreviewData(result);
      setRowsToProcess(Math.min(5, result.rows.length));
    } catch (error) {
      console.error('Error parsing file:', error);
      setError('Failed to parse file. Please make sure it is a valid CSV or Excel file.');
    }
  };

  const handleSystemSelect = (systemCode: string) => {
    setSelectedSystem(availableSystems.find(s => s.system.code === systemCode) || null);
  };

  // Modify handler passed to ColumnSelector
  const handleColumnSelectionUpdate = useCallback((
    config: { sourceColumn: string; contextColumn?: string; keyColumnNames: string[] }
  ) => {
    setSourceColumn(config.sourceColumn);
    setContextColumn(config.contextColumn);
    setSelectedKeyColumns(config.keyColumnNames);
    setError(null); // Reset error on selection change
  }, []);

  const handleRowCountChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(event.target.value, 10);
    if (!isNaN(value) && value > 0 && previewData) {
      setRowsToProcess(Math.min(value, previewData.rows.length));
    }
  };

  const handleStartProcessing = async () => {
    if (!checkPermission('classify:batch')) {
      setError('You do not have permission to perform batch classifications');
      return;
    }

    if (!file || !sourceColumn || !previewData || !selectedSystem) {
      setError("Please select the source description column.");
      return;
    }

    // Determine and set the fixed total for this run
    const totalForThisBatch = processAll ? previewData.rows.length : rowsToProcess;
    setBatchTotalItems(totalForThisBatch);

    setIsProcessing(true);
    setBatchResults([]);
    setProcessedItems(0);
    setError(null);
    setCompletedBatch(null);

    try {
      const allRows = previewData.rows;
      const rowsToUse = allRows.slice(0, totalForThisBatch);

      const items = rowsToUse.map(row => {
        const sourceIndex = previewData.headers.indexOf(sourceColumn);
        const contextIndex = contextColumn
          ? previewData.headers.indexOf(contextColumn)
          : -1;
        
        // Generate composite key from selected key columns
        let key = '';
        if (selectedKeyColumns && selectedKeyColumns.length > 0) {
          const keyParts = selectedKeyColumns.map(keyCol => {
            const keyIndex = previewData.headers.indexOf(keyCol);
            return keyIndex >= 0 ? row[keyIndex] : '';
          }).filter(Boolean); // Remove empty values
          
          key = keyParts.join('|'); // Join with pipe delimiter for multiple key parts
        }

        return {
          description: row[sourceIndex],
          additionalContext: contextIndex >= 0 ? row[contextIndex] : undefined,
          key: key || undefined // Only include key if it has a value
        };
      });

      // Create request with key column names
      const request: BatchClassificationRequest & { key_column_names?: string[] } = {
        items,
        systemCode: selectedSystem.system.code,
        key_column_names: selectedKeyColumns // Pass the selected key names
      };

      console.log('Starting batch with request:', { 
        itemCount: request.items.length,
        systemCode: request.systemCode,
        keyColumnNames: request.key_column_names
      });

      const result = await apiClient.classifyBatch(request);
      console.log('Started batch processing:', result?.id);

      if (!result?.id) {
        throw new Error('No batch ID received from server');
      }

      setBatchId(result.id);
    } catch (error) {
      console.error('Error starting batch process:', error);
      setError('Failed to start batch processing');
      setIsProcessing(false);
      setBatchTotalItems(0); // Reset total on error
    }
  };

  const handlePageChange = (page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
      // Results will be updated by the polling effect
      console.debug('Changing to page:', page);
    }
  };

  return (
    <div className="max-w-8xl mx-auto space-y-10" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
      {!checkPermission('classify:batch') && (
        <div className="bg-white shadow-card rounded-card p-6 border-l-4 border-yellow-500">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-yellow-800">Permission Notice</h3>
              <div className="mt-2 text-sm text-yellow-700">
                <p>You don't have permission to perform batch classifications. Contact your administrator for access.</p>
              </div>
            </div>
          </div>
        </div>
      )}

      <div className="bg-white shadow-card rounded-card p-8 w-full" style={{ paddingRight: '5rem', paddingLeft: '3rem'}}>
        <div className="space-y-8">
          {error && (
            <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3">
              <p className="text-sm text-red-700">{error}</p>
            </div>
          )}

          <div className="border-b pb-6">
            <h3 className="text-lg font-medium mb-3">1. Upload File</h3>
            <FileUpload onFileUpload={handleFileUpload} />
          </div>

          {previewData && (
            <>
              <div className="border-b pb-6">
                <div className="flex justify-between items-center mb-3">
                  <h3 className="text-lg font-medium">2. Preview Data</h3>
                  {isProcessing && (
                    <div className="ml-4">
                      <BatchProgress 
                        current={processedItems} 
                        total={batchTotalItems}
                      />
                    </div>
                  )}
                </div>
                <PreviewTable 
                  data={previewData}
                  columnConfig={{
                    sourceColumn,
                    contextColumn,
                    keyColumns: selectedKeyColumns, // Pass key columns to preview
                    resultColumns: [],
                    descriptionColumnIndex: sourceColumn ? previewData.headers.indexOf(sourceColumn) : -1
                  }}
                  batchResults={batchResults}
                  isProcessing={isProcessing}
                />
              </div>

              <div className="border-b pb-6">
                <h3 className="text-lg font-medium mb-3">3. Select Columns</h3>
                <ColumnSelector 
                  headers={previewData.headers}
                  onColumnSelect={handleColumnSelectionUpdate}
                  availableSystems={availableSystems}
                  onSystemSelect={handleSystemSelect}
                  selectedSystem={selectedSystem}
                />
              </div>
            </>
          )}

          {!isProcessing && completedBatch && (
            <div className="border-b pb-6">
              <h3 className="text-lg font-medium mb-3">Results</h3>
              <BatchSummary
                result={completedBatch}
                originalData={{
                  headers: previewData?.headers || [],
                  rows: previewData?.rows || []
                }}
              />
              
              {/* Move pagination controls here */}
              {batchResults.length > 0 && (
                <div className="mt-6 flex items-center justify-between">
                  <div className="flex-1 flex justify-between items-center">
                    <p className="text-sm text-secondary-600">
                      Showing {Math.min((currentPage - 1) * pageSize + 1, totalCount)} - {Math.min(currentPage * pageSize, totalCount)} of {totalCount} results
                    </p>
                    
                    {/* Pagination buttons */}
                    <div className="flex items-center gap-2">
                      <button
                        onClick={() => handlePageChange(1)}
                        disabled={currentPage === 1 || isProcessing}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        First
                      </button>
                      
                      <button
                        onClick={() => handlePageChange(currentPage - 1)}
                        disabled={currentPage === 1 || isProcessing}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Previous
                      </button>

                      {(() => {
                        const pages = [];
                        const maxButtons = 5;
                        let start = Math.max(1, currentPage - Math.floor(maxButtons / 2));
                        let end = Math.min(start + maxButtons - 1, totalPages);

                        // Adjust start if we're at the end
                        if (end === totalPages) {
                          start = Math.max(1, end - maxButtons + 1);
                        }

                        // Show dots at start if needed
                        if (start > 1) {
                          pages.push(
                            <span key="start-dots" className="px-2 py-2 text-secondary-500">...</span>
                          );
                        }

                        // Page numbers
                        for (let i = start; i <= end; i++) {
                          pages.push(
                            <button
                              key={i}
                              onClick={() => handlePageChange(i)}
                              disabled={isProcessing}
                              className={`px-3 py-2 rounded-lg border text-sm font-medium ${
                                i === currentPage
                                  ? 'bg-primary-600 text-white border-primary-600'
                                  : 'border-secondary-200 text-secondary-700 hover:bg-secondary-50'
                              }`}
                            >
                              {i}
                            </button>
                          );
                        }

                        // Show dots at end if needed
                        if (end < totalPages) {
                          pages.push(
                            <span key="end-dots" className="px-2 py-2 text-secondary-500">...</span>
                          );
                        }

                        return pages;
                      })()}

                      <button
                        onClick={() => handlePageChange(currentPage + 1)}
                        disabled={currentPage === totalPages || isProcessing}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Next
                      </button>
                      
                      <button
                        onClick={() => handlePageChange(totalPages)}
                        disabled={currentPage === totalPages || isProcessing || totalPages <= 1}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Last
                      </button>
                    </div>
                  </div>
                </div>
              )}
              
              <button
                onClick={() => {
                  setCompletedBatch(null);
                  setBatchResults([]);
                  setProcessedItems(0);
                  setError(null);
                }}
                className="mt-4 w-full py-3 px-4 rounded-card text-white font-medium transition-colors bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
              >
                Process Another Batch
              </button>
            </div>
          )}

          {previewData && sourceColumn && selectedSystem && !completedBatch && (
            <div className="space-y-6">
              {/* Selected System Display */}
              <div className="flex flex-col space-y-3">
                <h3 className="text-lg font-medium">4. Selected System</h3>
                <div className="bg-secondary-50 rounded-card border border-secondary-200 p-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <p className="text-sm font-medium text-secondary-700">System Name</p>
                      <p className="mt-1 text-sm text-secondary-900">{selectedSystem.system.name}</p>
                    </div>
                    <div>
                      <p className="text-sm font-medium text-secondary-700">System Code</p>
                      <p className="mt-1 text-sm text-secondary-900">{selectedSystem.system.code}</p>
                    </div>
                    {selectedSystem.system.description && (
                      <div className="col-span-2">
                        <p className="text-sm font-medium text-secondary-700">Description</p>
                        <p className="mt-1 text-sm text-secondary-900">{selectedSystem.system.description}</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Processing Options */}
              <div className="flex flex-col space-y-3">
                <h3 className="text-lg font-medium">5. Processing Options</h3>
                <div>
                  <label className="block text-sm font-medium text-secondary-700 mb-1">
                    Rows to Process
                  </label>
                    
                  {/* Restructure to a single line with flex layout */}
                  <div className="flex items-center">
                    <div className="flex items-center mr-6">
                    <input
                      type="number"
                      min="1"
                      max={previewData.rows.length}
                      value={processAll ? previewData.rows.length : rowsToProcess}
                      onChange={handleRowCountChange}
                      disabled={processAll || isProcessing}
                      className="w-24 px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent disabled:bg-gray-100"
                    />
                    </div>
                    
                    <div className="flex items-center mr-6">
                    <input
                      type="checkbox"
                      id="processAll"
                      checked={processAll}
                      onChange={(e) => setProcessAll(e.target.checked)}
                      disabled={isProcessing}
                      className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-secondary-300 rounded"
                    />
                    <label htmlFor="processAll" className="ml-2 text-sm text-secondary-700">
                      Process all rows ({previewData.rows.length} total)
                    </label>
                    </div>
     
                
                  {/* Progress indicator takes remaining space */}
                  {isProcessing && (
                    <div className="flex-grow max-w-">
                    <BatchProgress 
                      current={processedItems} 
                      total={batchTotalItems}
                    />
                    </div>
                  )}
                  </div>
                </div>
              </div>

              <div className="flex justify-center items-center pt-4">
                <button
                  onClick={handleStartProcessing}
                  disabled={isProcessing}
                  className={`py-3 rounded-card text-white font-medium transition-colors ${
                    isProcessing 
                      ? 'bg-secondary-400 cursor-not-allowed w-full' 
                      : 'bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 px-8'
                  }`}
                >
                  {isProcessing ? 'Processing...' : 'Start Processing'}
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default BatchTab;


File: src/components/BatchTab/ColumnSelector.tsx
import React, { useState, useEffect } from 'react';
import { ColumnConfig, ResultColumn, SystemConfig } from './types';

interface ColumnSelectorProps {
  headers: string[];
  onColumnSelect: (config: Omit<ColumnConfig, 'resultColumns'> & { keyColumnNames: string[] }) => void; // Pass key names separately for clarity initially
  availableSystems: SystemConfig[];
  onSystemSelect: (systemCode: string) => void;
  selectedSystem: SystemConfig | null;
}

const ColumnSelector: React.FC<ColumnSelectorProps> = ({
  headers,
  onColumnSelect,
  availableSystems,
  onSystemSelect,
  selectedSystem
}) => {
  const [sourceColumn, setSourceColumn] = useState('');
  const [contextColumn, setContextColumn] = useState('');
  const [keyColumns, setKeyColumns] = useState<string[]>([]); // State for key column names
  const [resultColumns, setResultColumns] = useState<ResultColumn[]>([]);

  // Initialize result columns when system changes
  useEffect(() => {
    if (selectedSystem) {
      const initialResultColumns: ResultColumn[] = selectedSystem.levels.map(level => ({
        levelCode: level.code,
        levelName: level.name,
        codeColumn: `${level.name}_Code`,
        nameColumn: `${level.name}_Name`,
        isNewColumn: true
      }));
      setResultColumns(initialResultColumns);
    }
  }, [selectedSystem]);

  // Effect to call onColumnSelect when selections change
  useEffect(() => {
    if (sourceColumn) { // Only call if source is selected
      onColumnSelect({
        sourceColumn,
        contextColumn: contextColumn || undefined, // Ensure undefined if empty
        keyColumnNames: keyColumns, // Pass selected key columns 
        keyColumns: keyColumns, // Also map to keyColumns for type compatibility
        descriptionColumnIndex: -1 // Keep dummy value for backward compatibility
      });
    }
  }, [sourceColumn, contextColumn, keyColumns, onColumnSelect]);

  const handleSourceColumnChange = (value: string) => {
    setSourceColumn(value);
  };

  const handleContextColumnChange = (value: string) => {
    setContextColumn(value);
  };

  const handleKeyColumnChange = (header: string, isChecked: boolean) => {
    setKeyColumns(prev => {
      if (isChecked) {
        // Add to key columns if not already present
        return [...prev, header];
      } else {
        // Remove from key columns
        return prev.filter(col => col !== header);
      }
    });
    // Note: The useEffect above will trigger onColumnSelect
  };

  const handleResultColumnChange = (levelCode: string, changes: Partial<ResultColumn>) => {
    setResultColumns(prev => ({
      ...prev,
      resultColumns: prev.map(col =>
        col.levelCode === levelCode
          ? { ...col, ...changes }
          : col
      )
    }));
  };

  const isColumnDisabled = (header: string, currentType: keyof ColumnConfig | string) => {
    if (currentType === 'sourceColumn' || currentType === 'contextColumn') {
      return (
        (currentType === 'sourceColumn' ? sourceColumn !== header : contextColumn !== header) &&
        (sourceColumn === header || contextColumn === header)
      );
    }
    // Key columns can overlap with any column
    if (currentType === 'keyColumns') {
      return false;
    }
    // For result columns
    return sourceColumn === header || contextColumn === header;
  };

  return (
    <div className="space-y-4">
      {/* Classification System Selection */}
      <div className="space-y-2">
        <label 
          htmlFor="systemSelect"
          className="block text-sm font-medium text-secondary-700"
        >
          Classification System *
        </label>
        <select
          id="systemSelect"
          value={selectedSystem?.system.code || ''}
          onChange={(e) => onSystemSelect(e.target.value)}
          className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
          required
        >
          <option value="">Select a classification system</option>
          {availableSystems.map((sys) => (
            <option key={sys.system.code} value={sys.system.code}>
              {sys.system.name} ({sys.levels.length} levels)
            </option>
          ))}
        </select>
      </div>

      {/* Source Column Selection */}
      <div className="space-y-2">
        <label 
          htmlFor="sourceColumn"
          className="block text-sm font-medium text-secondary-700"
        >
          Source Description Column *
        </label>
        <select
          id="sourceColumn"
          value={sourceColumn}
          onChange={(e) => handleSourceColumnChange(e.target.value)}
          className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
          required
        >
          <option value="">Select a column</option>
          {headers.map((header) => (
            <option 
              key={header} 
              value={header}
              disabled={isColumnDisabled(header, 'sourceColumn')}
            >
              {header}
            </option>
          ))}
        </select>
      </div>

      {/* Context Column Selection */}
      <div className="space-y-2">
        <label 
          htmlFor="contextColumn"
          className="block text-sm font-medium text-secondary-700"
        >
          Additional Context Column (Optional)
        </label>
        <select
          id="contextColumn"
          value={contextColumn}
          onChange={(e) => handleContextColumnChange(e.target.value)}
          className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
        >
          <option value="">None</option>
          {headers.map((header) => (
            <option 
              key={header} 
              value={header}
              disabled={isColumnDisabled(header, 'contextColumn')}
            >
              {header}
            </option>
          ))}
        </select>
      </div>

      {/* Key Column Selection */}
      <div className="space-y-2">
        <label className="block text-sm font-medium text-secondary-700">
          Key Columns (Select one or more columns to use as unique identifiers)
        </label>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2 p-3 border border-secondary-200 rounded-card bg-white">
          {headers.map((header) => (
            <div key={header} className="flex items-center">
              <input
                type="checkbox"
                id={`key-${header}`}
                // Use keyColumns state here
                checked={keyColumns.includes(header)}
                onChange={(e) => handleKeyColumnChange(header, e.target.checked)}
                className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-secondary-300 rounded"
              />
              <label htmlFor={`key-${header}`} className="ml-2 block text-sm text-secondary-900 truncate">
                {header}
              </label>
            </div>
          ))}
        </div>
        <p className="text-xs text-secondary-500">
          These columns will be combined to form a unique key for each row. When downloading results, 
          they will be available as separate columns (key1, key2, etc.).
        </p>
      </div>

      {/* Result Columns Selection */}
      {selectedSystem && (
        <div className="space-y-4">
          <h4 className="font-medium text-secondary-700">Result Columns</h4>
          {resultColumns.map((resultCol) => (
            <div key={resultCol.levelCode} className="space-y-2">
              <label className="block text-sm font-medium text-secondary-700">
                {resultCol.levelName} Result Columns *
              </label>
              <div className="grid grid-cols-2 gap-4">
               {/* Code Column Selection */}
               <div>
                 <select
                   value={resultCol.isNewColumn ? '__new__' : resultCol.codeColumn}
                   onChange={(e) => {
                     const isNew = e.target.value === '__new__';
                     handleResultColumnChange(resultCol.levelCode, {
                       isNewColumn: isNew,
                       codeColumn: isNew ? `${resultCol.levelName}_Code` : e.target.value
                     });
                   }}
                   className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  >
                    <option value="__new__">{resultCol.levelName} Code (New)</option>
                    {headers.map((header) => (
                      <option 
                        key={header} 
                        value={header}
                        disabled={isColumnDisabled(header, resultCol.levelCode)}
                      >
                        {header}
                      </option>
                    ))}
                  </select>
                  {resultCol.isNewColumn && (
                    <input
                      type="text"
                      value={resultCol.codeColumn}
                      onChange={(e) => handleResultColumnChange(resultCol.levelCode, {
                        codeColumn: e.target.value
                      })}
                      placeholder="Code column name"
                      className="mt-2 w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                    />
                  )}
                </div>

                {/* Name Column Selection */}
                <div>
                  <select
                    value={resultCol.isNewColumn ? '__new__' : resultCol.nameColumn}
                    onChange={(e) => {
                      const isNew = e.target.value === '__new__';
                      handleResultColumnChange(resultCol.levelCode, {
                        isNewColumn: isNew,
                        nameColumn: isNew ? `${resultCol.levelName}_Name` : e.target.value
                      });
                    }}
                    className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  >
                    <option value="__new__">{resultCol.levelName} Name (New)</option>
                    {headers.map((header) => (
                      <option 
                        key={header} 
                        value={header}
                        disabled={isColumnDisabled(header, resultCol.levelCode)}
                      >
                        {header}
                      </option>
                    ))}
                  </select>
                  {resultCol.isNewColumn && (
                    <input
                      type="text"
                      value={resultCol.nameColumn}
                      onChange={(e) => handleResultColumnChange(resultCol.levelCode, {
                        nameColumn: e.target.value
                      })}
                      placeholder="Name column name"
                      className="mt-2 w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                    />
                  )}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Helper Text */}
      <p className="text-sm text-secondary-500 mt-2">
        * Required fields. Each column must be unique.
      </p>
    </div>
  );
};

export default ColumnSelector;

File: src/components/RagInfoTab/components/RagInfoFormModal.tsx
// src/components/RagInfoTab/components/RagInfoFormModal.tsx
import React, { useState, useEffect } from 'react';
import { RagInfoItem, CreateRagInfoRequest, UpdateRagInfoRequest } from '../../../api/types'; // Adjust path

interface RagInfoFormModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: CreateRagInfoRequest | UpdateRagInfoRequest) => Promise<boolean>; // Returns true on success
    initialData?: RagInfoItem; // For editing
    loading: boolean;
}

export const RagInfoFormModal: React.FC<RagInfoFormModalProps> = ({
    isOpen,
    onClose,
    onSubmit,
    initialData,
    loading
}) => {
    const [key, setKey] = useState('');
    const [description, setDescription] = useState('');
    const [error, setError] = useState<string | null>(null);

    const isEditMode = !!initialData;

    useEffect(() => {
        if (isOpen) {
            if (isEditMode) {
                setKey(initialData.key);
                setDescription(initialData.description);
            } else {
                setKey('');
                setDescription('');
            }
            setError(null); // Reset error when modal opens
        }
    }, [isOpen, initialData, isEditMode]);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        if (!key.trim() || !description.trim()) {
            setError('Key and Description cannot be empty.');
            return;
        }

        const data: CreateRagInfoRequest | UpdateRagInfoRequest = isEditMode
            ? { description: description.trim() } // Only allow updating description for now
            : { key: key.trim(), description: description.trim() };

        const success = await onSubmit(data);
        if (success) {
            onClose();
        } else {
             // Assuming the hook sets the error state visible in the main tab
             // If you want modal-specific errors, onSubmit should return error message
            setError("Operation failed. Please check the main page for errors.");
        }
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg shadow-xl max-w-lg w-full max-h-[90vh] overflow-y-auto">
                <form onSubmit={handleSubmit}>
                    <div className="p-6">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-semibold text-secondary-900">
                                {isEditMode ? 'Edit Information' : 'Add New Information'}
                            </h2>
                            <button
                                type="button"
                                onClick={onClose}
                                className="text-secondary-400 hover:text-secondary-600"
                                disabled={loading}
                                aria-label="Close modal"
                            >
                                <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>

                        {error && (
                            <div className="mb-4 rounded-md border border-red-200 bg-red-50 p-3 text-sm text-red-700">
                                {error}
                            </div>
                        )}

                        <div className="space-y-4">
                            <div>
                                <label htmlFor="ragKey" className="label">Key *</label>
                                <input
                                    type="text"
                                    id="ragKey"
                                    value={key}
                                    onChange={(e) => setKey(e.target.value)}
                                    className="input"
                                    required
                                    disabled={isEditMode || loading} // Disable key editing in edit mode
                                />
                                 {isEditMode && <p className="text-xs text-secondary-500 mt-1">Key cannot be changed after creation.</p>}
                            </div>
                            <div>
                                <label htmlFor="ragDescription" className="label">Description *</label>
                                <textarea
                                    id="ragDescription"
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    className="input" // Use global style
                                    rows={4}
                                    required
                                    disabled={loading}
                                />
                            </div>
                        </div>
                    </div>

                    <div className="bg-secondary-50 px-6 py-3 flex justify-end space-x-3">
                        <button
                            type="button"
                            onClick={onClose}
                            className="btn btn-secondary" // Use global style
                            disabled={loading}
                        >
                            Cancel
                        </button>
                        <button
                            type="submit"
                            className="btn btn-primary" // Use global style
                            disabled={loading || !key.trim() || !description.trim()}
                        >
                            {loading ? 'Saving...' : (isEditMode ? 'Save Changes' : 'Add Information')}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

File: src/components/BatchJobsTab/components/JobStatusDisplay.tsx
// src/components/BatchJobsTab/components/JobStatusDisplay.tsx
import React from 'react';
import { BatchClassificationResult } from '../../../api/types';
import { getExecutionStatus, calculateResultStatus, isSuccessfulItem, isFailedItem, isPartialItem } from '../utils/batchJobUtils';
import { ExecutionStatusType, ResultStatusType } from '../utils/batchJobUtils';
import { formatDate } from '../../../utils/dateFormat';

interface JobStatusDisplayProps { job: BatchClassificationResult; }

// Execution Status Badge Component
export const ExecutionStatusBadge: React.FC<{ status: ExecutionStatusType }> = ({ status }) => {
    const styles: Record<ExecutionStatusType, string> = {
        pending: "bg-blue-100 text-blue-800 border-blue-200",
        processing: "bg-yellow-100 text-yellow-800 border-yellow-200 animate-pulse",
        completed: "bg-green-100 text-green-800 border-green-200",
        error: "bg-red-100 text-red-800 border-red-200"
    };
    const labels: Record<ExecutionStatusType, string> = {
        pending: "Pending",
        processing: "Processing",
        completed: "Completed",
        error: "Error"
    };
    const style = styles[status];
    const label = labels[status];
    return <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${style}`}>{label}</span>;
};

// Result Status Badge Component
export const ResultStatusBadge: React.FC<{ status: ResultStatusType }> = ({ status }) => {
    if (status === 'N/A') {
        return <span className="text-xs text-gray-400 italic">N/A</span>;
    }
    const styles: Record<Exclude<ResultStatusType, 'N/A'>, string> = {
        successful: "bg-green-100 text-green-800 border-green-200",
        partial: "bg-orange-100 text-orange-800 border-orange-200",
        failed: "bg-red-100 text-red-800 border-red-200"
    };
    const labels: Record<Exclude<ResultStatusType, 'N/A'>, string> = {
        successful: "Successful",
        partial: "Partial",
        failed: "Failed"
    };
    const style = styles[status];
    const label = labels[status];
    return <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${style}`}>{label}</span>;
};

// Renders the progress bar and text
const ProgressInfo: React.FC<{ job: BatchClassificationResult }> = ({ job }) => {
    const resultsArray = job.results || job.Results || [];
    
    // Access the totalItems property from the API response
    const totalItems = job.totalItems ?? 0;
    
    // Access processedItems from the API response, fall back to counting if not available
    const processedItems = job.processedItems ?? resultsArray.filter(r => r.result || r.error).length;
    
    console.log('Job object in ProgressInfo:', job);
    console.log('Total items detected:', totalItems);
    console.log('Processed items detected:', processedItems);
    
    // Use totalItems, or fall back to array length if not available
    const total = totalItems > 0 ? totalItems : resultsArray.length;
    
    if (total === 0) return <div className="text-xs text-secondary-500">No items</div>;
    
    // Use the processed items count from the API if available
    const processed = processedItems;
    const success = resultsArray.filter(isSuccessfulItem).length;
    const partial = resultsArray.filter(isPartialItem).length;
    const failed = processed - success - partial;

    // Calculate success rate based on fully successful items
    const successRate = processed > 0 ? Math.round((success / processed) * 100) : 0;

    // Calculate partial success rate
    const partialRate = processed > 0 ? Math.round((partial / processed) * 100) : 0;

    // Determine overall success rate description
    const successRateDescription = () => {
        const combinedSuccessRate = successRate + (partialRate / 2); // Count partials as half successful for color determination
        if (combinedSuccessRate >= 80) return 'text-green-600';
        if (combinedSuccessRate >= 50) return 'text-orange-600';
        return 'text-red-600';
    };

    const executionStatus = getExecutionStatus(job);

    if (executionStatus === 'pending') {
        return (
            <div className="space-y-1">
                <div className="flex justify-between mb-1 text-xs">
                    <span>0/{total} items</span>
                    <span className="text-secondary-500">0% success</span>
                </div>
                <div className="w-full bg-secondary-200 rounded-full h-2">
                    <div className="bg-blue-500 h-full" style={{ width: '0%' }} />
                </div>
                <div className="text-xs text-blue-600 text-right">Waiting...</div>
            </div>
        );
    }

    // Calculate width percentages for the progress bar
    const successWidth = (success / total) * 100;
    const partialWidth = (partial / total) * 100;
    const failedWidth = (failed / total) * 100;
    const pendingWidth = ((total - processed) / total) * 100;

    return (
        <div className="space-y-1">
            <div className="flex justify-between mb-1 text-xs">
                <span>{processed}/{total} processed</span>
                {processed > 0 && (
                    <span className={successRateDescription()}>
                        {successRate}% success {partial > 0 ? `(+${partialRate}% partial)` : ''}
                    </span>
                )}
            </div>
            <div className="w-full bg-secondary-200 rounded-full h-2 relative overflow-hidden">
                {/* Success segment (green) */}
                {success > 0 && (
                    <div 
                        className="absolute top-0 left-0 bg-green-500 h-full transition-width duration-500 ease-out" 
                        style={{ width: `${successWidth}%` }} 
                    />
                )}
                
                {/* Partial segment (orange) */}
                {partial > 0 && (
                    <div 
                        className="absolute top-0 bg-orange-500 h-full transition-width duration-500 ease-out" 
                        style={{ left: `${successWidth}%`, width: `${partialWidth}%` }} 
                    />
                )}
                
                {/* Failed segment (red) */}
                {failed > 0 && (
                    <div 
                        className="absolute top-0 bg-red-500 h-full transition-width duration-500 ease-out" 
                        style={{ left: `${successWidth + partialWidth}%`, width: `${failedWidth}%` }} 
                    />
                )}
                
                {/* Processing segment (yellow pulse) */}
                {executionStatus === 'processing' && processed < total && (
                    <div 
                        className="absolute top-0 bg-yellow-400 h-full animate-pulse" 
                        style={{ left: `${(processed / total) * 100}%`, width: `${pendingWidth}%` }} 
                    />
                )}
            </div>
            {executionStatus === 'processing' && <div className="text-xs text-yellow-600 text-right">Processing...</div>}
            {executionStatus === 'completed' && calculateResultStatus(job) === 'successful' && 
                <div className="text-xs text-green-600 text-right">Successfully Completed</div>}
            {executionStatus === 'completed' && calculateResultStatus(job) === 'partial' && 
                <div className="text-xs text-orange-600 text-right">Partially Successful</div>}
            {executionStatus === 'completed' && calculateResultStatus(job) === 'failed' && 
                <div className="text-xs text-red-600 text-right">Failed</div>}
        </div>
    );
};

// Renders a summary of counts
const JobSummary: React.FC<{ job: BatchClassificationResult }> = ({ job }) => {
    const resultsArray = job.results || job.Results || [];
    
    // Access the totalItems property, but handle the case where the server sends it as total_items
    const totalItems = job.totalItems ?? (job as any).total_items;
    
    console.log('Job object in JobSummary:', job);
    console.log('Total items detected in summary:', totalItems);
    
    // Use totalItems, or fall back to array length if not available
    const total = totalItems ?? resultsArray.length;
    
    if (total === 0) return <div className="text-xs text-secondary-500">No items</div>;
    
    const success = resultsArray.filter(isSuccessfulItem).length;
    const partial = resultsArray.filter(isPartialItem).length;
    const failed = resultsArray.filter(isFailedItem).length;
    const processed = resultsArray.filter(r => r.result || r.error).length;
    const pending = total - processed;
    
    const executionStatus = getExecutionStatus(job);

    return (
        <div className="text-xs text-secondary-600 space-y-0.5">
            <div>Total: <span className="font-medium">{total}</span></div>
            <div className="text-green-600">Success: <span className="font-medium">{success}</span></div>
            {partial > 0 && (
                <div className="text-orange-600">Partial: <span className="font-medium">{partial}</span></div>
            )}
            <div className="text-red-600">Failed: <span className="font-medium">{failed}</span></div>
            {(executionStatus === 'pending' || executionStatus === 'processing') && pending > 0 && 
                <div className="text-yellow-600">Pending: <span className="font-medium">{pending}</span></div>}
            {processed > 0 && (
                <div className="text-secondary-500 pt-1">
                    Success Rate: <span className="font-medium">{Math.round((success / processed) * 100)}%</span>
                    {partial > 0 && (
                        <> (+<span className="font-medium">{Math.round((partial / processed) * 100)}%</span> partial)</>
                    )}
                </div>
            )}
        </div>
    );
};

// Combined component to render multiple cells related to status/progress
export const JobStatusDisplay: React.FC<JobStatusDisplayProps> = ({ job }) => {
    const executionStatus = getExecutionStatus(job);
    const resultStatus = calculateResultStatus(job);

    return (
        <>
            {/* Execution Status Cell */}
            <td className="px-4 py-4 whitespace-nowrap text-sm">
                <ExecutionStatusBadge status={executionStatus} />
            </td>
            {/* Result Status Cell */}
            <td className="px-4 py-4 whitespace-nowrap text-sm">
                <ResultStatusBadge status={resultStatus} />
            </td>
            {/* Created Date Cell */}
            <td className="px-4 py-4 whitespace-nowrap text-sm text-secondary-600">
                <span title={formatDate(job.timestamp).fullText}>
                    {formatDate(job.timestamp).displayText}
                </span>
            </td>
            {/* Progress Info Cell */}
            <td className="px-4 py-4 text-sm w-52">
                <ProgressInfo job={job} />
            </td>
            {/* Summary Info Cell */}
            <td className="px-4 py-4 text-sm">
                <JobSummary job={job} />
            </td>
        </>
    );
};

File: src/components/BatchJobsTab/components/BatchJobsFilters.tsx
// src/components/BatchJobsTab/components/BatchJobsFilters.tsx
import React from 'react';
import { ExecutionStatusFilterType, ResultStatusFilterType } from '../utils/batchJobUtils';

interface BatchJobsFiltersProps {
    selectedExecutionStatus: ExecutionStatusFilterType;
    selectedResultStatus: ResultStatusFilterType;
    startDate: string;
    endDate: string;
    onExecutionStatusChange: (status: ExecutionStatusFilterType) => void;
    onResultStatusChange: (status: ResultStatusFilterType) => void;
    onStartDateChange: (date: string) => void;
    onEndDateChange: (date: string) => void;
    loading: boolean;
}

export const BatchJobsFilters: React.FC<BatchJobsFiltersProps> = ({
    selectedExecutionStatus,
    selectedResultStatus,
    startDate,
    endDate,
    onExecutionStatusChange,
    onResultStatusChange,
    onStartDateChange,
    onEndDateChange,
    loading
}) => {
    return (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            {/* Execution Status Filter */}
            <div>
                <label htmlFor="execStatusFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    Exec. Status
                </label>
                <select
                    id="execStatusFilter"
                    className="input"
                    value={selectedExecutionStatus}
                    onChange={(e) => onExecutionStatusChange(e.target.value as ExecutionStatusFilterType)}
                    disabled={loading}
                >
                    <option value="all">All Execution</option>
                    <option value="pending">Pending</option>
                    <option value="processing">Processing</option>
                    <option value="completed">Completed</option>
                    <option value="error">Error</option>
                </select>
            </div>

            {/* Result Status Filter */}
            <div>
                <label htmlFor="resultStatusFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    Result Status
                </label>
                <select
                    id="resultStatusFilter"
                    className="input"
                    value={selectedResultStatus}
                    onChange={(e) => onResultStatusChange(e.target.value as ResultStatusFilterType)}
                    disabled={loading || selectedExecutionStatus === 'pending' || selectedExecutionStatus === 'processing'}
                >
                    <option value="all">All Results</option>
                    <option value="successful">Successful</option>
                    <option value="partial">Partial</option>
                    <option value="failed">Failed</option>
                </select>
            </div>

            {/* Start Date Filter */}
            <div>
                <label htmlFor="startDateFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    Start Date
                </label>
                <input
                    type="date"
                    id="startDateFilter"
                    className="input"
                    value={startDate}
                    onChange={(e) => onStartDateChange(e.target.value)}
                    max={endDate}
                    disabled={loading}
                />
            </div>

            {/* End Date Filter */}
            <div>
                <label htmlFor="endDateFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    End Date
                </label>
                <input
                    type="date"
                    id="endDateFilter"
                    className="input"
                    value={endDate}
                    onChange={(e) => onEndDateChange(e.target.value)}
                    min={startDate}
                    disabled={loading}
                />
            </div>
        </div>
    );
};

File: src/components/RoleManagement/components/RoleTable.tsx
// src/components/RoleManagement/components/RoleTable.tsx
import React from 'react';
import { Table, Space, Button, Tag, Popconfirm, Tooltip } from 'antd';
import { EditOutlined, DeleteOutlined } from '@ant-design/icons';
import { Role, Permission } from '../../../api/types'; // Adjust path

interface RoleTableProps {
  roles: Role[];
  loading: boolean;
  onEdit: (role: Role) => void;
  onDelete: (id: number) => void;
  // Add pagination props if implemented in useRoles hook
  // pagination: { current: number; pageSize: number; total: number };
  // onPageChange: (page: number, pageSize: number) => void;
}

export const RoleTable: React.FC<RoleTableProps> = ({
  roles,
  loading,
  onEdit,
  onDelete,
  // pagination,
  // onPageChange,
}) => {

  const columns = [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
      width: 80,
      sorter: (a: Role, b: Role) => a.id - b.id,
    },
    {
      title: 'Role Name',
      dataIndex: 'name',
      key: 'name',
      sorter: (a: Role, b: Role) => a.name.localeCompare(b.name),
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true, // Truncate long descriptions
    },
    {
        title: 'Permissions',
        key: 'permissions',
        render: (_: any, record: Role) => {
            const permissions = record.permissions || [];
            const displayCount = 3; // Max permissions to show directly
            const hiddenCount = permissions.length - displayCount;

            return (
                <Space wrap size={[4, 4]}>
                    {permissions.slice(0, displayCount).map((perm: Permission) => (
                        <Tooltip key={perm.id} title={perm.description || perm.code}>
                             <Tag color="geekblue" style={{ cursor: 'help' }}>{perm.code}</Tag>
                        </Tooltip>
                    ))}
                    {hiddenCount > 0 && (
                        <Tooltip title={permissions.slice(displayCount).map(p => p.code).join(', ')}>
                            <Tag>+{hiddenCount} more</Tag>
                        </Tooltip>
                    )}
                    {permissions.length === 0 && <Tag>No Permissions</Tag>}
                </Space>
            );
        },
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 120,
      render: (_: any, record: Role) => (
        <Space size="small">
          <Tooltip title="Edit Role">
            <Button
              type="text"
              icon={<EditOutlined />}
              onClick={() => onEdit(record)}
              aria-label={`Edit role ${record.name}`}
            />
          </Tooltip>
          {/* Prevent deleting core roles like 'admin' if needed */}
          {record.name !== 'admin' && record.name !== 'classifier' && (
              <Popconfirm
                title={`Delete role "${record.name}"?`}
                description="Users assigned only this role will lose its permissions. This cannot be undone."
                onConfirm={() => onDelete(record.id)}
                okText="Delete"
                okType="danger"
                cancelText="Cancel"
              >
                <Tooltip title="Delete Role">
                  <Button
                    type="text"
                    danger
                    icon={<DeleteOutlined />}
                    aria-label={`Delete role ${record.name}`}
                  />
                </Tooltip>
              </Popconfirm>
          )}
        </Space>
      ),
    },
  ];

  return (
    <Table
      rowKey="id"
      columns={columns}
      dataSource={roles}
      loading={loading}
      pagination={false} // Add pagination prop from hook if implemented
      // onChange={(p) => onPageChange(p.current ?? 1, p.pageSize ?? 10)} // Add if paginated
      scroll={{ x: 'max-content' }}
      size="small"
    />
  );
};

File: src/components/BatchJobsTab/BatchJobDetailsModal.tsx
// src/components/BatchJobsTab/BatchJobDetailsModal.tsx
import React, { useMemo, useCallback, useRef, useEffect, memo, JSX } from 'react';
import { Modal, Typography } from 'antd';
// Import necessary types from your API types file
import { BatchClassificationResult, BatchItemResult, CategoryLevel } from '../../api/types'; // Ensure CategoryLevel is imported if used
import { 
    getExecutionStatus, 
    calculateResultStatus, 
    getFormattedErrorMessage,
    isSuccessfulItem,
    isFailedItem,
    isPartialItem,
    isProcessedItem
} from './utils/batchJobUtils'; // Import all utility functions
import { ExecutionStatusBadge, ResultStatusBadge } from './components/JobStatusDisplay'; 
import './BatchJobDetailsModal.css'; // Assuming this exists

// Define Props Interface
interface BatchJobDetailsModalProps {
  job: BatchClassificationResult | null;
  open: boolean;
  onClose: () => void;
}

// Keyboard keys constant
const KEYS = {
  ESCAPE: 'Escape',
  TAB: 'Tab'
} as const;

const formatDuration = (ms: number): string => {
  if (isNaN(ms)) return 'N/A'; // Handle potential NaN
  const seconds = Math.floor(Math.abs(ms) / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) return `${hours}h ${minutes % 60}m`;
  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
  if (seconds >= 0) return `${seconds}s`; // Ensure non-negative seconds are shown
  return '0s'; // Default if calculation is odd
};

const formatDateTime = (dateInput: string | Date | undefined | null): string => {
    if (!dateInput) return 'N/A';
    try {
        const date = typeof dateInput === 'string' ? new Date(dateInput) : dateInput;
        if (isNaN(date.getTime())) { // Check if date is valid
           console.warn("Attempted to format invalid date:", dateInput);
           return 'Invalid Date';
        }
        return date.toLocaleString(undefined, {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    } catch (e) {
        console.error("Error formatting date:", dateInput, e);
        return 'Error';
    }
};


// Component Definition
const BatchJobDetailsModalComponent = ({ job, open, onClose }: BatchJobDetailsModalProps): JSX.Element | null => {
  // Early return if no job or modal not open
  if (!job || !open) return null;

  // Refs for focus management
  const modalRef = useRef<HTMLDivElement>(null);
  const lastFocusedElementRef = useRef<HTMLElement | null>(null);

  // Compute timing information safely
  const timingInfo = useMemo(() => {
        if (!job?.timestamp) {
            return { startTime: 'N/A', endTime: 'N/A', duration: 'N/A' };
        }

        const startTime = new Date(job.timestamp);
        const endTime = job.updated_at ? new Date(job.updated_at) : new Date(); // Use updated_at if available, otherwise fallback to current time.

        const duration = endTime.getTime() - startTime.getTime();

        // Format results
        const formattedStartTime = formatDateTime(startTime);
        const formattedEndTime = formatDateTime(endTime);
        const formattedDuration = formatDuration(duration);

        return {
            startTime: formattedStartTime,
            endTime: formattedEndTime,
            duration: formattedDuration,
        };
    }, [job]);

  // Effect for focus trapping when modal opens/closes
  useEffect(() => {
    let timer: NodeJS.Timeout;
    if (open) {
      lastFocusedElementRef.current = document.activeElement as HTMLElement;
      // Use timeout to ensure modal is fully rendered before focusing
      timer = setTimeout(() => {
          // Check if modalRef.current exists before focusing
          const modalContent = modalRef.current?.querySelector('.ant-modal-content');
          if (modalContent instanceof HTMLElement) {
              modalContent.focus();
          } else {
              modalRef.current?.focus(); // Fallback to modal wrapper
          }
      }, 100);

    } else if (lastFocusedElementRef.current) {
      // Ensure the element still exists and is focusable before focusing
      if (document.body.contains(lastFocusedElementRef.current) && typeof lastFocusedElementRef.current.focus === 'function') {
          lastFocusedElementRef.current.focus();
      }
      lastFocusedElementRef.current = null; // Clear ref after restoring focus or if it's no longer valid
    }
    // Cleanup timer on unmount or when 'open' changes
    return () => clearTimeout(timer);
  }, [open]);

  // Effect for handling keydown events (Escape, Tab)
  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLDivElement>) => { // Add type to event
    switch (e.key) {
      case KEYS.ESCAPE:
        onClose(); // Call the passed onClose function
        break;
      case KEYS.TAB:
        // Focus trapping logic
        if (modalRef.current) {
            // Query within the modalRef element
            const focusableElements = modalRef.current.querySelectorAll<HTMLElement>(
              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements.length > 0) {
              const firstElement = focusableElements[0];
              const lastElement = focusableElements[focusableElements.length - 1];
              const currentActive = document.activeElement as HTMLElement; // Get currently focused element

              if (e.shiftKey) { // Shift + Tab
                if (currentActive === firstElement || !modalRef.current.contains(currentActive)) {
                    // If focus is on the first element or outside the modal, wrap to last
                    e.preventDefault();
                    lastElement.focus();
                }
              } else { // Tab
                 if (currentActive === lastElement || !modalRef.current.contains(currentActive)) {
                    // If focus is on the last element or outside the modal, wrap to first
                    e.preventDefault();
                    firstElement.focus();
                 }
              }
              // Allow normal tab behavior within the modal otherwise
            }
        }
        break;
    }
  }, [onClose]); // Dependency array is correct

  // --- Render Helper Functions ---
  const renderSummary = useCallback(() => {
    const resultsArray = job.results || [];    // Filter to show only processed items
    const processedResults = resultsArray.filter(isProcessedItem);

    // Use refined utils for counting on processed items only
    const successItems = processedResults.filter(isSuccessfulItem).length;
    const partialItems = processedResults.filter(isPartialItem).length;
    const failedItems = processedResults.filter(isFailedItem).length;

    return (
      <div className="mb-6 space-y-4">
        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <div className="rounded-md bg-green-50 p-4 text-center sm:text-left">
            <div className="text-sm font-medium text-green-700">Successful</div>
            <div className="mt-1 text-2xl font-semibold text-green-600">{successItems}</div>
          </div>
          {/* Partial Count */}
          <div className="rounded-md bg-yellow-50 p-4 text-center sm:text-left">
            <div className="text-sm font-medium text-yellow-700">Partial</div>
            <div className="mt-1 text-2xl font-semibold text-yellow-600">{partialItems}</div>
          </div>
          <div className="rounded-md bg-red-50 p-4 text-center sm:text-left">
            <div className="text-sm font-medium text-red-700">Failed</div>
            <div className="mt-1 text-2xl font-semibold text-red-600">{failedItems}</div>
          </div>
        </div>
      </div>
    );
  }, [job]);

  const renderJobInfo = useCallback(() => {
    const executionStatus = getExecutionStatus(job);
    const resultStatus = calculateResultStatus(job);

    return (
      <div className="space-y-4">
        <h3 className="text-lg font-semibold text-secondary-800">Job Information</h3>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Execution Status</div>
            <div className="flex items-center">
              <ExecutionStatusBadge status={executionStatus} />
            </div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Result Status</div>
            <div className="flex items-center">
              <ResultStatusBadge status={resultStatus} />
            </div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Created</div>
            <div className="text-sm text-secondary-700">{timingInfo.startTime}</div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Completed</div>
            <div className="text-sm text-secondary-700">{timingInfo.endTime}</div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Duration</div>
            <div className="text-sm text-secondary-700">{timingInfo.duration}</div>
          </div>          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Batch Size</div>            <div className="text-sm text-secondary-700">
              {job.processedItems !== undefined ? job.processedItems : (job.results || []).filter(isProcessedItem).length} / {(job.results || []).length} items processed
            </div>
          </div>
        </div>
      </div>
    );
  }, [job, timingInfo]);
  const renderResultDetails = useCallback(() => {
    const resultsArray = job.results || [];
    
    // Filter to only show processed items
    const processedResults = resultsArray.filter(isProcessedItem);
    
    if (!resultsArray.length) {
      return <div className="text-center py-8"><p className="text-secondary-600">No results available for this job yet.</p></div>;
    }
    
    if (!processedResults.length) {
      return <div className="text-center py-8"><p className="text-secondary-600">No processed items available yet. Processing is in progress.</p></div>;
    }    return (
      <div className="overflow-x-auto border border-secondary-200 rounded-md">
        <table className="min-w-full divide-y divide-secondary-200">
          <thead className="bg-secondary-50 sticky top-0 z-10"> {/* Make header sticky */}
            <tr>
              <th className="px-4 py-2 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-2/5">Item Description & Context</th>
              <th className="px-4 py-2 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-auto">Status</th>
              <th className="px-4 py-2 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-3/5">Classification / Error</th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-secondary-200">
            {processedResults.map((resultItem: BatchItemResult, index: number) => {
              // Determine individual item status using refined utils
              let status: 'Success' | 'Partial' | 'Failed' = 'Failed'; // Default to Failed
              let statusClass = 'bg-red-100 text-red-800 border-red-200';
              
              if (isSuccessfulItem(resultItem)) {
                status = 'Success';
                statusClass = 'bg-green-100 text-green-800 border-green-200';
              } else if (isPartialItem(resultItem)) {
                status = 'Partial';
                statusClass = 'bg-yellow-100 text-yellow-800 border-yellow-200';
              }
              // isFailedItem is implicitly covered by the default

              return (
                <tr key={index} className="hover:bg-secondary-50 align-top">
                  <td className="px-4 py-2 text-sm text-secondary-900">
                    <div className="font-medium">{resultItem.description || `Item ${index + 1}`}</div>
                    {/* Show key value if present */}
                    {resultItem.key && <p className="text-xs text-amber-700 font-medium mt-1 break-words">Key: {resultItem.key}</p>}
                    {resultItem.additional_context && (<p className="text-xs text-secondary-500 mt-1 break-words">Context: {resultItem.additional_context}</p>)}
                  </td>
                  <td className="px-4 py-2 text-sm">
                    {/* Use determined status and class */}
                    <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium border ${statusClass}`}>
                      {status}
                    </span>
                  </td>
                  <td className="px-4 py-2 text-sm text-secondary-600">
                    {/* Display error OR classification */}
                    {isFailedItem(resultItem) ? (
                      <div className="text-red-600 whitespace-pre-wrap break-words">
                        {getFormattedErrorMessage(resultItem.error || resultItem.result?.error) || 'Classification failed'}
                      </div>
                    ) : resultItem.result ? (
                      <div className="text-sm space-y-1">
                        {Object.entries(resultItem.result.levels || {})
                          // Sort levels by logical order
                          .sort(([a], [b]) => {
                            const levelOrder: Record<string, number> = { 'segment': 1, 'family': 2, 'class': 3, 'commodity': 4, 'SUBCAT1': 1, 'SUBCAT2': 2 };
                            return (levelOrder[a] ?? 99) - (levelOrder[b] ?? 99);
                          })
                          .map(([levelCode, category]: [string, CategoryLevel | undefined]) => (
                            <div key={levelCode}>
                              <span className="font-medium text-secondary-700">{levelCode}:</span>{' '}
                              <span className="text-secondary-600">
                                {category ? `${category.code} - ${category.name}` : 'N/A'}
                                {/* Show level-specific error if present */}
                                {category?.error && (<span className="text-xs text-red-600 ml-2">({category.error})</span>)}
                              </span>
                            </div>
                          ))}
                        {/* Show partial status explanation if applicable */}
                        {status === 'Partial' && !getFormattedErrorMessage(resultItem.error || resultItem.result?.error) && (
                          <p className="text-xs text-yellow-700 mt-1 italic">Result is partial, check levels.</p>
                        )}
                        {/* Display RAG context if available */}
                        {resultItem.result?.ragContextUsed && (
                          <div className="mt-2 border-t border-secondary-200 pt-2">
                            <details className="text-xs">
                              <summary className="text-blue-600 cursor-pointer">RAG Context Used</summary>
                              <div className="mt-1 bg-blue-50 p-2 rounded text-secondary-700 whitespace-pre-wrap">
                                {resultItem.result.ragContext || 'No specific context text available.'}
                              </div>
                            </details>
                          </div>
                        )}
                      </div>
                    ) : (
                      <div className="text-secondary-500">No classification data.</div>
                    )}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    );
  }, [job]);

  // --- Main Render ---
  return (
      <Modal
        title={
          <div className="flex items-center justify-between pr-4">
              <Typography.Title level={4} style={{ margin: 0, flexGrow: 1 }}>
                Batch Job Details
              </Typography.Title>
              <span className="text-sm text-secondary-600 font-mono">
                  ID: {job.id}
              </span>
          </div>
        }
        open={open} // Use 'open' prop for visibility (AntD v5+)
        onCancel={onClose} // Use the correct prop from Ant Design
        keyboard={true}     // Allow closing with ESC
        maskClosable={true} // Allow closing by clicking mask
        footer={null}       // No default footer buttons
        width={1000}        // Set desired width
        // Use 'styles' prop for new AntD versions v5+
        styles={{
            body: {
                maxHeight: 'calc(85vh - 120px)', // Adjust height calculation
                overflowY: 'auto', // Ensure vertical scroll
                padding: '24px' // Add padding to body
            },
            // Ensure header doesn't contribute to scroll height unnecessarily
            header: {
                padding: '16px 24px', // Standard AntD padding
                borderBottom: '1px solid #f0f0f0' // Standard AntD border
            },
            content: {
                padding: 0 // Reset padding if body padding is set
            }
        }}
        destroyOnClose={true} // Optional: Reset internal state when modal closes
        className="batch-details-modal" // Custom class for styling
        // The Modal component itself handles focus trapping. Ref and keydown on wrapper are for custom actions if needed.
        // ref={modalRef} // Not strictly needed for AntD modal focus trapping
        // onKeyDown={handleKeyDown} // Can attach here if Modal supports it, or use wrapper below
      >
          {/* Content Wrapper with Keydown Handler */}
          <div onKeyDown={handleKeyDown} tabIndex={-1} className="focus:outline-none">
             <div className="space-y-6">
                {renderSummary()}
                <div className="border-t border-secondary-200 pt-4">
                    {renderJobInfo()}
                </div>
                 <div className="border-t border-secondary-200 pt-4">                <div className="flex justify-between items-center mb-3">
                    <h3 className="text-lg font-semibold text-secondary-800">Results Breakdown</h3>                    <span className="text-sm text-secondary-500">
                        {`${job.processedItems !== undefined ? job.processedItems : (job.results || []).filter(isProcessedItem).length} of ${(job.results || []).length} items processed`}
                    </span>
                </div>
                    {renderResultDetails()}
                 </div>
             </div>
          </div>
      </Modal>
  );
};

export default memo(BatchJobDetailsModalComponent);

File: src/components/BatchTab/index.ts
// Export all components
export { default as FileUpload } from './FileUpload';
export { default as ColumnSelector } from './ColumnSelector';
export { default as PreviewTable } from './PreviewTable';
export { default as BatchProgress } from './BatchProgress';
export { default as BatchTab } from './BatchTab';
export { default as BatchSummary } from './BatchSummary';

// Export types
export interface BatchTabProps {
  apiClient: any; // Replace with proper API client type
}

export interface ColumnConfig {
  sourceColumn: string;
  contextColumn?: string;
}

export interface PreviewData {
  headers: string[];
  rows: string[][];
  fileName: string;
  fileType: 'csv' | 'excel';
}

export interface SystemConfig {
  system: {
    code: string;
    name: string;
    description?: string;
  };
  levels: Array<{
    code: string;
    name: string;
  }>;
}

File: src/components/BatchJobsTab/components/BatchJobsTable.tsx
// src/components/BatchJobsTab/components/BatchJobsTable.tsx
import React, { useState } from 'react';
import { BatchClassificationResult } from '../../../api/types';
import { JobStatusDisplay } from './JobStatusDisplay';
import { downloadJobReport, DownloadFormat } from '../utils/csvGenerator';

interface BatchJobsTableProps {
    jobs: BatchClassificationResult[];
    onViewDetails: (job: BatchClassificationResult) => void;
}

export const BatchJobsTable: React.FC<BatchJobsTableProps> = ({ jobs, onViewDetails }) => {
    // Track open dropdown state for each job
    const [openDropdown, setOpenDropdown] = useState<string | null>(null);

    // Handle download with specified format
    const handleDownload = (job: BatchClassificationResult, format: DownloadFormat) => {
        // No longer need to normalize keys - we want to preserve decimal suffixes
        downloadJobReport(job, format);
        setOpenDropdown(null); // Close dropdown after action
    };

    // Toggle dropdown visibility
    const toggleDropdown = (jobId: string) => {
        setOpenDropdown(openDropdown === jobId ? null : jobId);
    };

    return (
        <div className="overflow-x-auto rounded-card border border-secondary-200 mb-6">
            <table className="min-w-full divide-y divide-secondary-200">
                <thead className="bg-secondary-50">
                    <tr>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Job ID</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">System</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Exec. Status</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Result Status</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Created</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-52">Progress</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Summary</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Actions</th>
                    </tr>
                </thead>
                <tbody className="bg-white divide-y divide-secondary-200">
                    {jobs.map((job) => (
                        <tr key={job.id} className="hover:bg-secondary-50">
                            {/* Job ID */}
                            <td className="px-4 py-4 whitespace-nowrap text-sm text-secondary-900 font-mono">{job.id}</td>
                            <td className="px-4 py-4 whitespace-nowrap text-sm text-secondary-900">
                                {(job.system_code) ? (
                                    <div className="flex flex-col">
                                        <span className="font-medium">{job.system_code}</span>
                                    </div>
                                ) : (
                                    <span className="text-secondary-400">N/A</span>
                                )}
                            </td>
                            {/* Execution Status, Result Status, Created, Progress, Summary (rendered by JobStatusDisplay) */}
                            <JobStatusDisplay job={job} />
                            {/* Actions */}
                            <td className="px-4 py-4 whitespace-nowrap text-sm">
                                <div className="flex space-x-2">
                                    <button
                                        onClick={() => onViewDetails(job)}
                                        className="btn btn-secondary py-1 px-2 text-xs" // Use global style
                                        aria-label={`View details for job ${job.id}`}
                                    > View </button>
                                    
                                    {/* Download Dropdown */}
                                    <div className="relative">
                                        <button
                                            onClick={() => toggleDropdown(job.id)}
                                            disabled={job.status === 'pending' || job.status === 'processing'}
                                            className="btn btn-secondary py-1 px-2 text-xs text-green-600 border-green-200 hover:bg-green-50 disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
                                            aria-label={`Download options for job ${job.id}`}
                                            aria-expanded={openDropdown === job.id}
                                            aria-haspopup="true"
                                        >
                                            Download
                                            <svg className="ml-1 -mr-1 h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                                <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a 1 1 0 010-1.414z" clipRule="evenodd" />
                                            </svg>
                                        </button>
                                        
                                        {/* Dropdown Menu - Increased width from w-48 to w-64 (33% wider) */}
                                        {openDropdown === job.id && (
                                            <div 
                                                className="origin-top-right absolute right-0 mt-2 w-64 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 divide-y divide-gray-100 focus:outline-none z-10"
                                                role="menu"
                                                aria-orientation="vertical"
                                                aria-labelledby="download-options-menu"
                                            >
                                                <div className="py-1" role="none">
                                                    <button
                                                        onClick={() => handleDownload(job, 'simple')}
                                                        className="text-gray-700 block w-full text-left px-4 py-2 text-sm hover:bg-gray-100"
                                                        role="menuitem"
                                                    >
                                                        Basic (without LLM responses)
                                                    </button>
                                                    <button
                                                        onClick={() => handleDownload(job, 'full')}
                                                        className="text-gray-700 block w-full text-left px-4 py-2 text-sm hover:bg-gray-100"
                                                        role="menuitem"
                                                    >
                                                        Complete (with LLM responses)
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

File: src/components/RagInfoTab/RagInfoTab.tsx
// src/components/RagInfoTab/RagInfoTab.tsx
import React, { useState, useCallback, useRef } from 'react';
import { ApiClient, RagInfoItem, CreateRagInfoRequest, UpdateRagInfoRequest } from '../../api/types'; // Adjust path
import { useRagInfo } from './hooks/useRagInfo';
import { RagInfoFilters } from './components/RagInfoFilters';
import { RagInfoTable } from './components/RagInfoTable';
import { RagInfoPagination } from './components/RagInfoPagination';
import { RagInfoFormModal } from './components/RagInfoFormModal';
import { PlusIcon, ArrowDownTrayIcon, ArrowUpTrayIcon } from '@heroicons/react/24/solid'; // Added ArrowUpTrayIcon
import { useAuth } from '../../context/AuthContext'; // Import useAuth hook
import { message } from 'antd'; // Import message for notifications

interface RagInfoTabProps {
    apiClient: ApiClient;
}

const PAGE_SIZE = 10; // Must match the hook

// Helper function to convert RAG info items to CSV and trigger download
const exportToCSV = (items: RagInfoItem[]): void => {
    const headers = ['Key', 'Description', 'Created At', 'Updated At'];
    const csvContent = [
        headers.join(','),
        ...items.map(item => [
            `"${item.key.replace(/"/g, '""')}"`,
            `"${item.description.replace(/"/g, '""')}"`,
            item.createdAt ? new Date(item.createdAt).toLocaleString() : '',
            item.updatedAt ? new Date(item.updatedAt).toLocaleString() : ''
        ].join(','))
    ].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `rag-info-export-${new Date().toISOString().slice(0, 10)}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
};

// Helper function to parse CSV data into RAG info items
const parseCSV = (csvText: string): CreateRagInfoRequest[] => {
    const lines = csvText.split(/\r?\n/);
    if (lines.length < 2) {
        throw new Error('CSV file is empty or has incorrect format');
    }
    const headers = lines[0].toLowerCase().split(',');
    const keyIndex = headers.findIndex(header => header.trim() === 'key');
    const descriptionIndex = headers.findIndex(header => header.trim() === 'description');
    if (keyIndex === -1 || descriptionIndex === -1) {
        throw new Error('CSV must contain "Key" and "Description" columns');
    }
    const items: CreateRagInfoRequest[] = [];
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        const values: string[] = [];
        let inQuote = false;
        let currentValue = '';
        for (let j = 0; j < line.length; j++) {
            const char = line[j];
            if (char === '"') {
                if (j + 1 < line.length && line[j + 1] === '"') {
                    currentValue += '"';
                    j++;
                } else {
                    inQuote = !inQuote;
                }
            } else if (char === ',' && !inQuote) {
                values.push(currentValue);
                currentValue = '';
            } else {
                currentValue += char;
            }
        }
        values.push(currentValue);
        const key = values[keyIndex]?.trim();
        const description = values[descriptionIndex]?.trim();
        if (key && description) {
            items.push({ key, description });
        }
    }
    return items;
};

export const RagInfoTab: React.FC<RagInfoTabProps> = ({ apiClient }) => {
    const { checkPermission } = useAuth(); // Get permission checker
    
    const {
        items,
        loading,
        error,
        totalCount,
        totalPages,
        currentPage,
        searchTerm,
        setCurrentPage,
        setSearchTerm,
        refreshList,
        createItem,
        updateItem,
        deleteItem,
        fetchAllForExport,
    } = useRagInfo(apiClient);

    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingItem, setEditingItem] = useState<RagInfoItem | undefined>(undefined);
    const [isExporting, setIsExporting] = useState(false);
    const [isImporting, setIsImporting] = useState(false);
    const [importStatus, setImportStatus] = useState<{
        total: number;
        success: number;
        failed: number;
        message?: string;
    } | null>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleAddClick = () => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied."); 
            return; 
        }
        setEditingItem(undefined);
        setIsModalOpen(true);
    };

    const handleEditClick = (item: RagInfoItem) => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied."); 
            return; 
        }
        setEditingItem(item);
        setIsModalOpen(true);
    };

    const handleDeleteClick = async (item: RagInfoItem) => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied."); 
            return; 
        }
        if (window.confirm(`Are you sure you want to delete the item "${item.key}"?`)) {
            await deleteItem(item.id); // deleteItem hook handles loading/error state
        }
    };

    const handleExportClick = async () => {
        if (!checkPermission('rag:view')) { // Use view permission for export
            message.error("Permission denied to export data.");
            return;
        }
        setIsExporting(true);
        try {
            const allItems = await fetchAllForExport(searchTerm);
            if (allItems.length === 0) {
                message.info('No RAG info items to export.');
                return;
            }
            exportToCSV(allItems);
            console.log(`Successfully exported ${allItems.length} RAG info items to CSV`);
        } catch (error) {
            console.error('Error exporting data:', error);
            message.error('Failed to export data. Please try again.');
        } finally {
            setIsExporting(false);
        }
    };

    const handleImportClick = () => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied to import data."); 
            return; 
        }
        if (fileInputRef.current) {
            fileInputRef.current.value = '';
            fileInputRef.current.click();
        }
    };

    const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
        // Permission check already done in handleImportClick
        const file = e.target.files?.[0];
        if (!file) return;
        setIsImporting(true);
        setImportStatus(null);
        try {
            const text = await readFileAsText(file);
            const itemsToImport = parseCSV(text);
            if (itemsToImport.length === 0) {
                throw new Error('No valid items found in the CSV file');
            }
            const importResults = await importItems(itemsToImport);
            setImportStatus({
                total: itemsToImport.length,
                success: importResults.success,
                failed: importResults.failed,
                message: `Successfully imported ${importResults.success} items. ${importResults.failed} items failed.`
            });
            await refreshList();
        } catch (error) {
            console.error('Import error:', error);
            setImportStatus({
                total: 0,
                success: 0,
                failed: 0,
                message: `Import failed: ${error instanceof Error ? error.message : 'Unknown error'}`
            });
        } finally {
            setIsImporting(false);
        }
    };

    const readFileAsText = (file: File): Promise<string> => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target?.result as string);
            reader.onerror = (e) => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        });
    };

    const importItems = async (items: CreateRagInfoRequest[]): Promise<{ success: number; failed: number }> => {
        let success = 0;
        let failed = 0;
        const batchSize = 10;
        for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            const results = await Promise.allSettled(
                batch.map(item => createItem(item))
            );
            results.forEach(result => {
                if (result.status === 'fulfilled' && result.value) {
                    success++;
                } else {
                    failed++;
                }
            });
        }
        return { success, failed };
    };

    const handleModalSubmit = async (data: CreateRagInfoRequest | UpdateRagInfoRequest): Promise<boolean> => {
        // Permissions checked before opening modal, but double-check is safe
        if (!checkPermission('rag:manage')) {
            message.error("Permission denied.");
            return false;
        }
        let success = false;
        if (editingItem) {
            success = !!(await updateItem(editingItem.id, data as UpdateRagInfoRequest));
        } else {
            success = !!(await createItem(data as CreateRagInfoRequest));
        }
        return success;
    };

    return (
        <div className="space-y-6">
            <div className="flex justify-between items-center">
                <div className="flex-grow mr-4">
                    <RagInfoFilters
                        searchTerm={searchTerm}
                        onSearchChange={setSearchTerm}
                        loading={loading}
                    />
                </div>
                <div className="flex space-x-2">
                    <button
                        onClick={handleImportClick}
                        className="btn btn-secondary inline-flex items-center"
                        disabled={loading || isImporting || isExporting || !checkPermission('rag:manage')}
                        title={!checkPermission('rag:manage') ? "Permission denied" : "Import data from CSV file"}
                    >
                        <ArrowUpTrayIcon className={`h-5 w-5 mr-1 ${!checkPermission('rag:manage') ? 'opacity-50' : ''}`} />
                        {isImporting ? 'Importing...' : 'Import CSV'}
                    </button>
                    <input
                        ref={fileInputRef}
                        type="file"
                        accept=".csv"
                        className="hidden"
                        onChange={handleFileChange}
                    />
                    <button
                        onClick={handleExportClick}
                        className="btn btn-secondary inline-flex items-center"
                        disabled={loading || isExporting || isImporting || items.length === 0 || !checkPermission('rag:view')}
                        title={!checkPermission('rag:view') ? "Permission denied" : "Export data to CSV file"}
                    >
                        <ArrowDownTrayIcon className={`h-5 w-5 mr-1 ${!checkPermission('rag:view') ? 'opacity-50' : ''}`} />
                        {isExporting ? 'Exporting...' : 'Export CSV'}
                    </button>
                    <button
                        onClick={handleAddClick}
                        className="btn btn-primary inline-flex items-center"
                        disabled={loading || isImporting || !checkPermission('rag:manage')}
                        title={!checkPermission('rag:manage') ? "Permission denied" : "Add new RAG info item"}
                    >
                        <PlusIcon className={`h-5 w-5 mr-1 ${!checkPermission('rag:manage') ? 'opacity-50' : ''}`} />
                        Add Info
                    </button>
                </div>
            </div>

            {!checkPermission('rag:view') && (
                <div className="rounded-md border border-amber-200 bg-amber-50 p-4 text-sm text-amber-700">
                    You don't have permission to view or manage RAG information items.
                </div>
            )}

            {importStatus && importStatus.message && (
                <div className={`rounded-md border p-4 text-sm ${
                    importStatus.failed > 0 
                    ? 'border-yellow-200 bg-yellow-50 text-yellow-700' 
                    : 'border-green-200 bg-green-50 text-green-700'
                }`}>
                    {importStatus.message}
                </div>
            )}

            {error && (
                <div className="rounded-md border border-red-200 bg-red-50 p-4 text-sm text-red-700">
                    Error: {error}
                </div>
            )}

            <RagInfoTable
                items={items}
                loading={loading}
                onEdit={handleEditClick}
                onDelete={handleDeleteClick}
                canEdit={checkPermission('rag:manage')}
                canDelete={checkPermission('rag:manage')}
            />

            <RagInfoPagination
                currentPage={currentPage}
                totalPages={totalPages}
                totalCount={totalCount}
                pageSize={PAGE_SIZE}
                loading={loading}
                onPageChange={setCurrentPage}
            />

            <RagInfoFormModal
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                onSubmit={handleModalSubmit}
                initialData={editingItem}
                loading={loading}
            />
        </div>
    );
};

File: src/components/BatchJobsTab/utils/csvGenerator.ts
// src/components/BatchJobsTab/utils/csvGenerator.ts
import { saveAs } from 'file-saver';
import { BatchClassificationResult, BatchItemResult, ClassificationError } from '../../../api/types';

// Helper function to escape CSV values
const escapeCsvValue = (value: any): string => {
  if (value === null || value === undefined) return '';
  const stringValue = String(value);
  // More comprehensive check for characters requiring quoting
  const needsQuoting = stringValue.includes(',') ||
                       stringValue.includes('"') ||
                       stringValue.includes('\n') ||
                       stringValue.includes('\r') ||
                       stringValue.includes(';') ||
                       stringValue.includes('\t');
  if (!needsQuoting) return stringValue;
  return `"${stringValue.replace(/"/g, '""')}"`;
};

export type DownloadFormat = 'simple' | 'full';

const splitMultiKey = (key: string = ''): string[] => {
    if (!key) return [''];
    return key.split('|').map(k => k.trim());
};

const getMaxKeyParts = (results: BatchItemResult[]): number => {
    let maxParts = 0;
    if (!results || results.length === 0) return 0;
    for (const item of results) {
        if (item.key) {
            const keyParts = splitMultiKey(item.key);
            maxParts = Math.max(maxParts, keyParts.length);
        }
    }
    return maxParts === 0 && results.some(r => r.key !== undefined && r.key !== null && r.key !== '') ? 1 : maxParts; // If keys exist but are single, still have 1 key column
};

const getKeyHeaders = (job: BatchClassificationResult): string[] => {
    const columnNames = job.keyColumnNames || (job as any).key_column_names;
    if (columnNames && Array.isArray(columnNames) && columnNames.length > 0) {
        return columnNames;
    }
    const resultsArray = job.results || [];
    const maxParts = getMaxKeyParts(resultsArray);
    if (maxParts === 0 && resultsArray.some(item => item.key !== undefined && item.key !== null && item.key !== '')) {
        return ["Key"]; // Fallback for single key column if names not provided
    }
    if (maxParts === 0) return []; // No key columns if no keys
    return Array.from({ length: maxParts }, (_, i) => `Key_${i + 1}`);
};

export const downloadJobReport = (job: BatchClassificationResult, format: DownloadFormat = 'full') => {
    const resultsArray = job.results || [];
    if (resultsArray.length === 0) { alert('No results to download for this job.'); return; }

    try {
        const keyHeaders = getKeyHeaders(job);
        const numKeyColumns = keyHeaders.length;

        const allLevels = new Set<string>();
        resultsArray.forEach(item => { if (item.result?.levels) Object.keys(item.result.levels).forEach(level => allLevels.add(level)); });
        
        const levelOrder: Record<string, number> = {
            'segment': 1, 'family': 2, 'class': 3, 'commodity': 4,
            'subcat1': 1, 'subcat2': 2 // Ensure robust matching for common cats too
        };
        const sortedLevels = Array.from(allLevels).sort((a, b) => 
            ((levelOrder[a.toLowerCase()] ?? 999) - (levelOrder[b.toLowerCase()] ?? 999)) || a.localeCompare(b) // Use toLowerCase for robust key matching
        );

        let headers: string[] = [];
        if (numKeyColumns > 0) { // Only add key headers if there are key columns
            headers.push(...keyHeaders.map(header => escapeCsvValue(header)));
        }
        headers.push(escapeCsvValue('Description'));
        headers.push(escapeCsvValue('Additional_Context'));

        for (const level of sortedLevels) {
            headers.push(escapeCsvValue(`${level}_Code`));
            headers.push(escapeCsvValue(`${level}_Name`));
        }
        
        headers.push(escapeCsvValue('Item_Classification_Status')); // Moved here: Add status for both simple and full

        if (format === 'full') {
            headers.push(escapeCsvValue('RAG_Context_Used'));
            headers.push(escapeCsvValue('RAG_Context_Content'));
            for (const level of sortedLevels) {
                headers.push(escapeCsvValue(`LLM_Response_${level}`));
            }
            headers.push(escapeCsvValue('First_Level_Prompt'));
            headers.push(escapeCsvValue('All_Prompts_Detail_JSON'));
        }
        headers.push(escapeCsvValue('Item_Error_Message'));

        const csvRows = [headers.join(',')];

        resultsArray.forEach(item => {
            const row: string[] = [];
            
            if (numKeyColumns > 0) {
                const keyParts = splitMultiKey(item.key || '');
                for (let i = 0; i < numKeyColumns; i++) {
                    row.push(escapeCsvValue(keyParts[i] || ''));
                }
            }
            
            row.push(escapeCsvValue(item.description));
            row.push(escapeCsvValue(item.additional_context || '')); 

            let itemStatusValue = 'Failed'; 
            if (item.error) { itemStatusValue = 'Failed'; } 
            else if (item.result) { itemStatusValue = item.result.status; }

            for (const level of sortedLevels) {
                const category = item.result?.levels?.[level];
                row.push(escapeCsvValue(category?.code || ''));
                row.push(escapeCsvValue(category?.name || ''));
            }
            
            row.push(escapeCsvValue(itemStatusValue)); // Moved here: Add status value for both simple and full
            
            if (format === 'full') {
                row.push(escapeCsvValue(item.result?.ragContextUsed ? 'Yes' : 'No'));
                row.push(escapeCsvValue(item.result?.ragContext || ''));
                
                const llmReplies = sortedLevels.map(levelCode => 
                    escapeCsvValue(item.result?.levelResponses?.[levelCode] || '')
                );
                row.push(...llmReplies);

                row.push(escapeCsvValue(item.result?.firstLevelPrompt || '')); 
                row.push(escapeCsvValue(item.result?.allPromptsDetail || ''));
            }

            let errorMessage = '';
            if (item.error) {
                errorMessage = typeof item.error === 'string' ? item.error : (item.error as ClassificationError).message || JSON.stringify(item.error);
            } else if (item.result?.error) {
                errorMessage = item.result.error;
            }
            row.push(escapeCsvValue(errorMessage));
            
            csvRows.push(row.join(','));
        });

        const csvContent = csvRows.join('\r\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const formatSuffix = format === 'simple' ? 'simple' : 'full';
        saveAs(blob, `batch_job_${job.id}_${formatSuffix}_report.csv`);

    } catch(error) {
         console.error('[CSV Generator] Error creating download:', error);
         alert(`Failed to generate download file: ${error instanceof Error ? error.message : String(error)}`);
    }
};

File: src/components/BatchJobsTab/components/BatchSummary.tsx
// src/components/BatchJobsTab/components/BatchSummary.tsx
import React, { useMemo } from 'react';
import { Button } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';
import { BatchClassificationResult } from '../../../api/types';
import { isSuccessfulItem, isFailedItem, isPartialItem } from '../utils/batchJobUtils';

interface BatchSummaryProps {
  batchJob: BatchClassificationResult;
  onViewDetails: () => void;
}

export const BatchSummary: React.FC<BatchSummaryProps> = ({ batchJob, onViewDetails }) => {
  const resultsArray = batchJob.results || [];
  const totalItems = resultsArray.length;

  // Calculate counts using our utility functions
  const successCount = useMemo(() => resultsArray.filter(isSuccessfulItem).length, [resultsArray]);
  const partialCount = useMemo(() => resultsArray.filter(isPartialItem).length, [resultsArray]);
  const failedCount = useMemo(() => resultsArray.filter(isFailedItem).length, [resultsArray]);

  // Calculate success and failure rates
  const successRate = totalItems > 0 ? Math.round((successCount / totalItems) * 100) : 0;
  const partialRate = totalItems > 0 ? Math.round((partialCount / totalItems) * 100) : 0;
  const failedRate = totalItems > 0 ? Math.round((failedCount / totalItems) * 100) : 0;

  // Function to split multi-keys into array (separated by |)
  const splitMultiKey = (key: string = ''): string[] => {
    if (!key) return [''];
    return key.split('|').map(k => k.trim());
  };

  // Determines the maximum number of key parts across all items
  const getMaxKeyParts = (results: any[]): number => {
    let maxParts = 1; // Default to at least one key column
    
    for (const item of results) {
      if (item.key) {
        const keyParts = splitMultiKey(item.key);
        maxParts = Math.max(maxParts, keyParts.length);
      }
    }
    
    return maxParts;
  };

  const handleExportCSV = () => {
    // Prepare the CSV data
    let headers = ['Item Number', 'Description', 'Additional Context', 'Status', 'Error'];
    
    // Check if keys exist in the data
    const hasKeys = resultsArray.some(r => r.key);
    const maxKeyParts = hasKeys ? getMaxKeyParts(resultsArray) : 0;
    
    // Add key columns if needed
    if (hasKeys && maxKeyParts > 0) {
      const keyHeaders = Array.from({ length: maxKeyParts }, (_, i) => `Key_${i+1}`);
      headers = [...keyHeaders, ...headers];
    }
    
    // Add category levels for UNSPSC or Common Categories
    const systemCode = batchJob.system_code || '';
    if (systemCode.toUpperCase().includes('UNSPSC')) {
      headers = [...headers, 'Segment Code', 'Segment Name', 'Family Code', 'Family Name', 
                 'Class Code', 'Class Name', 'Commodity Code', 'Commodity Name'];
    } else {
      headers = [...headers, 'SUBCAT1 Code', 'SUBCAT1 Name', 'SUBCAT2 Code', 'SUBCAT2 Name'];
    }
    
    // Convert data to CSV format
    const csvContent = [
      headers.join(','),
      ...resultsArray.map((item, index) => {
        // Determine item status
        let status = 'Failed';
        if (isSuccessfulItem(item)) {
          status = 'Success';
        } else if (isPartialItem(item)) {
          status = 'Partial';
        }
        
        // Get level data if available
        const levels = item.result?.levels || {};
        
        // Format description and context - escape quotes and commas
        const escapedDescription = item.description ? `"${item.description.replace(/"/g, '""')}"` : '';
        const escapedContext = item.additional_context ? `"${item.additional_context.replace(/"/g, '""')}"` : '';
        
        // Format error - escape quotes and commas
        const error = item.error || item.result?.error || '';
        const errorText = typeof error === 'string' ? error : (error?.message || '');
        const escapedError = errorText ? `"${errorText.replace(/"/g, '""')}"` : '';
        
        const row = [];
        
        // Add key parts if needed
        if (hasKeys && maxKeyParts > 0) {
          const keyParts = splitMultiKey(item.key || '');
          // Fill in key columns - add empty strings for missing parts
          for (let i = 0; i < maxKeyParts; i++) {
            row.push(keyParts[i] || '');
          }
        }
        
        // Add standard fields
        row.push(index + 1);
        row.push(escapedDescription);
        row.push(escapedContext);
        row.push(status);
        row.push(escapedError);
        
        // Extract level data based on system
        if (systemCode.toUpperCase().includes('UNSPSC')) {
          // UNSPSC system
          const segment = levels.segment || {};
          const family = levels.family || {};
          const classLevel = levels.class || {};
          const commodity = levels.commodity || {};
          
          row.push(segment.code || '');
          row.push(`"${(segment.name || '').replace(/"/g, '""')}"`);
          row.push(family.code || '');
          row.push(`"${(family.name || '').replace(/"/g, '""')}"`);
          row.push(classLevel.code || '');
          row.push(`"${(classLevel.name || '').replace(/"/g, '""')}"`);
          row.push(commodity.code || '');
          row.push(`"${(commodity.name || '').replace(/"/g, '""')}"`);
        } else {
          // Common Categories system
          const subcat1 = levels.SUBCAT1 || {};
          const subcat2 = levels.SUBCAT2 || {};
          
          row.push(subcat1.code || '');
          row.push(`"${(subcat1.name || '').replace(/"/g, '""')}"`);
          row.push(subcat2.code || '');
          row.push(`"${(subcat2.name || '').replace(/"/g, '""')}"`);
        }
        
        return row.join(',');
      })
    ].join('\n');
    
    // Create and trigger download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `batch-results-${batchJob.id}-${new Date().toISOString().slice(0, 10)}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="bg-white rounded-md border border-secondary-200 shadow-card p-6">
      <div className="flex justify-between mb-6">
        <h3 className="text-lg font-semibold text-secondary-900">Batch Results</h3>
        <div className="flex gap-3">
          <Button
            icon={<DownloadOutlined />}
            onClick={handleExportCSV}
          >
            Export CSV
          </Button>
          <Button type="primary" onClick={onViewDetails}>
            View Details
          </Button>
        </div>
      </div>
      
      <div className="mb-6">
        <div className="h-3 w-full rounded-full bg-secondary-100 overflow-hidden">
          <div className="h-full bg-green-500" style={{ width: `${successRate}%`, float: 'left' }}></div>
          <div className="h-full bg-yellow-500" style={{ width: `${partialRate}%`, float: 'left' }}></div>
          <div className="h-full bg-red-500" style={{ width: `${failedRate}%`, float: 'left' }}></div>
        </div>
        <div className="flex justify-between mt-1 text-sm">
          <span className="text-green-600 font-medium">{successCount} successful ({successRate}%)</span>
          {partialCount > 0 && (
            <span className="text-yellow-600 font-medium">{partialCount} partial ({partialRate}%)</span>
          )}
          <span className="text-red-600 font-medium">{failedCount} failed ({failedRate}%)</span>
        </div>
      </div>
      
      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
        {/* Successful Items */}
        <div className="rounded-md bg-green-50 p-4">
          <div className="text-sm font-medium text-green-700 mb-1">Successful</div>
          <div className="text-2xl font-semibold text-green-600">{successCount}</div>
          <div className="text-xs text-green-600 mt-1">Items classified with all levels</div>
        </div>
        
        {/* Partial Items */}
        <div className="rounded-md bg-yellow-50 p-4">
          <div className="text-sm font-medium text-yellow-700 mb-1">Partial</div>
          <div className="text-2xl font-semibold text-yellow-600">{partialCount}</div>
          <div className="text-xs text-yellow-600 mt-1">Items classified with some levels</div>
        </div>
        
        {/* Failed Items */}
        <div className="rounded-md bg-red-50 p-4">
          <div className="text-sm font-medium text-red-700 mb-1">Failed</div>
          <div className="text-2xl font-semibold text-red-600">{failedCount}</div>
          <div className="text-xs text-red-600 mt-1">Items that could not be classified</div>
        </div>
      </div>
    </div>
  );
};

File: src/components/BatchTab/types.ts
// Types for BatchTab functionality

import { ClassificationSystem, BatchStatus as ApiBatchStatus } from "../../api/types";

export interface PreviewData {
    headers: string[];
    rows: string[][];
    fileName: string;
    fileType: 'csv' | 'excel';
}

export interface ResultColumn {
    levelCode: string;
    levelName: string;
    codeColumn: string;
    nameColumn: string;
    isNewColumn: boolean;
}

export interface ColumnConfig {
    // Original properties
    descriptionColumnIndex: number;
    contextColumnIndex?: number;
    keyColumnIndex?: number;
    multiKeyIndices?: number[];
    
    // New properties being used in components
    sourceColumn: string;
    contextColumn?: string;
    keyColumns: string[];
    resultColumns: ResultColumn[];
}

export interface BatchTabProps {
    availableSystems: { system: ClassificationSystem }[];
    apiClient: any; // TODO: Replace with proper API client type
}

// Specialized types for key handling
export interface MultiKey {
    original: string;
    normalized: string;
    parts: string[];
}

// Key processing utilities
export const normalizeDecimalKey = (key: string): string => {
    // Simply return the key as is - we're no longer normalizing decimal suffixes
    return key;
};

export const splitMultiKey = (key: string): string[] => {
    if (!key) return [];
    return key.split('|');
};

export const processMultiKey = (key: string): MultiKey => {
    if (!key) return { original: '', normalized: '', parts: [] };
    
    const normalized = normalizeDecimalKey(key);
    const parts = splitMultiKey(normalized);
    
    return {
        original: key,
        normalized,
        parts
    };
}

// Define and export the filter type
export type BatchJobStatusFilterType = ApiBatchStatus | 'all' | 'partial';

export interface SystemConfig {
    system: ClassificationSystem;
    levels: Array<{
        code: string;
        name: string;
        description?: string;
    }>;
}

export interface BatchJobStatus {
    batchId: string | null;
    isProcessing: boolean;
}

File: src/components/RoleManagement/components/RoleFormModal.tsx
// src/components/RoleManagement/components/RoleFormModal.tsx
import React, { useEffect, useState } from 'react';
import { Modal, Form, Input, Select, Button, Spin, Alert, Checkbox, Row, Col, Tooltip, message } from 'antd';
import { Role, Permission, CreateRoleRequest, UpdateRoleRequest } from '../../../api/types';

interface RoleFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: CreateRoleRequest | UpdateRoleRequest) => Promise<boolean>; // Returns success status
  initialData?: Role;
  availablePermissions: Permission[];
  loading: boolean; // Loading state for submission
  loadingPermissions: boolean; // Loading state for permissions list
}

const { Option } = Select;

export const RoleFormModal: React.FC<RoleFormModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  initialData,
  availablePermissions,
  loading,
  loadingPermissions,
}) => {
  const [form] = Form.useForm();
  const [formError, setFormError] = useState<string | null>(null);

  const isEditMode = !!initialData;
  const isCoreRole = isEditMode && (initialData?.name === 'admin' || initialData?.name === 'classifier');

  useEffect(() => {
    if (isOpen) {
      setFormError(null);
      if (isEditMode && initialData) {
        form.setFieldsValue({
          name: initialData.name,
          description: initialData.description || '',
          permissions: (initialData.permissions || []).map(p => p.code), // Set codes for Checkbox.Group
        });
      } else {
        form.resetFields();
      }
    }
  }, [isOpen, initialData, form, isEditMode]);

  const handleFinish = async (values: any) => {
    setFormError(null);
    const permissionCodes = values.permissions || [];

    let success = false;
    if (isEditMode && initialData) {
      const updateData: UpdateRoleRequest = {
        name: values.name !== initialData.name ? values.name : undefined, // Only send if changed
        description: values.description !== (initialData.description || '') ? values.description : undefined,
        permissions: permissionCodes, // Always send permissions array
      };
       // Filter out undefined fields
       const filteredUpdateData = Object.fromEntries(
           Object.entries(updateData).filter(([_, v]) => v !== undefined)
       ) as UpdateRoleRequest;

        // Check if anything changed (permissions comparison needs care)
        const initialPermCodes = (initialData.permissions || []).map(p => p.code).sort();
        const currentPermCodes = [...permissionCodes].sort();
        const permsChanged = JSON.stringify(initialPermCodes) !== JSON.stringify(currentPermCodes);

        if (Object.keys(filteredUpdateData).length === 0 && !permsChanged) {
            message.info("No changes detected.");
            onClose();
            return;
        }
        // If only permissions changed, ensure the permissions field is included
        if (Object.keys(filteredUpdateData).length === 0 && permsChanged) {
            filteredUpdateData.permissions = permissionCodes;
        }


      success = await onSubmit(filteredUpdateData);
    } else {
      const createData: CreateRoleRequest = {
        name: values.name,
        description: values.description || undefined,
        permissions: permissionCodes,
      };
      success = await onSubmit(createData);
    }

    if (success) {
      onClose();
    } else {
      setFormError("Failed to save role. Please check the console for details.");
    }
  };

  return (
    <Modal
      title={isEditMode ? `Edit Role: ${initialData?.name}` : 'Create New Role'}
      open={isOpen}
      onCancel={onClose}
      confirmLoading={loading}
      destroyOnClose
      footer={[
        <Button key="back" onClick={onClose} disabled={loading}>
          Cancel
        </Button>,
        <Button key="submit" type="primary" loading={loading} onClick={() => form.submit()}>
          {isEditMode ? 'Save Changes' : 'Create Role'}
        </Button>,
      ]}
      width={700} // Wider modal for permissions
    >
      <Spin spinning={loading || loadingPermissions}>
        {formError && <Alert message={formError} type="error" showIcon closable onClose={() => setFormError(null)} className="mb-4" />}
        <Form
          form={form}
          layout="vertical"
          onFinish={handleFinish}
          name="roleForm"
        >
          <Form.Item
            name="name"
            label="Role Name"
            rules={[{ required: true, message: 'Please input the role name!' }]}
          >
            <Input placeholder="Enter role name (e.g., data_viewer)" disabled={isCoreRole} />
            {isCoreRole && <p className="text-xs text-amber-600 mt-1">Core role names cannot be changed.</p>}
          </Form.Item>

          <Form.Item
            name="description"
            label="Description"
          >
            <Input.TextArea rows={2} placeholder="Optional: Describe the role's purpose" />
          </Form.Item>

          <Form.Item
            name="permissions"
            label="Permissions"
             rules={[{ type: 'array' }]}
          >
            <Checkbox.Group style={{ width: '100%' }}>
                <Row gutter={[8, 8]}>
                    {availablePermissions.sort((a, b) => a.code.localeCompare(b.code)).map(perm => (
                        <Col span={12} key={perm.id}>
                           <Tooltip title={perm.description || perm.code} placement="right">
                             <Checkbox value={perm.code} disabled={isCoreRole && perm.code !== 'config:update' && perm.code !== 'classify:item'}> {/* Example: prevent removing most admin perms */}
                                {perm.code}
                             </Checkbox>
                           </Tooltip>
                        </Col>
                    ))}
                     {availablePermissions.length === 0 && !loadingPermissions && (
                        <Col span={24}><Alert message="No permissions found or failed to load." type="warning" showIcon /></Col>
                    )}
                 </Row>
            </Checkbox.Group>
            {isCoreRole && <p className="text-xs text-amber-600 mt-1">Permissions for core roles ('admin', 'classifier') cannot be modified significantly.</p>}
          </Form.Item>

        </Form>
      </Spin>
    </Modal>
  );
};

File: src/components/BatchJobsTab/BatchJobsTab.tsx
// src/components/BatchJobsTab/BatchJobsTab.tsx
import React, { useState, useCallback, useRef, useEffect } from 'react';
import type { JSX } from 'react';
import { Spin } from 'antd';
import { ApiClient, BatchClassificationResult } from '../../api/types';
import { ExecutionStatusFilterType, ResultStatusFilterType, getExecutionStatus, calculateResultStatus } from './utils/batchJobUtils';
import BatchJobDetailsModal from './BatchJobDetailsModal';
import { BatchJobsFilters } from './components/BatchJobsFilters';
import { BatchJobsTable } from './components/BatchJobsTable';

interface BatchJobsTabProps {
  apiClient: ApiClient;
}

export const BatchJobsTab = ({ apiClient }: BatchJobsTabProps): JSX.Element => {
  const mountedRef = useRef(true);
  const [jobs, setJobs] = useState<BatchClassificationResult[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [cursor, setCursor] = useState<string | undefined>(undefined);
  const [currentPage, setCurrentPage] = useState(1);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | undefined>(undefined);
  const [selectedJob, setSelectedJob] = useState<BatchClassificationResult | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [pageSize] = useState(10);
  const [totalPages, setTotalPages] = useState(1);

  const [selectedExecutionStatus, setSelectedExecutionStatus] = useState<ExecutionStatusFilterType>('all');
  const [selectedResultStatus, setSelectedResultStatus] = useState<ResultStatusFilterType>('all');
  const [startDate, setStartDate] = useState<string>(() => {
    const d = new Date();
    d.setDate(d.getDate() - 7);
    return d.toISOString().split('T')[0];
  });
  const [endDate, setEndDate] = useState<string>(() => new Date().toISOString().split('T')[0]);

  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const requestIdRef = useRef(0);
  const isInitialMount = useRef(true);
  const loadingRef = useRef(loading);

  // Safe state updates
  const safeSetJobs = useCallback((data: BatchClassificationResult[]) => {
    if (mountedRef.current) setJobs(data);
  }, []);
  const safeSetTotalCount = useCallback((count: number) => {
    if (mountedRef.current) setTotalCount(count);
  }, []);
  const safeSetCursor = useCallback((newCursor: string | undefined) => {
    if (mountedRef.current) setCursor(newCursor);
  }, []);
  const safeSetLoading = useCallback((isLoading: boolean) => {
    if (mountedRef.current) {
      setLoading(isLoading);
      loadingRef.current = isLoading;
    }
  }, []);
  const safeSetError = useCallback((err: string | undefined) => {
    if (mountedRef.current) setError(err);
  }, []);

  // Component lifecycle
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
      requestIdRef.current++;
    };
  }, []);

  // Load jobs data
  const loadJobs = useCallback(async (pageToLoad: number, cursorToUse: string | undefined) => {
    const currentRequestId = ++requestIdRef.current;
    if (!loadingRef.current) {
      safeSetLoading(true);
    }
    safeSetError(undefined);

    try {
      const formattedStartDate = startDate ? new Date(startDate).toISOString() : undefined;
      const formattedEndDate = endDate ? new Date(endDate + 'T23:59:59.999Z').toISOString() : undefined;

      const result = await apiClient.getBatchJobs({
        cursor: cursorToUse,
        limit: pageSize,
        status: selectedExecutionStatus === 'all' ? undefined : selectedExecutionStatus,
        startDate: formattedStartDate,
        endDate: formattedEndDate,
      });

      // Debug the raw response from the backend
      console.log('Batch jobs API response:', result);
      console.log('First job totalItems value:', result.items?.[0]?.totalItems);

      if (!mountedRef.current || currentRequestId !== requestIdRef.current) {
        return;
      }

      const resultItems = result.items || [];
      // Apply client-side filtering for result status
      const filteredItems = selectedResultStatus !== 'all'
        ? resultItems.filter(job => {
            if (getExecutionStatus(job) === 'pending' || getExecutionStatus(job) === 'processing') {
              return false;
            }
            return calculateResultStatus(job) === selectedResultStatus;
          })
        : resultItems;

      safeSetJobs(filteredItems);
      safeSetTotalCount(result.totalCount || 0);
      safeSetCursor(result.nextCursor);
      const newTotalPages = Math.ceil((result.totalCount || 0) / pageSize);
      setTotalPages(newTotalPages > 0 ? newTotalPages : 1);
      safeSetLoading(false);

    } catch (err) {
      if (mountedRef.current && currentRequestId === requestIdRef.current) {
        safeSetError('Failed to load batch jobs: ' + (err instanceof Error ? err.message : 'Unknown error'));
        safeSetJobs([]);
        safeSetTotalCount(0);
        safeSetCursor(undefined);
        setTotalPages(1);
        safeSetLoading(false);
      }
    }
  }, [apiClient, startDate, endDate, selectedExecutionStatus, selectedResultStatus, pageSize, safeSetLoading, safeSetError, safeSetJobs, safeSetTotalCount, safeSetCursor]);

  // Reset page when filters change
  useEffect(() => {
    if (!isInitialMount.current) {
      setCurrentPage(1);
      setCursor(undefined);
    }
  }, [selectedExecutionStatus, selectedResultStatus, startDate, endDate]);

  // Load data when page changes
  useEffect(() => {
    loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
    if (isInitialMount.current) {
      isInitialMount.current = false;
    }
  }, [currentPage, cursor, loadJobs]);

  // Polling for active jobs
  const refreshJobs = useCallback(async () => {
    await loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
  }, [loadJobs, currentPage, cursor]);

  useEffect(() => {
    const hasActiveJobs = jobs.some(job => 
      getExecutionStatus(job) === 'processing' || getExecutionStatus(job) === 'pending'
    );

    if (hasActiveJobs && !loadingRef.current && !pollIntervalRef.current) {
      pollIntervalRef.current = setInterval(refreshJobs, 5000);
    } else if (!hasActiveJobs && pollIntervalRef.current) {
      clearInterval(pollIntervalRef.current);
      pollIntervalRef.current = null;
    }

    return () => {
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
    };
  }, [jobs, refreshJobs]);

  // Pagination handler
  const handlePageChange = useCallback((newPage: number) => {
    if (loadingRef.current || newPage < 1 || newPage > totalPages || newPage === currentPage) return;
    setCurrentPage(newPage);
  }, [currentPage, totalPages]);

  return (
    <div className="max-w-8xl mx-auto space-y-6" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem' }}>
      {/* Filters */}
      <div className="bg-white shadow-card rounded-card p-6 w-full">
        <BatchJobsFilters
          selectedExecutionStatus={selectedExecutionStatus}
          selectedResultStatus={selectedResultStatus}
          startDate={startDate}
          endDate={endDate}
          onExecutionStatusChange={setSelectedExecutionStatus}
          onResultStatusChange={setSelectedResultStatus}
          onStartDateChange={setStartDate}
          onEndDateChange={setEndDate}
          loading={loadingRef.current}
        />
      </div>

      {/* Main Content */}
      <div className="bg-white shadow-card rounded-card p-6 w-full">
        {error && (
          <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3 mb-4" role="alert">
            <p className="text-sm text-red-700">{error}</p>
          </div>
        )}

        {loadingRef.current && jobs.length === 0 && (
          <div className="text-center py-8">
            <div className="flex justify-center">
              <Spin size="large" />
              <span className="ml-3">Loading jobs...</span>
            </div>
          </div>
        )}

        {!loadingRef.current && jobs.length === 0 && !error && (
          <div className="text-center py-8 text-sm text-secondary-500">
            No batch jobs found.
          </div>
        )}

        {jobs.length > 0 && (
          <>
            <BatchJobsTable
              jobs={jobs}
              onViewDetails={(job) => {
                setSelectedJob(job);
                setIsModalOpen(true);
              }}
            />

            {/* Always show pagination when we have jobs */}
            {jobs.length > 0 && (
              <div className="mt-6 flex items-center justify-between">
                <div className="flex-1 flex justify-between items-center">
                  <p className="text-sm text-secondary-600">
                    Showing {Math.min((currentPage - 1) * pageSize + 1, totalCount || jobs.length)} - {Math.min(currentPage * pageSize, totalCount || jobs.length)} of {totalCount || jobs.length} results
                  </p>
                  
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => handlePageChange(1)}
                      disabled={currentPage === 1 || loading}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      First
                    </button>
                    
                    <button
                      onClick={() => handlePageChange(currentPage - 1)}
                      disabled={currentPage === 1 || loading}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Previous
                    </button>

                    {(() => {
                      const pages = [];
                      const maxButtons = 5;
                      let start = Math.max(1, currentPage - Math.floor(maxButtons / 2));
                      let end = Math.min(start + maxButtons - 1, totalPages);

                      // Adjust start if we're at the end
                      if (end === totalPages) {
                        start = Math.max(1, end - maxButtons + 1);
                      }

                      // Show dots at start if needed
                      if (start > 1) {
                        pages.push(
                          <span key="start-dots" className="px-2 py-2 text-secondary-500">...</span>
                        );
                      }

                      // Page numbers
                      for (let i = start; i <= end; i++) {
                        pages.push(
                          <button
                            key={i}
                            onClick={() => handlePageChange(i)}
                            disabled={loading || (i > currentPage && !cursor)}
                            className={`px-3 py-2 rounded-lg border text-sm font-medium ${
                              i === currentPage
                                ? 'bg-primary-600 text-white border-primary-600'
                                : 'border-secondary-200 text-secondary-700 hover:bg-secondary-50'
                            }`}
                          >
                            {i}
                          </button>
                        );
                      }

                      // Show dots at end if needed
                      if (end < totalPages) {
                        pages.push(
                          <span key="end-dots" className="px-2 py-2 text-secondary-500">...</span>
                        );
                      }

                      return pages;
                    })()}

                    <button
                      onClick={() => handlePageChange(currentPage + 1)}
                      disabled={currentPage === totalPages || loading || !cursor}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Next
                    </button>
                    
                    <button
                      onClick={() => handlePageChange(totalPages)}
                      disabled={currentPage === totalPages || loading}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Last
                    </button>
                  </div>
                </div>
              </div>
            )}
          </>
        )}

        {/* Job Details Modal */}
        <BatchJobDetailsModal
          job={selectedJob}
          open={isModalOpen}
          onClose={() => {
            setSelectedJob(null);
            setIsModalOpen(false);
          }}
        />
      </div>
    </div>
  );
};

export default BatchJobsTab;

File: src/api/auth.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore, AUTH_TOKEN_KEY, USER_INFO_KEY } from './core-client';
import { LoginResponse, User } from './types';

export class AuthService {
  constructor(private core: ApiClientCore) {}

  isLoggedIn(): boolean {
    const token = localStorage.getItem(AUTH_TOKEN_KEY);
    return !!token;
  }

  isAuthEnabled(): boolean | null {
    return this.core.authEnabled;
  }

  async login(username: string, password: string): Promise<LoginResponse> {
    const requestId = Math.random().toString(36).substring(7);
    console.log(`[${requestId}] Logging in user: ${username}`);
    try {
      const response = await this.core.fetchWithTimeout(formatEndpoint('/auth/login'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      });
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: response.statusText || 'Login failed' }));
        throw new Error(error.error || 'Authentication failed');
      }
      const result = await response.json();
      if (result.token) {
        localStorage.setItem(AUTH_TOKEN_KEY, result.token);
        if (result.user) {
          localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));
        }
      } else {
        throw new Error('Authentication response missing token');
      }
      return result;
    } catch (error) {
      console.error(`[${requestId}] Login error:`, error);
      throw error;
    }
  }

  clearToken(): void {
    localStorage.removeItem(AUTH_TOKEN_KEY);
    localStorage.removeItem(USER_INFO_KEY);
    console.log('User logged out, token and user info cleared');
  }

  async getCurrentUser(): Promise<User> {
    const cachedUser = this.core.getCurrentUserInfo();
    if (cachedUser && cachedUser.permissions) {
      return cachedUser;
    }
    const url = formatEndpoint('/auth/me');
    try {
      const response = await this.core.fetchWithTimeout(url);
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: response.statusText }));
        throw new Error(error.error || "Failed to get current user information");
      }
      const user = await response.json();
      localStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
      return user;
    } catch (error) {
      console.error("Error fetching current user:", error);
      throw error;
    }
  }
}

File: src/components/BatchJobsTab/hooks/useBatchJobs.ts
// src/components/BatchJobsTab/hooks/useBatchJobs.ts
import { useState, useEffect, useRef, useCallback } from 'react';
import { ApiClient, BatchClassificationResult, BatchJobParams } from '../../../api/types'; // Adjust import
import { BatchJobStatusFilterType } from '../../BatchTab/types'; // Adjust import if type moved

export interface UseBatchJobsResult {
    jobs: BatchClassificationResult[];
    loading: boolean;
    error: string | undefined;
    totalCount: number;
    totalPages: number;
    currentPage: number;
    selectedStatus: BatchJobStatusFilterType;
    startDate: string;
    endDate: string;
    cursor: string | undefined;
    setSelectedStatus: React.Dispatch<React.SetStateAction<BatchJobStatusFilterType>>;
    setStartDate: React.Dispatch<React.SetStateAction<string>>;
    setEndDate: React.Dispatch<React.SetStateAction<string>>;
    setCurrentPage: React.Dispatch<React.SetStateAction<number>>;
    refreshJobs: () => Promise<void>;
}

const POLLING_INTERVAL = 5000;
const PAGE_SIZE = 10;

export function useBatchJobs(apiClient: ApiClient): UseBatchJobsResult {
    const mountedRef = useRef(true);
    const [jobs, setJobs] = useState<BatchClassificationResult[]>([]);
    const [totalCount, setTotalCount] = useState(0);
    const [cursor, setCursor] = useState<string | undefined>(undefined);
    const [currentPage, setCurrentPage] = useState(1);
    const [loading, setLoading] = useState(true); // Start loading true
    const [error, setError] = useState<string | undefined>(undefined);
    const [totalPages, setTotalPages] = useState(1);

    const [selectedStatus, setSelectedStatus] = useState<BatchJobStatusFilterType>('all');
    const [startDate, setStartDate] = useState<string>(() => { const d = new Date(); d.setDate(d.getDate() - 7); return d.toISOString().split('T')[0]; });
    const [endDate, setEndDate] = useState<string>(() => new Date().toISOString().split('T')[0]);

    const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
    const requestIdRef = useRef(0);
    const isInitialMount = useRef(true);
    const loadingRef = useRef(loading);

    // --- Use specific safe setters ---
    const safeSetJobs = useCallback((data: BatchClassificationResult[]) => { if (mountedRef.current) setJobs(data); }, []);
    const safeSetTotalCount = useCallback((count: number) => { if (mountedRef.current) setTotalCount(count); }, []);
    const safeSetCursor = useCallback((newCursor: string | undefined) => { if (mountedRef.current) setCursor(newCursor); }, []);
    const safeSetCurrentPage = useCallback((page: number | ((prevPage: number) => number)) => { if (mountedRef.current) setCurrentPage(page); }, []);
    const safeSetTotalPages = useCallback((pages: number) => { if (mountedRef.current) setTotalPages(pages); }, []);
    const safeSetLoading = useCallback((isLoading: boolean) => { if (mountedRef.current) { setLoading(isLoading); loadingRef.current = isLoading; } }, []);
    const safeSetError = useCallback((err: string | undefined) => { if (mountedRef.current) setError(err); }, []);
    // --- End specific safe setters ---

    // Lifecycle
    useEffect(() => {
        mountedRef.current = true;
        return () => { mountedRef.current = false; if (pollIntervalRef.current) clearInterval(pollIntervalRef.current); requestIdRef.current++; };
    }, []);

    // Core loading logic
    const loadJobs = useCallback(async (pageToLoad: number, cursorToUse: string | undefined) => {
        const currentRequestId = ++requestIdRef.current;
        console.log(`[useBatchJobs loadJobs ${currentRequestId}] Req Start. Page: ${pageToLoad}, Cursor: ${cursorToUse}`);
        if (!loadingRef.current) { safeSetLoading(true); }
        safeSetError(undefined); // Use specific safe setter
        try {
            const params: BatchJobParams = {
                cursor: cursorToUse, limit: PAGE_SIZE, status: selectedStatus === 'all' ? undefined : selectedStatus,
                startDate: startDate ? new Date(startDate).toISOString() : undefined,
                endDate: endDate ? new Date(endDate + 'T23:59:59.999Z').toISOString() : undefined,
            };
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] Calling API with params:`, params);
            const result = await apiClient.getBatchJobs(params);
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] API call successful.`);
            if (!mountedRef.current || currentRequestId !== requestIdRef.current) { console.log(`[useBatchJobs loadJobs ${currentRequestId}] Discarded.`); return; }
            if (!result) throw new Error('No response data');
            const items = result.items || [];
            const total = result.totalCount || 0;
            const nextCursor = result.nextCursor;
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] Processing result: Items=${items.length}, Total=${total}, NextCursor=${nextCursor}`);

            // Use specific safe setters
            safeSetJobs(items);
            safeSetTotalCount(total);
            safeSetCursor(nextCursor);
            const newTotalPages = Math.ceil(total / PAGE_SIZE);
            safeSetTotalPages(newTotalPages > 0 ? newTotalPages : 1); // Use specific safe setter

            safeSetLoading(false);
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] State updated, loading=false.`);
        } catch (err) {
            console.error(`[useBatchJobs loadJobs ${currentRequestId}] Error:`, err);
            if (mountedRef.current && currentRequestId === requestIdRef.current) {
                // Use specific safe setters
                safeSetError('Failed to load: ' + (err instanceof Error ? err.message : 'Unknown error'));
                safeSetJobs([]);
                safeSetTotalCount(0);
                safeSetCursor(undefined);
                safeSetTotalPages(1); // Use specific safe setter
                safeSetLoading(false);
                console.log(`[useBatchJobs loadJobs ${currentRequestId}] Error state set, loading=false.`);
            } else { console.log(`[useBatchJobs loadJobs ${currentRequestId}] Error ignored.`); }
        }
     // Update dependencies to use specific safe setters
    }, [apiClient, startDate, endDate, selectedStatus, PAGE_SIZE, safeSetLoading, safeSetError, safeSetJobs, safeSetTotalCount, safeSetCursor, safeSetTotalPages]);

    // Effect to reset page when filters change
    useEffect(() => {
        if (!isInitialMount.current) {
            console.log('[useBatchJobs] Filters changed, resetting to page 1.');
            // Use specific safe setters
            safeSetCurrentPage(1);
            safeSetCursor(undefined);
        }
     // Update dependencies to use specific safe setters
    }, [selectedStatus, startDate, endDate, safeSetCurrentPage, safeSetCursor]);

    // Effect for loading data when page changes OR after filters force page reset
    useEffect(() => {
        console.log('[useBatchJobs] Load trigger effect running for page:', currentPage);
        loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
        if (isInitialMount.current) isInitialMount.current = false;
    }, [currentPage, cursor, loadJobs]); // Include loadJobs dependency

    // Refresh current page data
    const refreshJobs = useCallback(async () => {
        console.log('[useBatchJobs refreshJobs] Refreshing current page:', currentPage);
        await loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
    }, [loadJobs, currentPage, cursor]);

    // Effect for polling active jobs
    useEffect(() => {
        const hasActiveJobs = jobs.some(job => job.status === 'processing' || job.status === 'pending');
        const setupPollingInterval = () => {
            if (!pollIntervalRef.current) {
                console.log('[useBatchJobs Polling] Starting interval.');
                pollIntervalRef.current = setInterval(() => {
                    if (!loadingRef.current) { console.log('[useBatchJobs Polling] Refreshing...'); refreshJobs(); }
                    else { console.log('[useBatchJobs Polling] Skipping refresh: loading.'); }
                }, POLLING_INTERVAL);
            }
        };
        const clearPollingInterval = () => {
            if (pollIntervalRef.current) { console.log('[useBatchJobs Polling] Clearing interval.'); clearInterval(pollIntervalRef.current); pollIntervalRef.current = null; }
        };
        if (hasActiveJobs && !loadingRef.current) setupPollingInterval(); else clearPollingInterval();
        return clearPollingInterval;
    }, [jobs, refreshJobs]);

    // Return hook state and *original* setters for filters/page
    return {
        jobs, loading, error, totalCount, totalPages, currentPage,
        selectedStatus, startDate, endDate, cursor,
        setSelectedStatus, // Expose original setter
        setStartDate,      // Expose original setter
        setEndDate,        // Expose original setter
        setCurrentPage,    // Expose original setter
        refreshJobs,
    };
}

File: src/components/BatchJobsTab/BatchJobDetailsModal.css
/* Custom scrollbar for the modal */
.batch-details-modal .ant-modal-body {
  scrollbar-width: thin;
  scrollbar-color: #d1d5db transparent;
}

.batch-details-modal .ant-modal-body::-webkit-scrollbar {
  width: 6px;
}

.batch-details-modal .ant-modal-body::-webkit-scrollbar-track {
  background: transparent;
}

.batch-details-modal .ant-modal-body::-webkit-scrollbar-thumb {
  background-color: #d1d5db;
  border-radius: 3px;
}

/* Focus styles */
.batch-details-modal *:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
}

.batch-details-modal .ant-modal-close:focus {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  border-radius: 9999px;
}

/* Processing overlay animation */
@keyframes pulse {
  0% {
    opacity: 0.5;
  }
  50% {
    opacity: 0.7;
  }
  100% {
    opacity: 0.5;
  }
}

.batch-details-modal .processing-overlay {
  animation: pulse 2s ease-in-out infinite;
  background-color: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(1px);
  border-radius: 0.25rem;
  padding: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Better table focus styles */
.batch-details-modal tr:focus-within {
  background-color: rgba(59, 130, 246, 0.05);
  outline: 2px solid rgba(59, 130, 246, 0.5);
  outline-offset: -2px;
}

/* Sticky header shadow */
.batch-details-modal thead {
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

/* Better modal transitions */
.batch-details-modal.ant-modal-wrap {
  transition: opacity 0.2s ease-out;
}

.batch-details-modal .ant-modal {
  transition: transform 0.2s ease-out;
}

.batch-details-modal .ant-modal-mask {
  transition: opacity 0.2s ease-out;
}

/* Improve result display */
.batch-details-modal pre {
  background-color: rgba(255, 255, 255, 0.5);
  border-radius: 0.375rem;
  padding: 0.5rem;
}

/* Better focus indication for interactive elements */
.batch-details-modal button:focus-visible,
.batch-details-modal [role="button"]:focus-visible {
  outline: 2px solid rgba(59, 130, 246, 0.5);
  outline-offset: 2px;
}

/* Screen reader only text */
.batch-details-modal .sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* ARIA keyboard navigation styles */
.batch-details-modal [tabindex="0"]:not(:focus-visible):focus {
  outline: none;
  box-shadow: none;
}

/* Improved status badges */
.batch-details-modal [role="status"] {
  transition: all 0.2s ease-out;
}

/* Loading state transitions */
.batch-details-modal .ant-spin {
  transition: opacity 0.2s ease-out;
}

/* Focus order improvements */
.batch-details-modal [tabindex]:not([tabindex="-1"]) {
  transition: box-shadow 0.2s ease-out;
}


File: src/api/batch-classification.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import {
  BatchClassificationRequest,
  BatchClassificationResult,
  BatchJobsPage,
  BatchJobParams
} from './types';

export class BatchClassificationService {
    constructor(private core: ApiClientCore) {}

    async classifyBatch(request: BatchClassificationRequest): Promise<BatchClassificationResult> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const requestBody: any = {
                items: request.items.map(item => ({
                    description: item.description,
                    additional_context: item.additionalContext,
                    key: item.key
                })),
                system_code: request.systemCode,
            };
            if (Array.isArray(request.key_column_names) && request.key_column_names.length > 0) {
                requestBody.key_column_names = request.key_column_names;
            }

            const response = await this.core.fetchWithTimeout(formatEndpoint('/classify/batch'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Batch classification failed');
            }
            const result = await response.json();
            return {
                ...result,
                timestamp: this.core.formatDate(result.timestamp),
                // Ensure systemCode is correctly propagated or derived
                systemCode: result.system_code || request.systemCode || result.results?.[0]?.result?.system_code
            };
        } catch (error) {
            console.error(`[${requestId}] Batch classification error:`, error);
            throw error;
        }
    }

    async getBatchStatus(batchId: string): Promise<BatchClassificationResult> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            // Corrected endpoint:
            const response = await this.core.fetchWithTimeout(formatEndpoint(`/batch/jobs/${batchId}`));
            if (!response.ok) {
                // Try to parse error from backend, otherwise use statusText
                let errorPayload;
                try {
                    errorPayload = await response.json();
                } catch (e) {
                    // Ignore parsing error if body is not JSON or empty
                }
                const errorMessage = errorPayload?.error || response.statusText || `Failed to get batch status (${response.status})`;
                console.error(`[${requestId}] Get batch status error (${response.status}):`, errorMessage, errorPayload);
                throw new Error(errorMessage);
            }
            const result = await response.json();
            // Ensure systemCode is correctly propagated or derived for consistency
            const systemCode = result.system_code || result.results?.[0]?.result?.system_code;
            return {
                ...result,
                timestamp: this.core.formatDate(result.timestamp),
                updated_at: result.updated_at ? this.core.formatDate(result.updated_at) : undefined,
                systemCode // Keep consistent casing
            };
        } catch (error) {
            // Log already happened or will be handled by the caller
            // console.error(`[${requestId}] Get batch status error (outer):`, error);
            throw error;
        }
    }

    async getBatchJobs(params: BatchJobParams): Promise<BatchJobsPage> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const searchParams = new URLSearchParams();
            if (params.limit) searchParams.append('limit', params.limit.toString());
            if (params.cursor) searchParams.append('cursor', params.cursor);
            if (params.status && params.status !== 'all') searchParams.append('status', params.status); // Only add if not 'all'
            if (params.startDate) searchParams.append('start_date', params.startDate);
            if (params.endDate) searchParams.append('end_date', params.endDate);

            const url = `${formatEndpoint('/batch/jobs')}${searchParams.toString() ? '?' + searchParams.toString() : ''}`;
            const response = await this.core.fetchWithTimeout(url, { method: 'GET' });

            if (!response.ok) {
                const errorText = await response.text(); // Get raw text for debugging
                console.error(`[${requestId}] Failed to fetch batch jobs (${response.status}): ${errorText}`);
                throw new Error(`Failed to fetch batch jobs: ${response.statusText} - ${errorText}`);
            }
            const data = await response.json();
            // Ensure consistent casing and data transformation
            const items = (data.items || []).map((job: any) => ({
                ...job,
                id: job.id,
                status: job.status,
                system_code: job.system_code, // Keep snake_case from backend if that's what it sends
                systemCode: job.system_code,  // Add camelCase for frontend consistency
                timestamp: this.core.formatDate(job.timestamp),
                updated_at: job.updated_at ? this.core.formatDate(job.updated_at) : undefined,
                totalItems: job.total_items,
                processedItems: job.processed_items,
                keyColumnNames: job.key_column_names,
                results: job.results || [], // Ensure results is always an array
            }));
            return {
                items,
                totalCount: data.total_count,
                nextCursor: data.next_cursor,
            };
        } catch (error) {
            console.error(`[${requestId}] Error fetching batch jobs:`, error);
            throw error;
        }
    }
}

File: src/api/rag.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { 
    RagInfoItem, 
    RagInfoPage, 
    RagInfoRequestParams, 
    CreateRagInfoRequest, 
    UpdateRagInfoRequest 
} from './types';

export class RagService {
    constructor(private core: ApiClientCore) {}

    async getRagInfoList(params: RagInfoRequestParams): Promise<RagInfoPage> {
        const requestId = Math.random().toString(36).substring(7);
        const searchParams = new URLSearchParams();
        if (params.page) searchParams.append('page', params.page.toString());
        if (params.limit) searchParams.append('limit', params.limit.toString());
        if (params.search) searchParams.append('search', params.search);
        const url = `${formatEndpoint('/rag-info')}${searchParams.toString() ? '?' + searchParams.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get RAG info list');
            }
            const result = await response.json();
            return {
                items: (result.items || []).map((item: any) => ({
                    ...item,
                    createdAt: this.core.formatDate(item.createdAt),
                    updatedAt: this.core.formatDate(item.updatedAt)
                })),
                totalCount: result.totalCount || 0,
                totalPages: result.totalPages || 1,
                currentPage: result.currentPage || 1,
            };
        } catch (error) {
            console.error(`[${requestId}] Get RAG info list error:`, error);
            throw error;
        }
    }

    async createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint('/rag-info');
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to create RAG info');
            }
            const result = await response.json();
            return {
                ...result,
                createdAt: this.core.formatDate(result.createdAt),
                updatedAt: this.core.formatDate(result.updatedAt)
            };
        } catch (error) {
            console.error(`[${requestId}] Create RAG info error:`, error);
            throw error;
        }
    }

    async getRagInfoItem(id: string): Promise<RagInfoItem> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint(`/rag-info/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || `Failed to get RAG info item ${id}`);
            }
            const result = await response.json();
            return {
                ...result,
                createdAt: this.core.formatDate(result.createdAt),
                updatedAt: this.core.formatDate(result.updatedAt)
            };
        } catch (error) {
            console.error(`[${requestId}] Get RAG info item error:`, error);
            throw error;
        }
    }

    async updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint(`/rag-info/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || `Failed to update RAG info ${id}`);
            }
            const result = await response.json();
            return {
                ...result,
                createdAt: this.core.formatDate(result.createdAt),
                updatedAt: this.core.formatDate(result.updatedAt)
            };
        } catch (error) {
            console.error(`[${requestId}] Update RAG info error:`, error);
            throw error;
        }
    }

    async deleteRagInfo(id: string): Promise<void> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint(`/rag-info/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || `Failed to delete RAG info ${id}`);
            }
        } catch (error) {
            console.error(`[${requestId}] Delete RAG info error:`, error);
            throw error;
        }
    }

    // Keep the duplicate getRagInfo for compatibility if needed
    async getRagInfo(id: string): Promise<RagInfoItem> {
        return this.getRagInfoItem(id);
    }

    async queryRag(question: string): Promise<any> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const url = formatEndpoint('/rag/query');
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question }),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'RAG query failed');
            }
            return await response.json();
        } catch (error) {
            console.error(`[${requestId}] RAG query error:`, error);
            throw error;
        }
    }
}

File: src/api/permission.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { PermissionListResponse } from './types';

export class PermissionService {
    constructor(private core: ApiClientCore) {}

    async getPermissions(): Promise<PermissionListResponse> {
        const url = formatEndpoint('/permissions');
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to get permissions");
            }
            return await response.json();
        } catch (error) {
            console.error(`Get permissions error:`, error);
            throw error;
        }
    }
}

File: src/api/config.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { LlmConfig, UpdateConfigRequest } from './types'; // Import UpdateConfigRequest

export class ConfigService {
    constructor(private core: ApiClientCore) {}

    async getConfig(): Promise<LlmConfig & { ragEnabled?: boolean }> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const response = await this.core.fetchWithTimeout(formatEndpoint('/settings/config'));
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get configuration');
            }
            const data = await response.json();

            // Simplified transformation logic (adjust if complex cases needed)
            const transformObject = (obj: any): any => {
                if (!obj || typeof obj !== 'object') return obj;
                if (Array.isArray(obj)) return obj.map(transformObject);
                const result: any = {};
                Object.entries(obj).forEach(([key, value]) => {
                    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
                    result[camelKey] = typeof value === 'object' ? transformObject(value) : value;
                });
                return result;
            };

            const config: LlmConfig = {
                server: transformObject(data.server),
                service: transformObject(data.service),
                database: transformObject(data.database),
                validation: transformObject(data.validation),
                alert: transformObject(data.alert),
                llmEndpoint: data.service?.llm_endpoint || '',
                llmApiKey: data.service?.llm_api_key || '',
                ragEnabled: !!(data.database?.rag_enabled ?? data.ragEnabled ?? false), // Simplified check
            };
            console.log(`[${requestId}] Transformed config (API Key Redacted):`, { ...config, llmApiKey: '[REDACTED]', service: { ...config.service, llmApiKey: '[REDACTED]' } });
            return config;
        } catch (error) {
            console.error(`[${requestId}] Get config error:`, error);
            return { llmEndpoint: '', llmApiKey: '', ragEnabled: false }; // Default on error
        }
    }

    async updateConfig(configUpdate: UpdateConfigRequest): Promise<void> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint('/settings/config'); // Ensure endpoint is correct (usually same as GET)
        try {
            // Log the update payload *without* sensitive fields if possible
             const safePayload = JSON.parse(JSON.stringify(configUpdate)); // Deep copy
             if (safePayload.service?.llmApiKey) safePayload.service.llmApiKey = '[REDACTED]';
             if (safePayload.alert?.emailSettings?.smtpPassword) safePayload.alert.emailSettings.smtpPassword = '[REDACTED]';
             console.log(`[${requestId}] Sending config update request to ${url}`, safePayload);

            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT', // Use PUT for updating the entire config resource (or PATCH for partial)
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(configUpdate), // Send the update payload
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                console.error(`[${requestId}] Update config error response:`, error);
                throw new Error(error.error || 'Failed to update configuration');
            }
            console.log(`[${requestId}] Configuration updated successfully.`);
        } catch (error) {
            console.error(`[${requestId}] Update config error:`, error);
            throw error; // Re-throw error
        }
    }
}

File: src/api/client.ts
import {
  ApiClient,
  ClassificationResult,
  LlmConfig,
  UpdateConfigRequest, 
  ClassificationSystem,
  ClassificationLevel,
  Category,
  SystemCategoriesRequest,
  ClassificationHistoryRequest,
  ClassificationHistoryPage,
  BatchClassificationRequest,
  BatchClassificationResult,
  ManualClassificationRequest,
  BatchJobsPage,
  BatchJobParams,
  RagInfoItem,
  RagInfoPage,
  RagInfoRequestParams,
  CreateRagInfoRequest,
  UpdateRagInfoRequest,
  LoginResponse,
  User,
  UserListResponse,
  CreateUserRequest,
  UpdateUserRequest,
  RoleListResponse,
  CreateRoleRequest,
  UpdateRoleRequest,
  Role,
  PermissionListResponse,
} from './types';

import { ApiClientCore } from './core-client';
import { AuthService } from './auth.service';
import { UserService } from './user.service';
import { RoleService } from './role.service';
import { PermissionService } from './permission.service';
import { ClassificationService } from './classification.service';
import { BatchClassificationService } from './batch-classification.service';
import { SystemService } from './system.service';
import { ConfigService } from './config.service';
import { RagService } from './rag.service';

export class WebApiClient implements ApiClient {
  private core: ApiClientCore;
  private authService: AuthService;
  private userService: UserService;
  private roleService: RoleService;
  private permissionService: PermissionService;
  private classificationService: ClassificationService;
  private batchClassificationService: BatchClassificationService;
  private systemService: SystemService;
  private configService: ConfigService;
  private ragService: RagService;

  constructor() {
    this.core = new ApiClientCore();
    this.authService = new AuthService(this.core);
    this.userService = new UserService(this.core);
    this.roleService = new RoleService(this.core);
    this.permissionService = new PermissionService(this.core);
    this.classificationService = new ClassificationService(this.core);
    this.batchClassificationService = new BatchClassificationService(this.core);
    this.systemService = new SystemService(this.core);
    this.configService = new ConfigService(this.core);
    this.ragService = new RagService(this.core);
  }

  // Add generic HTTP methods delegating to ApiClientCore
  async get<T = any>(path: string, params?: Record<string, any>, config?: any): Promise<T> {
    return this.core.get<T>(path, params, config);
  }

  async post<T = any>(path: string, data?: any, config?: any): Promise<T> {
    return this.core.post<T>(path, data, config);
  }

  async put<T = any>(path: string, data?: any, config?: any): Promise<T> {
    return this.core.put<T>(path, data, config);
  }

  async delete<T = any>(path: string, config?: any): Promise<T> {
    return this.core.delete<T>(path, config);
  }

  // Initialize method now fetches auth config
  async initialize(): Promise<void> {
    await this.core.fetchAuthConfig();
  }

  // --- Delegate methods to services ---

  // Auth
  isLoggedIn(): boolean { return this.authService.isLoggedIn(); }
  isAuthEnabled(): boolean | null { return this.authService.isAuthEnabled(); }
  async login(username: string, password: string): Promise<LoginResponse> { return this.authService.login(username, password); }
  clearToken(): void { this.authService.clearToken(); }
  async getCurrentUser(): Promise<User> { return this.authService.getCurrentUser(); }

  // User Management
  async getUsers(params?: { limit?: number; offset?: number; search?: string }): Promise<UserListResponse> { return this.userService.getUsers(params); }
  async createUser(data: CreateUserRequest): Promise<User> { return this.userService.createUser(data); }
  async updateUser(id: number, data: UpdateUserRequest): Promise<User> { return this.userService.updateUser(id, data); }
  async deleteUser(id: number): Promise<void> { return this.userService.deleteUser(id); }
  async assignRolesToUser(userId: number, roleNames: string[]): Promise<void> { return this.userService.assignRolesToUser(userId, roleNames); }

  // Role Management
  async getRoles(params?: { limit?: number; offset?: number }): Promise<RoleListResponse> { return this.roleService.getRoles(params); }
  async createRole(data: CreateRoleRequest): Promise<Role> { return this.roleService.createRole(data); }
  async updateRole(id: number, data: UpdateRoleRequest): Promise<Role> { return this.roleService.updateRole(id, data); }
  async deleteRole(id: number): Promise<void> { return this.roleService.deleteRole(id); }

  // Permission Management
  async getPermissions(): Promise<PermissionListResponse> { return this.permissionService.getPermissions(); }

  // Classification
  async classify(description: string, systemCode?: string, additionalContext?: string, modelOverride?: string): Promise<ClassificationResult> { return this.classificationService.classify(description, systemCode, additionalContext, modelOverride); }
  async classifyManually(request: ManualClassificationRequest): Promise<ClassificationResult> { return this.classificationService.classifyManually(request); }
  async rerunClassification(id: string): Promise<ClassificationResult> { return this.classificationService.rerunClassification(id); }
  async deleteClassification(id: string): Promise<void> { return this.classificationService.deleteClassification(id); }
  async getClassificationHistory(req: ClassificationHistoryRequest): Promise<ClassificationHistoryPage> { return this.classificationService.getClassificationHistory(req); }
  async deleteClassificationHistory(id: string): Promise<void> { return this.classificationService.deleteClassificationHistory(id); }

  // Batch Classification
  async classifyBatch(request: BatchClassificationRequest): Promise<BatchClassificationResult> { return this.batchClassificationService.classifyBatch(request); }
  async getBatchStatus(batchId: string): Promise<BatchClassificationResult> { return this.batchClassificationService.getBatchStatus(batchId); }
  async getBatchJobs(params: BatchJobParams): Promise<BatchJobsPage> { return this.batchClassificationService.getBatchJobs(params); }

  // System
  async getClassificationSystems(): Promise<ClassificationSystem[]> { return this.systemService.getClassificationSystems(); }
  async getClassificationSystem(code: string): Promise<{ system: ClassificationSystem; levels: ClassificationLevel[] }> { return this.systemService.getClassificationSystem(code); }
  async getSystemCategories(req: SystemCategoriesRequest): Promise<Category[]> { return this.systemService.getSystemCategories(req); }

  // Config
  async getConfig(): Promise<LlmConfig & { ragEnabled?: boolean }> { return this.configService.getConfig(); }
  async updateConfig(configUpdate: UpdateConfigRequest): Promise<void> { 
    return this.configService.updateConfig(configUpdate); 
  }

  // RAG
  async getRagInfoList(params: RagInfoRequestParams): Promise<RagInfoPage> { return this.ragService.getRagInfoList(params); }
  async createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem> { return this.ragService.createRagInfo(data); }
  async getRagInfoItem(id: string): Promise<RagInfoItem> { return this.ragService.getRagInfoItem(id); }
  async updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem> { return this.ragService.updateRagInfo(id, data); }
  async deleteRagInfo(id: string): Promise<void> { return this.ragService.deleteRagInfo(id); }
  async getRagInfo(id: string): Promise<RagInfoItem> { return this.ragService.getRagInfo(id); } // Keep for compatibility
  async queryRag(question: string): Promise<any> { return this.ragService.queryRag(question); }

  // For backward compatibility - fetch auth config (will eventually be removed)
  async fetchAuthConfig(): Promise<void> {
    return this.core.fetchAuthConfig();
  }
}


File: src/components/BatchJobsTab/components/BatchJobsPagination.tsx
// src/components/BatchJobsTab/components/BatchJobsPagination.tsx
import React from 'react';

interface BatchJobsPaginationProps {
    currentPage: number;
    totalPages: number;
    totalCount: number;
    pageSize: number;
    loading: boolean;
    cursor?: string;
    onPageChange: (page: number) => void;
}

export const BatchJobsPagination: React.FC<BatchJobsPaginationProps> = ({
    currentPage, totalPages, totalCount, pageSize, loading, cursor, onPageChange
}) => {
    // Don't show pagination if only one page or no results
    if (totalCount <= pageSize && totalPages <= 1) {
        return null;
    }

    const firstItem = (currentPage - 1) * pageSize + 1;
    const lastItem = Math.min(currentPage * pageSize, totalCount);

    return (
        <div className="mt-6 flex items-center justify-between">
            {/* Results Count Text */}
            <p className="text-sm text-secondary-600">
                Showing <span className="font-medium">{firstItem}</span>-
                <span className="font-medium">{lastItem}</span> of{' '}
                <span className="font-medium">{totalCount}</span> results
            </p>
            {/* Pagination Buttons */}
            <div className="flex items-center gap-1">
                <button
                    onClick={() => onPageChange(1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >First</button>
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Previous</button>
                <span className="text-sm text-secondary-600 px-2">
                    Page {currentPage} of {totalPages}
                </span>
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages || loading || !cursor}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Next</button>
                <button
                    onClick={() => onPageChange(totalPages)}
                    disabled={currentPage === totalPages || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Last</button>
            </div>
        </div>
    );
};

File: src/api/core-client.ts
import { formatEndpoint } from '../config/api';

// Constants for local storage keys
export const AUTH_TOKEN_KEY = 'authToken';
export const USER_INFO_KEY = 'userInfo';

export class ApiClientCore {
  readonly timeoutDuration: number = 6000000; // 600 second timeout
  authEnabled: boolean | null = null; // Track if auth is enabled

  formatDate(dateStr: string | undefined | null): string {
    if (!dateStr) {
      return new Date().toISOString();
    }
    try {
      return new Date(dateStr).toISOString();
    } catch (e) {
      console.error('Error formatting date:', dateStr, e);
      return new Date().toISOString();
    }
  }

  getAuthHeader(): HeadersInit {
    const token = localStorage.getItem(AUTH_TOKEN_KEY);
    return token ? { 'Authorization': `Bearer ${token}` } : {};
  }

  async fetchWithTimeout(url: string, options: RequestInit = {}): Promise<Response> {
    const controller = new AbortController();
    const id = Math.random().toString(36).substring(7);

    const timeout = setTimeout(() => {
      controller.abort();
      console.error(`Request ${id} timed out:`, url);
    }, this.timeoutDuration);

    const authHeaders = this.getAuthHeader();
    const headers = {
      ...options.headers,
      ...authHeaders
    };

    console.log(`[${id}] Starting request:`, url);

    try {
      const response = await fetch(url, {
        ...options,
        headers,
        signal: controller.signal
      });

      console.log(`[${id}] Response received:`, {
        url,
        status: response.status,
        ok: response.ok
      });

      // Handle potential 401 Unauthorized specifically
      if (response.status === 401) {
          console.warn(`[${id}] Unauthorized request to ${url}. Clearing token.`);
          localStorage.removeItem(AUTH_TOKEN_KEY);
          localStorage.removeItem(USER_INFO_KEY);
          // Optionally redirect to login or notify the user
          // window.location.href = '/login'; // Example redirect
      }

      return response;
    } catch (error) {
      console.error(`[${id}] Request failed:`, {
        url,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    } finally {
      clearTimeout(timeout);
    }  }

  // --- Add generic HTTP methods ---
  async get<T = any>(path: string, params?: Record<string, any>, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    let urlString = endpoint;
    
    // Add query parameters to the URL
    if (params && Object.keys(params).length > 0) {
      const queryParams = new URLSearchParams();
      Object.keys(params).forEach(key => {
        if (params[key] !== undefined && params[key] !== null) {
          queryParams.append(key, String(params[key]));
        }
      });
      const queryString = queryParams.toString();
      urlString = queryString ? `${endpoint}${endpoint.includes('?') ? '&' : '?'}${queryString}` : endpoint;
    }
    
    const response = await this.fetchWithTimeout(urlString, { method: 'GET', ...config });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async post<T = any>(path: string, data?: any, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    const response = await this.fetchWithTimeout(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...config?.headers },
      body: data ? JSON.stringify(data) : null,
      ...config,
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    // Handle cases where response might be empty (e.g., 204 No Content)
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      return response.json() as Promise<T>;
    }
    return response.text() as unknown as Promise<T>; // Or handle as appropriate
  }

  async put<T = any>(path: string, data?: any, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    const response = await this.fetchWithTimeout(endpoint, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...config?.headers },
      body: data ? JSON.stringify(data) : null,
      ...config,
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      return response.json() as Promise<T>;
    }
    return response.text() as unknown as Promise<T>;
  }

  async delete<T = any>(path: string, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    const response = await this.fetchWithTimeout(endpoint, {
      method: 'DELETE',
      ...config,
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      return response.json() as Promise<T>;
    }
    return response.text() as unknown as Promise<T>;
  }
  // --- End of new methods ---

  getCurrentUserInfo(): any | null {
    const stored = localStorage.getItem(USER_INFO_KEY);
    try {
      return stored ? JSON.parse(stored) : null;
    } catch (e) {
      console.error("Error parsing stored user info:", e);
      localStorage.removeItem(USER_INFO_KEY); // Clear invalid data
      return null;
    }
  }

  async fetchAuthConfig(): Promise<void> {
    try {
      const requestId = Math.random().toString(36).substring(7);
      console.log(`[${requestId}] Fetching auth configuration`);

      // Use fetch directly here as fetchWithTimeout might not be fully initialized
      // or to avoid circular dependencies if auth state affects fetchWithTimeout.
      const response = await fetch(formatEndpoint('/auth/config'));

      if (!response.ok) {
        console.warn(`[${requestId}] Failed to fetch auth config, assuming auth is disabled`);
        this.authEnabled = false;
        return;
      }

      const data = await response.json();
      this.authEnabled = data.enabled === true;
      console.log(`[${requestId}] Auth configuration fetched, auth is ${this.authEnabled ? 'enabled' : 'disabled'}`);
    } catch (error) {
      console.error('Error fetching auth config:', error);
      this.authEnabled = false; // Default to disabled on error
    }
  }
}

File: src/api/classification.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { 
  ClassificationResult, 
  ManualClassificationRequest, 
  ClassificationHistoryRequest,
  ClassificationHistoryPage,
  ClassificationHistory
} from './types';

export class ClassificationService {
  constructor(private core: ApiClientCore) {}

  async classify(description: string, systemCode: string = 'UNSPSC', additionalContext?: string, modelOverride?: string): Promise<ClassificationResult> {
    const requestId = Math.random().toString(36).substring(7);
    console.log("[ApiClient] classify Request ID:", requestId);
    try {
      const response = await this.core.fetchWithTimeout(formatEndpoint('/classify'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          description,
          system_code: systemCode,
          additional_context: additionalContext,
          save_failed: true,
          model_override: modelOverride,
        }),
      });
      const result = await response.json();
      if (!response.ok) {
        const errorMessage = result.error || response.statusText || 'Classification failed';
        const fullError = result.details ? `${errorMessage}: ${result.details}` : errorMessage;
        throw new Error(fullError);
      }
      let status: 'success' | 'partial' | 'failed' = 'success';
      if (result.error) {
        status = Object.keys(result.levels || {}).length > 0 ? 'partial' : 'failed';
      }      return {
        ...result,
        description,
        status: result.status || status,
        timestamp: this.core.formatDate(result.timestamp),
        firstLevelPrompt: result.first_level_prompt || result.firstLevelPrompt,
        allPromptsDetail: result.all_prompts_detail || result.allPromptsDetail
      };
    } catch (error) {
      console.error(`[${requestId}] Classification error:`, error);
      throw error;
    }
  }

  async classifyManually(request: ManualClassificationRequest): Promise<ClassificationResult> {
     const requestId = Math.random().toString(36).substring(7);
      console.log("[ApiClient] classifyManually Request ID:", requestId);
     try {
        const response = await this.core.fetchWithTimeout(formatEndpoint('/classify/manual'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                description: request.description,
                systemCode: request.systemCode, // Ensure backend expects camelCase or adjust here
                levels: request.levels,
                model_override: request.modelOverride, // Pass selected model if available
            }),
        });
        if (!response.ok) {
            const error = await response.json().catch(() => ({ error: response.statusText }));
            throw new Error(error.error || 'Manual classification failed');
        }        const result = await response.json();
        return {
            ...result,
            description: request.description,
            status: result.status || 'success',
            timestamp: this.core.formatDate(result.timestamp),
            firstLevelPrompt: result.first_level_prompt || result.firstLevelPrompt,
            allPromptsDetail: result.all_prompts_detail || result.allPromptsDetail
        };
     } catch (error) {
        console.error(`[${requestId}] Manual classification error:`, error);
        throw error;
     }
  }
  async rerunClassification(id: string): Promise<ClassificationResult> {
    const requestId = Math.random().toString(36).substring(7);
    try {
        const response = await this.core.fetchWithTimeout(formatEndpoint(`/history/${id}/rerun`), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        });
        if (!response.ok) {
            throw new Error(`Rerun classification failed: ${response.statusText}`);
        }
        const result = await response.json();
        
        // Map backend field names to frontend field names
        return {
            ...result,
            firstLevelPrompt: result.first_level_prompt || result.firstLevelPrompt,
            allPromptsDetail: result.all_prompts_detail || result.allPromptsDetail,
            timestamp: this.core.formatDate(result.timestamp)
        };
    } catch (error) {
        console.error(`[${requestId}] Error rerunning classification:`, error);
        throw error;
    }
  }

  async deleteClassification(id: string): Promise<void> {
    const requestId = Math.random().toString(36).substring(7);
    try {
        const response = await this.core.fetchWithTimeout(formatEndpoint(`/history/${id}`), {
            method: 'DELETE',
        });
        if (!response.ok) {
            throw new Error(`Delete classification failed: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`[${requestId}] Error deleting classification:`, error);
        throw error;
    }
  }

  async getClassificationHistory(req: ClassificationHistoryRequest): Promise<ClassificationHistoryPage> {
    const params = new URLSearchParams();
    params.append('limit', (req.limit ?? 10).toString());
    if (req.cursor) params.append('cursor', req.cursor);
    if (req.status) params.append('status', req.status);
    if (req.startDate) params.append('start_date', req.startDate);
    if (req.endDate) params.append('end_date', req.endDate);
    if (req.search) params.append('search', req.search);
    if (req.sourceType) params.append('source_type', req.sourceType);
    if (req.createdBy) params.append('created_by', req.createdBy);

    const endpointPath = req.systemCode ? `/systems/${req.systemCode}/history` : '/history';
    const url = `${formatEndpoint(endpointPath)}?${params.toString()}`;
    const requestId = Math.random().toString(36).substring(7);

    try {
      const response = await this.core.fetchWithTimeout(url);
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: response.statusText }));
        throw new Error(error.error || 'Failed to get classification history');
      }
      const data = await response.json();

      // Map backend snake_case to frontend camelCase
      const items: ClassificationHistory[] = (data.items || []).map((item: any) => ({
        id: item.id,
        description: item.description,
        systemCode: item.system_code ?? item.systemCode,
        additionalContext: item.additional_context ?? item.additionalContext,
        levels: item.levels,
        createdAt: this.core.formatDate(item.created_at ?? item.createdAt),
        status: item.status,
        createdBy: item.created_by ?? item.createdBy,
        sourceType: item.source_type ?? item.sourceType,        ragContextUsed: item.rag_context_used ?? item.ragContextUsed,
        ragContext: item.rag_context ?? item.ragContext,
        levelResponses: item.level_responses ?? item.levelResponses,
        error: item.error,
        firstLevelPrompt: item.first_level_prompt ?? item.firstLevelPrompt,
        allPromptsDetail: item.all_prompts_detail ?? item.allPromptsDetail,
        modelUsed: item.model_used ?? item.modelUsed,
      }));

      return {
        items: items,
        totalCount: data.total_count,
        nextCursor: data.next_cursor,
      };
    } catch (error) {
        console.error(`[${requestId}] Get classification history error:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to load history: ${error.message}`);
        } else {
            throw new Error('Failed to load history due to an unknown error.');
        }
    }
  }

  async deleteClassificationHistory(id: string): Promise<void> {
    const response = await this.core.fetchWithTimeout(formatEndpoint(`/history/${id}`), {
      method: 'DELETE',
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to delete classification history: ${errorText}`);
    }
  }
}

File: src/components/BatchJobsTab/index.ts
// src/components/BatchJobsTab/index.ts
export { default as BatchJobsTab } from './BatchJobsTab';

File: src/api/system.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { 
  ClassificationSystem, 
  ClassificationLevel,
  Category,
  SystemCategoriesRequest
} from './types';

export class SystemService {
    constructor(private core: ApiClientCore) {}

    async getClassificationSystems(): Promise<ClassificationSystem[]> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const response = await this.core.fetchWithTimeout(formatEndpoint('/systems'));
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get classification systems');
            }
            const data = await response.json();
            const systems = Array.isArray(data.systems) ? data.systems : [];
            return systems.map((system: any) => ({
                id: system.id,
                code: system.code,
                name: system.name,
                description: system.description,
                enabled: system.enabled,
                createdAt: this.core.formatDate(system.created_at)
            }));
        } catch (error) {
            console.error(`[${requestId}] Get classification systems error:`, error);
            throw error;
        }
    }

    async getClassificationSystem(code: string): Promise<{ system: ClassificationSystem; levels: ClassificationLevel[] }> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const response = await this.core.fetchWithTimeout(formatEndpoint(`/systems/${code}`));
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get classification system');
            }
            const data = await response.json();
            const system: ClassificationSystem = {
                id: data.system.id,
                code: data.system.code,
                name: data.system.name,
                description: data.system.description,
                enabled: data.system.enabled,
                createdAt: this.core.formatDate(data.system.created_at)
            };
            const levels = (data.levels || []).map((level: any) => ({
                id: level.id,
                systemId: level.system_id,
                levelNumber: level.level_number,
                code: level.code,
                name: level.name,
                description: level.description,
                validationRegex: level.validation_regex
            }));
            return { system, levels };
        } catch (error) {
            console.error(`[${requestId}] Get classification system error:`, error);
            throw error;
        }
    }

    async getSystemCategories(req: SystemCategoriesRequest): Promise<Category[]> {
        const requestId = Math.random().toString(36).substring(7);
        const params = new URLSearchParams();
        if (req.level) params.append('level', req.level);
        if (req.parentCode) params.append('parent_code', req.parentCode);
        const url = `${formatEndpoint(`/systems/${req.systemCode}/categories`)}${params.toString() ? '?' + params.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get system categories');
            }
            const data = await response.json();
            const categories = Array.isArray(data.categories) ? data.categories : [];
            return categories.map((cat: any) => ({
                id: cat.id,
                systemId: cat.system_id,
                code: cat.code,
                name: cat.name,
                description: cat.description,
                levelCode: cat.level_code,
                parentCode: cat.parent_code,
                createdAt: this.core.formatDate(cat.created_at)
            }));
        } catch (error) {
            console.error(`[${requestId}] Get system categories error:`, error);
            throw error;
        }
    }
}

File: src/api/user.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore, USER_INFO_KEY } from './core-client';
import { User, UserListResponse, CreateUserRequest, UpdateUserRequest } from './types';

export class UserService {
    constructor(private core: ApiClientCore) {}

    async getUsers(params?: { limit?: number; offset?: number; search?: string }): Promise<UserListResponse> {
        const urlParams = new URLSearchParams();
        if (params?.limit) urlParams.append('limit', params.limit.toString());
        if (params?.offset) urlParams.append('offset', params.offset.toString());
        if (params?.search) urlParams.append('search', params.search);
        const url = `${formatEndpoint('/users')}${urlParams.toString() ? '?' + urlParams.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to get users");
            }
            return await response.json();
        } catch (error) {
            console.error(`Get users error:`, error);
            throw error;
        }
    }

    async createUser(data: CreateUserRequest): Promise<User> {
        const url = formatEndpoint('/users');
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to create user");
            }
            return await response.json();
        } catch (error) {
            console.error(`Create user error:`, error);
            throw error;
        }
    }

    async updateUser(id: number, data: UpdateUserRequest): Promise<User> {
        const url = formatEndpoint(`/users/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to update user");
            }
            const result = await response.json();
            const currentUser = this.core.getCurrentUserInfo();
            if (currentUser && currentUser.id === id) {
                localStorage.setItem(USER_INFO_KEY, JSON.stringify(result));
            }
            return result;
        } catch (error) {
            console.error(`Update user error:`, error);
            throw error;
        }
    }

    async deleteUser(id: number): Promise<void> {
        const url = formatEndpoint(`/users/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to delete user");
            }
        } catch (error) {
            console.error(`Delete user error:`, error);
            throw error;
        }
    }

    async assignRolesToUser(userId: number, roleNames: string[]): Promise<void> {
        const url = formatEndpoint(`/users/${userId}/roles`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ roles: roleNames }),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to assign roles to user");
            }
        } catch (error) {
            console.error(`Assign roles error:`, error);
            throw error;
        }
    }
}

File: src/api/types.ts
// src/api/types.ts
// API Client Interface
export interface ApiClient {
  // Generic HTTP methods
  get<T = any>(path: string, params?: Record<string, any>, config?: any): Promise<T>;
  post<T = any>(path: string, data?: any, config?: any): Promise<T>;
  put<T = any>(path: string, data?: any, config?: any): Promise<T>;
  delete<T = any>(path: string, config?: any): Promise<T>;

  // Authentication methods
  /**
   * Check if user is currently logged in
   * @returns boolean indicating login status
   */
  isLoggedIn(): boolean;

  /**
   * Check if authentication is enabled
   * @returns boolean indicating whether auth is enabled, or null if not determined yet
   */
  isAuthEnabled(): boolean | null;

  /**
   * Fetch authentication configuration from the server
   */
  fetchAuthConfig(): Promise<void>;

  /**
   * Log in a user
   * @param username - Username
   * @param password - Password
   */
  login(username: string, password: string): Promise<LoginResponse>;

  /**
   * Clear authentication token
   */
  clearToken(): void;

  /**
   * Get the current logged-in user's details
   */
  getCurrentUser(): Promise<User>;

  // --- User Management ---
  /**
   * Get a list of users
   * @param params - Optional parameters for pagination and searching
   */
  getUsers(params?: { limit?: number; offset?: number; search?: string }): Promise<UserListResponse>;
  
  /**
   * Create a new user
   * @param data - User creation data
   */
  createUser(data: CreateUserRequest): Promise<User>;
  
  /**
   * Update an existing user
   * @param id - User ID
   * @param data - User update data
   */
  updateUser(id: number, data: UpdateUserRequest): Promise<User>;
  
  /**
   * Delete a user
   * @param id - User ID
   */
  deleteUser(id: number): Promise<void>;
  
  /**
   * Assign roles to a user
   * @param userId - User ID
   * @param roleNames - Array of role names
   */
  assignRolesToUser(userId: number, roleNames: string[]): Promise<void>;

  // --- Role Management ---
  /**
   * Get a list of roles
   * @param params - Optional parameters for pagination
   */
  getRoles(params?: { limit?: number; offset?: number }): Promise<RoleListResponse>;
  
  /**
   * Create a new role
   * @param data - Role creation data
   */
  createRole(data: CreateRoleRequest): Promise<Role>;
  
  /**
   * Update an existing role
   * @param id - Role ID
   * @param data - Role update data
   */
  updateRole(id: number, data: UpdateRoleRequest): Promise<Role>;
  
  /**
   * Delete a role
   * @param id - Role ID
   */
  deleteRole(id: number): Promise<void>;

  // --- Permission Management ---
  /**
   * Get a list of all available permissions
   */
  getPermissions(): Promise<PermissionListResponse>;

  /** Initialize the API client */
  initialize(): Promise<void>;
  /**
   * Classify a description using AI
   * @param description - Text to classify
   * @param systemCode - Optional classification system code
   * @param additionalContext - Optional context for classification
   * @param modelOverride - Optional LLM model to use for this classification
   */
  classify(
    description: string,
    systemCode?: string,
    additionalContext?: string,
    modelOverride?: string
  ): Promise<ClassificationResult>;

  /**
   * Manually classify a description
   * @param request - Manual classification request
   */
  classifyManually(
    request: ManualClassificationRequest
  ): Promise<ClassificationResult>;

  /**
   * Classify multiple items in batch
   * @param request - Batch classification request
   */
  classifyBatch(
    request: BatchClassificationRequest
  ): Promise<BatchClassificationResult>;

  /**
   * Get status of a batch classification
   * @param batchId - ID of the batch
   */
  getBatchStatus(
    batchId: string
  ): Promise<BatchClassificationResult>;

  /** Get all classification systems */
  getClassificationSystems(): Promise<ClassificationSystem[]>;

  /**
   * Get a specific classification system with its levels
   * @param code - System code
   */
  getClassificationSystem(code: string): Promise<{
    system: ClassificationSystem;
    levels: ClassificationLevel[];
  }>;

  /**
   * Get categories for a system level
   * @param req - System categories request
   */
  getSystemCategories(
    req: SystemCategoriesRequest
  ): Promise<Category[]>;

  /**
   * Get classification history
   * @param req - History request parameters
   */
  getClassificationHistory(
    req: ClassificationHistoryRequest
  ): Promise<ClassificationHistoryPage>;

  /** Get current LLM configuration */
  getConfig(): Promise<LlmConfig>;

  /**
   * Update LLM configuration
   * @param config - New configuration
   */
  updateConfig(config: UpdateConfigRequest): Promise<void>;

  /** rerun classification for a specific history entry
   * @param id - ID of the classification history entry
  */
  rerunClassification(id: string): Promise<ClassificationResult>; // id should likely be string or number, consistent with HistoryTab

  /** delete a classification history entry
   * @param id - ID of the classification history entry
  */
  deleteClassification(id: string): Promise<void>; // id should likely be string or number

  getBatchJobs(params: BatchJobParams): Promise<BatchJobsPage>;
  /** Get a paginated list of RAG information entries */

  getRagInfoList(params: RagInfoRequestParams): Promise<RagInfoPage>;

  /** Create a new RAG information entry */
  createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem>;

  /** Get a specific RAG information entry by ID */
  getRagInfoItem(id: string): Promise<RagInfoItem>; // Added for editing

  /** Update a RAG information entry by ID */
  updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem>;

  /** Delete a RAG information entry by ID */
  deleteRagInfo(id: string): Promise<void>;

  /**
   * Delete a classification history entry
   * @param id - ID of the classification history entry
   */
  deleteClassificationHistory(id: string): Promise<void>;

  // --- RAG Information Management ---
  /**
   * Get a list of RAG information items
   * @param params - Optional parameters for pagination and searching
   */
  // getRagInfoList(params?: RagInfoRequestParams): Promise<RagInfoPage>; // Already declared above

  /**
   * Get a specific RAG information item
   * @param id - RAG information item ID
   */
  getRagInfo(id: string): Promise<RagInfoItem>;

  /**
   * Create a new RAG information item
   * @param data - RAG information creation data
   */
  // createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem>; // Already declared above

  /**
   * Update an existing RAG information item
   * @param id - RAG information item ID
   * @param data - RAG information update data
   */
  // updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem>; // Already declared above

  /**
   * Delete a RAG information item
   * @param id - RAG information item ID
   */
  // deleteRagInfo(id: string): Promise<void>; // Already declared above

  /** Get current configuration */
  // getConfig(): Promise<LlmConfig>; // Already declared above

  /** Update configuration */
  // updateConfig(configUpdate: UpdateConfigRequest): Promise<void>; // Already declared above

   /**
   * Query RAG for context (used by internal services, might not be exposed to UI directly)
   * @param question - The query string
   */
   queryRag(question: string): Promise<any>; // Define 'any' for now, can be more specific if response structure is known

  // Generic HTTP methods that should be implemented by the concrete ApiClient
  // get<T>(url: string, config?: any): Promise<T>;
  // post<T>(url: string, data?: any, config?: any): Promise<T>;
  // put<T>(url: string, data?: any, config?: any): Promise<T>;
  // delete<T>(url: string, config?: any): Promise<T>;
}

// --- RAG Information Types ---

export interface RagInfoItem {
  id: string; // Or number, depending on backend
  key: string;
  description: string;
  createdAt: string; // ISO Date string
  updatedAt: string; // ISO Date string
}

export interface RagInfoPage {
  items: RagInfoItem[];
  totalCount: number;
  totalPages: number;
  currentPage: number;
}

export interface RagInfoRequestParams {
  page?: number;
  limit?: number;
  search?: string; // Filter by key or description
}

export interface CreateRagInfoRequest {
  key: string;
  description: string;
}

export interface UpdateRagInfoRequest {
  key?: string; // Optional: Allow updating key? Decide based on backend
  description?: string;
}

// Authentication Types
export interface LoginResponse {
  token: string;
  user: User;
}

export interface User {
  id: number;
  username: string;
  roles: string[];      // Array of role names
  permissions?: string[]; // Array of permission codes (calculated on backend)
  createdAt?: string;
  updatedAt?: string;
}

// RBAC Types
export interface Role {
  id: number;
  name: string;
  description?: string;
  permissions?: Permission[]; // Permissions associated with the role
}

export interface Permission {
  id: number;
  code: string;          // e.g., 'users:manage', 'classify:item'
  description?: string;
}

// Request/Response for User Management
export interface UserListResponse {
  items: User[];
  totalCount: number;
  // Add pagination if needed
}

export interface CreateUserRequest {
  username: string;
  password?: string; // Required on create
  roles: string[]; // Assign roles by name
}

export interface UpdateUserRequest {
  username?: string; // Optional update
  password?: string; // Optional: For password change
  roles?: string[];  // Optional: For updating roles
}

// Request/Response for Role Management
export interface RoleListResponse {
  items: Role[];
  totalCount: number;
}

export interface CreateRoleRequest {
  name: string;
  description?: string;
  permissions: string[]; // Assign permissions by code
}

export interface UpdateRoleRequest {
  name?: string;
  description?: string;
  permissions?: string[];
}

// Request/Response for Permissions (likely just GET list)
export interface PermissionListResponse {
  items: Permission[];
  totalCount: number;
}

// Configuration Types
export interface LlmConfig {
  server?: {
    host: string;
    port: number;
    requestTimeout: string;
    logLevel: string;
  };  service?: {
    batchSize: number;
    dataPath: string;
    commonDataPath: string;
    excelPattern: string;
    llmEndpoint: string;
    llmApiKey: string;
    llmModel: string;
    llmRetryModels?: string[];
    llmMaxTokens: number;
    llmTemperature: number;
    useTypePrompt: boolean;
    maxSkipLogs: number;
    unspscExcelLoader: {
      filePath: string;
      sheetName: string;
      levelHeaders: Array<{
        dbLevelCode: string;
        codeHeader: string;
        titleHeader: string;
      }>;
    };
    commonExcelLoader: {
      filePath: string;
      sheetName: string;
      level1HeaderName: string;
    };
  };
  database?: {
    host: string;
    port: number;
    user: string;
    password: string;
    name: string;
    dataPath: string;
    ragServiceUrl: string;
    ragEnabled: boolean;
    ragManualInfoCollection: string;
    ragUnspscCollection: string;
    ragCommonCollection: string;
  };
  validation?: {
    maxHistoryLimit: number;
    tokenLimit: number;
    defaultTimeout: string;
  };
  alert?: {
    emailSettings: {
      smtpHost: string;
      smtpPort: number;
      smtpUser: string;
      smtpPassword: string;
      fromEmail: string;
    };
    webhookSettings: {
      url: string;
    };
  };
  
  auth?: {
    enabled: boolean;
    jwtSecret: string;
    jwtExpirationHours: number; 
    initialAdminUser: string;
    initialAdminPassword?: string;
  };
  
  // Keep these for backward compatibility
  llmEndpoint?: string;
  llmApiKey?: string;
  ragEnabled?: boolean;
}

// --- Helper types for config update API ---
// These types provide structure for the update API but don't replace the main LlmConfig interface

export interface UpdateServerConfig {
  logLevel?: string;
  requestTimeout?: string; // e.g., "60s"
}

export interface UpdateServiceConfig {
  llmEndpoint?: string;
  llmApiKey?: string; // Allow sending new key, BEWARE: sent in plain text
  llmModel?: string;
  llmRetryModels?: string[];
  llmMaxTokens?: number;
  llmTemperature?: number;
  useTypePrompt?: boolean;
  maxSkipLogs?: number;
}

export interface UpdateDatabaseConfig {
  ragEnabled?: boolean;
  ragServiceUrl?: string;
  ragManualInfoCollection?: string;
  ragUnspscCollection?: string;
  ragCommonCollection?: string;
}

export interface UpdateValidationConfig {
  maxHistoryLimit?: number;
  tokenLimit?: number;
  defaultTimeout?: string; // e.g., "15s"
}

export interface UpdateEmailSettings {
  smtpHost?: string;
  smtpPort?: number;
  smtpUser?: string;
  smtpPassword?: string; // Allow sending new password, BEWARE: sent in plain text
  fromEmail?: string;
}

export interface UpdateWebhookSettings {
  url?: string;
}

export interface UpdateAlertConfig {
  emailSettings?: UpdateEmailSettings;
  webhookSettings?: UpdateWebhookSettings;
}

export interface UpdateAuthConfig {
  enabled?: boolean;
  jwtExpirationHours?: number;
}

// Main Update Request Payload structure
export interface UpdateConfigRequest {
  server?: UpdateServerConfig;
  service?: UpdateServiceConfig;
  database?: UpdateDatabaseConfig;
  validation?: UpdateValidationConfig;
  alert?: UpdateAlertConfig;
  auth?: UpdateAuthConfig;
}

// --- Ensure LlmConfig Interface is up-to-date ---
export interface ServerConfig {
  host?: string;
  port?: number;
  requestTimeout?: string;
  logLevel?: string;
}

export interface LevelHeaderPair {
  dbLevelCode?: string;
  codeHeader?: string;
  titleHeader?: string;
}

export interface UnspscExcelLoaderConfig {
  filePath?: string;
  sheetName?: string;
  levelHeaders?: LevelHeaderPair[];
}

export interface CommonExcelLoaderConfig {
  filePath?: string;
  sheetName?: string;
  level1HeaderName?: string;
}

export interface ServiceConfig {
  batchSize?: number;
  dataPath?: string;
  commonDataPath?: string;
  excelPattern?: string;
  llmEndpoint?: string;
  llmApiKey?: string; // Expect "[REDACTED]" or similar mask from GET
  llmModel?: string;
  llmRetryModels?: string[];
  llmMaxTokens?: number;
  llmTemperature?: number;
  useTypePrompt?: boolean;
  maxSkipLogs?: number;
  batchRetryLimit?: number;
  unspscExcelLoader?: UnspscExcelLoaderConfig;
  commonExcelLoader?: CommonExcelLoaderConfig;
}

export interface DatabaseConfig {
  host?: string;
  port?: number;
  user?: string;
  password?: string; // Expect "[REDACTED]"
  name?: string;
  dataPath?: string;
  ragServiceUrl?: string;
  ragEnabled?: boolean;
  ragManualInfoCollection?: string;
  ragUnspscCollection?: string;
  ragCommonCollection?: string;
}

export interface ValidationConfig {
  maxHistoryLimit?: number;
  tokenLimit?: number;
  defaultTimeout?: string;
}

export interface EmailSettings {
  smtpHost?: string;
  smtpPort?: number;
  smtpUser?: string;
  smtpPassword?: string; // Expect "[REDACTED]"
  fromEmail?: string;
}

export interface WebhookSettings {
  url?: string;
}

export interface AlertConfig {
  emailSettings?: EmailSettings;
  webhookSettings?: WebhookSettings;
}

export interface AuthConfig {
  enabled?: boolean;
  jwtSecret?: string; // Expect "[REDACTED]"
  jwtExpirationHours?: number;
  initialAdminUser?: string;
  initialAdminPassword?: string; // Expect "[REDACTED]"
}

// Core Domain Types
export interface ClassificationSystem {
  id: number;
  code: string;
  name: string;
  description?: string;
  enabled: boolean;
  createdAt: string;
}

export interface ClassificationLevel {
  id: number;
  systemId: number; 
  levelNumber: number; 
  code: string;
  name: string;
  description?: string;
  validationRegex?: string; 
}

export interface Category {
  id: number;
  systemId: number;
  code: string;
  name: string;
  description?: string;
  levelCode: string; 
  parentCode?: string;
  createdAt: string;
}

export interface CategoryLevel {
  code: string;
  name: string;
  description?: string;
  error?: string;
}

// Classification Types
export interface ClassificationResult {
  system_code: string;
  description: string;
  levels: { [key: string]: CategoryLevel }; // key is level_code
  status: 'success' | 'failed' | 'partial';
  error?: string;
  timestamp: string; // ISO Date string
  ragContextUsed: boolean;
  ragContext?: string;
  levelResponses?: { [key: string]: string }; // Level-specific LLM responses
  firstLevelPrompt?: string; // Renamed from prompt to match backend changes
  allPromptsDetail?: string; // JSON string of all prompts
  modelUsed?: string;
}

export interface ClassificationError {
  message: string;
  code?: string;
  level?: string;
}

// Request Types
export interface ClassificationRequest {
  ItemID?: string; // Changed from item_id to ItemID
  Name?: string;   // Changed from name to Name
  description: string;
  systemCode?: string; // Changed from system_code to systemCode
  additionalContext?: string; // Changed from additional_context to additionalContext
  levels?: { [key: string]: string }; // For manual classification
  IsManual?: boolean; // Changed from is_manual to IsManual
  key?: string; // Unique key identifier for the item
}

export interface ManualClassificationRequest {
  description: string;
  systemCode: string;
  selectedSystem?: string; // Optional based on your backend expectation, usually same as systemCode
  additionalContext?: string;
  modelOverride?: string; // Optional LLM model override for classification
  levels: { [levelCode: string]: string };
}

export interface SystemCategoriesRequest {
  systemCode: string;
  level: string;
  parentCode?: string;
  search?: string;
}

export interface BatchClassificationRequest {
  items: Array<{
    description: string;
    additionalContext?: string;
    key?: string; // Include key field to identify batch items
  }>;
  systemCode?: string; // Changed from system_code to systemCode
  key_column_names?: string[]; 
}

// Response Types
export interface BatchClassificationResult {
  results?: BatchItemResult[]; 
  id: string;
  status: string;
  timestamp: string;
  Results?: BatchItemResult[]; // Kept for backward compatibility if backend sends this casing
  error?: string;
  system_code?: string;  
  updated_at?: string;
  totalItems?: number; 
  processedItems?: number; 
  keyColumnNames?: string[]; 
  systemCode?: string; 
}

export interface BatchItemResult {
  description: string;
  additional_context?: string;
  result?: ClassificationResult;
  error?: string | ClassificationError; 
  key?: string; 
  prompt?: string; // This is likely the first-level prompt used for this item
  allPromptsDetail?: string; // This is the JSON string of all prompts for this item
}

export interface BatchJobParams {
  cursor?: string;
  limit?: number;
  status?: string;
  startDate?: string; 
  endDate?: string;   
}

export interface BatchJobsPage {
  items: BatchClassificationResult[];
  totalCount: number;
  nextCursor?: string;
}

// History Types
export interface ClassificationHistory {
  id: number; 
  description: string;
  systemCode: string;
  additionalContext?: string;
  levels: { [key: string]: CategoryLevel };
  createdAt: string; 
  status: 'success' | 'failed' | 'partial';
  createdBy: string;
  sourceType: 'user' | 'batch' | 'manual' | 'api';
  ragContextUsed: boolean;
  ragContext?: string;
  error?: string;
  levelResponses?: { [key: string]: string }; 
  firstLevelPrompt?: string; // Renamed from prompt
  key?: string; 
  allPromptsDetail?: string; // JSON string of all prompts
  modelUsed?: string; 
}

export interface ClassificationHistoryPage {
  items: ClassificationHistory[];
  totalCount: number;
  nextCursor?: string;
}

// Request parameters for fetching classification history
export interface ClassificationHistoryRequest {
  systemCode?: string;
  limit?: number;
  cursor?: string;
  status?: string;
  startDate?: string;
  endDate?: string;
  search?: string; 
  sourceType?: string;
  createdBy?: string;
}

// Status Types

export type ClassificationStatus = 'all' | 'success' | 'partial' | 'failed';
export type BatchStatus = 'pending' | 'processing' | 'completed' | 'error';

export type ClassificationSourceType  = 'user' | 'batch' | 'api' | 'manual' | ''; // Allow empty for 'all'

export type BatchJobStatusFilterType = BatchStatus | 'all';

File: src/api/role.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { RoleListResponse, CreateRoleRequest, UpdateRoleRequest, Role } from './types';

export class RoleService {
    constructor(private core: ApiClientCore) {}

    async getRoles(params?: { limit?: number; offset?: number }): Promise<RoleListResponse> {
        const urlParams = new URLSearchParams();
        if (params?.limit) urlParams.append('limit', params.limit.toString());
        if (params?.offset) urlParams.append('offset', params.offset.toString());
        const url = `${formatEndpoint('/roles')}${urlParams.toString() ? '?' + urlParams.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to get roles");
            }
            return await response.json();
        } catch (error) {
            console.error(`Get roles error:`, error);
            throw error;
        }
    }

    async createRole(data: CreateRoleRequest): Promise<Role> {
        const url = formatEndpoint('/roles');
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to create role");
            }
            return await response.json();
        } catch (error) {
            console.error(`Create role error:`, error);
            throw error;
        }
    }

    async updateRole(id: number, data: UpdateRoleRequest): Promise<Role> {
        const url = formatEndpoint(`/roles/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to update role");
            }
            return await response.json();
        } catch (error) {
            console.error(`Update role error:`, error);
            throw error;
        }
    }

    async deleteRole(id: number): Promise<void> {
        const url = formatEndpoint(`/roles/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to delete role");
            }
        } catch (error) {
            console.error(`Delete role error:`, error);
            throw error;
        }
    }
}

File: tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [
    { "path": "./tsconfig.node.json" }
  ]
}

File: vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// Define your backend targets
const GO_BACKEND_TARGET = 'http://localhost:8081'; 
const PYTHON_LANGGRAPH_BACKEND_TARGET = 'http://localhost:8090'; 

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      // Rule for /v1/lg-vis/ws path - WebSocket (most specific for lg-vis)
      // This must come BEFORE other /v1/lg-vis and /v1 rules
      '/v1/lg-vis/ws': { 
        target: PYTHON_LANGGRAPH_BACKEND_TARGET, // Target Python server for WS
        ws: true, // Enable WebSocket proxying
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY PYTHON V1-WS] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY PYTHON V1-WS] Sending WS Request to Python:', req.method, proxyReq.path);
          });
        }
      },

      // Rule for /v1/lg-vis/... path (Python HTTP)
      // This must come BEFORE the /v1 rule
      '/v1/lg-vis': {
        target: PYTHON_LANGGRAPH_BACKEND_TARGET, // Python backend
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS] Sending Request to Python:', req.method, proxyReq.path);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS] Received Response from Python:', proxyRes.statusCode, req.url);
          });
        },
      },
      
      // --- Proxy for direct /lg-vis/ws path (obsolete WebSocket)
      // Kept for compatibility, ensure it's specific enough
      '/lg-vis/ws': { 
        target: PYTHON_LANGGRAPH_BACKEND_TARGET, // Target Python server for WS
        ws: true, // Enable WebSocket proxying
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY PYTHON OBSOLETE WS] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY PYTHON OBSOLETE WS] Sending WS Request to Python:', req.method, proxyReq.path);
          });
        }
      },

      // --- Proxy for direct /lg-vis/... path (obsolete HTTP)
      // Kept for compatibility
      '/lg-vis': {
        target: PYTHON_LANGGRAPH_BACKEND_TARGET, // Python backend
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY PYTHON OBSOLETE LG-VIS] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY PYTHON OBSOLETE LG-VIS] Sending Request to Python:', req.method, proxyReq.path);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('[PROXY PYTHON OBSOLETE LG-VIS] Received Response from Python:', proxyRes.statusCode, req.url);
          });
        },
      },
      
      // --- Proxy for existing Go RAG API ---
      // This will catch other /v1/... paths that are not for LangGraph
      '/v1': {
        target: GO_BACKEND_TARGET, // Go backend
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY GO V1] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY GO V1] Sending Request to Go:', req.method, proxyReq.path);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('[PROXY GO V1] Received Response from Go:', proxyRes.statusCode, req.url);
          });
        },
      },
    },
    port: 5173, // Your frontend dev port
    host: true,
  },
});


File: start-web.bat
@echo off
setlocal EnableDelayedExpansion

REM Constants
set "CONFIG_FILE=config\config.yaml"
set "SCRIPT_NAME=%~nx0"
set "REQUIRED_NODE_VERSION=16"

REM Initialize error handling
set "EXIT_SUCCESS=0"
set "EXIT_CONFIG_ERROR=1"
set "EXIT_PNPM_ERROR=2"
set "EXIT_NODE_ERROR=3"
set "EXIT_PORT_ERROR=4"

REM Prevent OpenSSL from looking for config
set "OPENSSL_CONF="
set "NODE_OPTIONS=--no-node-snapshot"

REM Parse parameters
set "USE_LOG_FILE="
if "%~1"=="-log" set "USE_LOG_FILE=1"

:main
    call :init
    if errorlevel 1 exit /b %errorlevel%
    
    call :check_prerequisites
    if errorlevel 1 exit /b %errorlevel%
    
    call :setup_dependencies
    if errorlevel 1 exit /b %errorlevel%
    
    call :start_web
    exit /b %errorlevel%

:init
    echo [%date% %time%] Starting %SCRIPT_NAME%...
    
    REM Check config file
    if not exist "%CONFIG_FILE%" (
        echo ERROR: %CONFIG_FILE% file not found
        exit /b %EXIT_CONFIG_ERROR%
    )
    
    REM Extract port from config.yaml
    for /f "tokens=2 delims=:" %%a in ('findstr /C:"port: " "%CONFIG_FILE%"') do (
        set "SERVER_PORT=%%a"
        set "SERVER_PORT=!SERVER_PORT: =!"
    )
    
    if not defined SERVER_PORT (
        echo ERROR: Unable to find port in %CONFIG_FILE%
        exit /b %EXIT_CONFIG_ERROR%
    )
    exit /b %EXIT_SUCCESS%

:check_prerequisites
    REM Check Node.js installation
    where node >nul 2>&1
    if %errorlevel% neq 0 (
        echo ERROR: Node.js is not installed
        exit /b %EXIT_NODE_ERROR%
    )

    REM Check Node.js version
    for /f "tokens=1 delims=." %%a in ('node -v') do (
        set "NODE_VERSION=%%a"
        set "NODE_VERSION=!NODE_VERSION:v=!"
        if !NODE_VERSION! lss %REQUIRED_NODE_VERSION% (
            echo ERROR: Node.js version %REQUIRED_NODE_VERSION% or higher required
            exit /b %EXIT_NODE_ERROR%
        )
    )

    REM Check pnpm installation
    where pnpm >nul 2>&1
    if %errorlevel% neq 0 (
        echo ERROR: pnpm is not installed
        echo Install it with: npm install -g pnpm
        exit /b %EXIT_PNPM_ERROR%
    )
    exit /b %EXIT_SUCCESS%

:setup_dependencies
    REM Check and install dependencies using pnpm
    if not exist "node_modules" (
        echo Installing dependencies...
        call pnpm install
        if !errorlevel! neq 0 (
            echo ERROR: Failed to install dependencies
            exit /b %EXIT_PNPM_ERROR%
        )
    )
    exit /b %EXIT_SUCCESS%

:check_port
    set "port_in_use="
    for /f "tokens=5" %%a in ('netstat -ano ^| findstr /R ":%SERVER_PORT%\>"') do (
        if not defined port_in_use (
            set "port_in_use=%%a"
        )
    )
    
    if defined port_in_use (
        echo Port %SERVER_PORT% is being used by process ID !port_in_use!
        choice /C YN /M "Do you want to terminate this process?"
        if !errorlevel!==1 (
            REM Check administrative privileges only when needed
            net session >nul 2>&1
            if %errorlevel% neq 0 (
                echo ERROR: Administrative privileges required to terminate process
                echo Please run 'taskkill /PID !port_in_use! /F' in an elevated command prompt
                exit /b %EXIT_PORT_ERROR%
            )
            
            taskkill /PID !port_in_use! /F
            if !errorlevel! neq 0 (
                echo ERROR: Failed to terminate process !port_in_use!
                echo Please manually terminate the process using: taskkill /PID !port_in_use! /F
                exit /b %EXIT_PORT_ERROR%
            )
            echo Process !port_in_use! terminated
            timeout /t 2 /nobreak >nul
        ) else (
            echo Please free up port %SERVER_PORT% and try again
            exit /b %EXIT_PORT_ERROR%
        )
    )
    exit /b %EXIT_SUCCESS%

:start_web
    call :check_port
    if errorlevel 1 exit /b %errorlevel%

    echo Starting development server on port %SERVER_PORT%...
    
    REM Start development server with appropriate logging
    if defined USE_LOG_FILE (
        pnpm run dev > "logs\web.log" 2>&1
    ) else (
        pnpm run dev
    )
    
    if errorlevel 1 (
        if defined USE_LOG_FILE (
            echo ERROR: Failed to start web server. Check logs\web.log for details
        ) else (
            echo ERROR: Failed to start web server
        )
        exit /b %errorlevel%
    )
    exit /b %EXIT_SUCCESS%

:end
endlocal


File: tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
        },
        secondary: {
          50: '#f8fafc',
          100: '#f1f5f9',
          200: '#e2e8f0',
          300: '#cbd5e1',
          400: '#94a3b8',
          500: '#64748b',
          600: '#475569',
          700: '#334155',
          800: '#1e293b',
          900: '#0f172a',
        },
      },
      borderRadius: {
        'card': '0.5rem',
      },
      boxShadow: {
        'card': '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
        'card-hover': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
      },
    },
  },
  plugins: [],
}

File: postcss.config.js
module.exports = {
  plugins: {
    'postcss-import': {},
    'postcss-nesting': {}, // Add explicit postcss-nesting plugin
    tailwindcss: {},
    autoprefixer: {},
  }
}


.