Files:
File: src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import 'reactflow/dist/style.css'; // Import React Flow styles
import 'antd/dist/reset.css'; // Import Ant Design styles (updated path)
import { AuthProvider } from './context/AuthContext'; // Import AuthProvider
import { WebApiClient } from './api/client'; // Import client

const apiClientInstance = new WebApiClient(); // Create single client instance

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <AuthProvider apiClientInstance={apiClientInstance}> {/* Wrap App */}
      <App />
    </AuthProvider>
  </React.StrictMode>
);

File: src/utils/dateFormat.ts
interface DateFormatOptions {
  /** Whether to include timezone in the full format */
  includeTimezone?: boolean;
  /** Whether to use 24-hour format */
  hour24?: boolean;
  /** Custom Intl.DateTimeFormat options for display text */
  displayOptions?: Intl.DateTimeFormatOptions;
  /** Custom Intl.DateTimeFormat options for tooltip text */
  tooltipOptions?: Intl.DateTimeFormatOptions;
}

interface FormattedDate {
  /** Short format for display (e.g., "Mar 28, 2025, 17:30") */
  displayText: string;
  /** Full format for tooltip (e.g., "Mar 28, 2025, 17:30 GST") */
  fullText: string;
}

const defaultDisplayOptions: Intl.DateTimeFormatOptions = {
  year: 'numeric',
  month: 'short',
  day: 'numeric',
  hour: '2-digit',
  minute: '2-digit',
  hour12: false
};

const defaultTooltipOptions: Intl.DateTimeFormatOptions = {
  ...defaultDisplayOptions,
  timeZoneName: 'short'
};

/**
 * Format a date string with display text and tooltip text
 * @param dateStr - ISO date string to format
 * @param options - Formatting options
 * @returns Object with displayText and fullText properties
 */
export const formatDate = (
  dateStr: string | undefined | null,
  options: DateFormatOptions = {}
): FormattedDate => {
  if (!dateStr) {
    return { displayText: 'N/A', fullText: 'N/A' };
  }

  try {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      console.error('Invalid date string:', dateStr);
      return { displayText: 'Invalid Date', fullText: 'Invalid Date' };
    }

    const {
      hour24 = true,
      includeTimezone = true,
      displayOptions: customDisplayOptions = {},
      tooltipOptions: customTooltipOptions = {}
    } = options;

    // Merge custom options with defaults
    const displayOpts: Intl.DateTimeFormatOptions = {
      ...defaultDisplayOptions,
      ...customDisplayOptions,
      hour12: !hour24
    };

    const tooltipOpts: Intl.DateTimeFormatOptions = {
      ...defaultTooltipOptions,
      ...customTooltipOptions,
      hour12: !hour24,
      timeZoneName: includeTimezone ? 'short' : undefined
    };

    const displayText = new Intl.DateTimeFormat('default', displayOpts).format(date);
    const fullText = new Intl.DateTimeFormat('default', tooltipOpts).format(date);

    return { displayText, fullText };
  } catch (e) {
    console.error('Error formatting date:', dateStr, e);
    return { displayText: 'Invalid Date', fullText: 'Invalid Date' };
  }
};

File: src/utils/statusUtils.ts
// src/utils/statusUtils.ts
import { ClassificationStatus } from '../api/types';
import { SnowValidationStatus } from '../snow/types/snow.types';

/**
 * Contains common informational messages that are displayed when classification
 * has specific non-critical errors, partial results, or has failed.
 * These messages are considered "informational" because they provide context
 * about why a classification might be partial or failed, rather than
 * being actual application errors.
 */
export const INFORMATIONAL_ERROR_MESSAGES = [
  "Classification failed to determine required levels",
  "Classification failed to determine required levels.",
  "No matching category found at this level",
  "Failed to classify at this level",
  "Classification is partial; some levels may be missing or invalid.",
  "Classification is partial.", // Matches backend's informational message for partial
  "Classification failed.",   // Matches backend's informational message for failed
];

/**
 * Determines if an error message is considered "informational" rather than a critical error.
 * @param errorMessage The error message to check
 * @returns Boolean indicating if the message is informational
 */
export const isInformationalError = (errorMessage?: string): boolean => {
  if (!errorMessage) return false;
  const lowerMessage = errorMessage.toLowerCase();
  return INFORMATIONAL_ERROR_MESSAGES.some(msg => lowerMessage.includes(msg.toLowerCase()));
};

/**
 * Get a color for the Categorization classification status
 * @param status The classification status
 * @returns A color string (success, warning, error)
 */
export const getClassificationStatusColor = (status: ClassificationStatus): string => {
  switch(status) {
    case 'success': return 'success';
    case 'partial': return 'warning';
    case 'failed': return 'error';
    case 'all': return 'default';
    default: return 'default';
  }
};

/**
 * Get a color for the ServiceNow validation status
 * @param status The SNOW validation status
 * @returns A color string (success, error)
 */
export const getSnowValidationStatusColor = (status: SnowValidationStatus): string => {
  return status === 'pass' ? 'success' : 'error';
};

/**
 * Returns a human-readable description of a Categorization classification status
 * @param status The classification status
 * @returns Human-readable description
 */
export const getClassificationStatusDescription = (status: ClassificationStatus): string => {
  switch(status) {
    case 'success': return 'Classification was successful with all required levels';
    case 'partial': return 'Classification is partial; some levels may be missing or invalid';
    case 'failed': return 'Classification failed to determine required levels';
    case 'all': return 'All statuses';
    default: return status;
  }
};

/**
 * Returns a human-readable description of a ServiceNow validation status
 * @param status The SNOW validation status
 * @returns Human-readable description
 */
export const getSnowValidationStatusDescription = (status: SnowValidationStatus): string => {
  switch(status) {
    case 'pass': return 'Ticket meets all validation criteria and quality standards';
    case 'fail': return 'Ticket fails to meet quality standards and requires improvement';
    default: return status;
  }
};


File: src/App.tsx
// src/App.tsx
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useLocation, Outlet } from 'react-router-dom';
import { useAuth } from './context/AuthContext'; // <<< Use the hook
import PageLayout from './components/Layout/PageLayout';
import TestPage from './pages/TestPage';
import BatchPage from './pages/BatchPage';
import BatchJobsPage from './pages/BatchJobsPage';
import HistoryPage from './pages/HistoryPage';
import SettingsPage from './pages/SettingsPage';
import RagInfoPage from './pages/RagInfoPage';
import LoginPage from './pages/LoginPage';
import UserManagementPage from './pages/UserManagementPage'; 
import RoleManagementPage from './pages/RoleManagementPage';   
import './App.css';
import { Spin } from 'antd'; // For loading indicator
import ChatPage from './pages/ChatPage';

// Assuming these components exist in the specified path
import LangGraphListPage from './langgraph/pages/LangGraphListPage'; 
import LangGraphViewPage from './langgraph/pages/LangGraphViewPage';
import LangGraphCreatePage from './langgraph/pages/LangGraphCreatePage';
import LangGraphEditPage from './langgraph/pages/LangGraphEditPage';

// SNOW imports
import SnowAnalyzePage from './snow/pages/SnowAnalyzePage'; 
import SnowHistoryPage from './snow/pages/SnowHistoryPage'; 
import { SolutionOutlined } from '@ant-design/icons'; // Example icon, choose/import appropriately

// --- Protected Route Component ---
interface ProtectedRouteProps {
    isAllowed: boolean;
    redirectPath?: string;
    children?: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
    isAllowed,
    redirectPath = '/login',
    children,
}) => {
    const location = useLocation();

    if (!isAllowed) {
        // Redirect them to the /login page, but save the current location they were
        // trying to go to when they were redirected. This allows us to send them
        // along to that page after they login, which is a nicer user experience
        // than dropping them off on the home page.
        return <Navigate to={redirectPath} state={{ from: location }} replace />;
    }

    return children ? <>{children}</> : <Outlet />; // Render children or Outlet
};
// --- End Protected Route Component ---

function App() {
  const {
    isAuthenticated,
    loading,
    authEnabled,
    checkPermission, // Get checkPermission from context
    apiClient,       // Get apiClient from context
    logout,          // Get logout from context
    handleLoginSuccess: contextLoginSuccess // Rename for clarity
  } = useAuth();

  // RAG enabled status (can also be moved to context if needed globally)
  const [ragEnabled, setRagEnabled] = useState<boolean | null>(null);
  const [ragStatusFetched, setRagStatusFetched] = useState(false);
  
  useEffect(() => {
    const fetchRagStatus = async () => {
       try {
            const config = await apiClient.getConfig();
            
            // Log the full config for debugging, pretty-printed
            console.log("[DEBUG] Full config response from apiClient.getConfig():", JSON.stringify(config, null, 2));
            
            // Determine RAG status solely from the correct nested property
            const isRagEnabled = !!config?.database?.ragEnabled;
            
            console.log('[App.tsx] RAG enabled status determined:', isRagEnabled, 'Value from config.database.ragEnabled:', config?.database?.ragEnabled);
            
            setRagEnabled(isRagEnabled);
       } catch (e) { 
          console.error("Failed to get RAG status from API, defaulting to false.", e); 
          setRagEnabled(false); // Ensure it defaults to false on API error
       } finally {
          setRagStatusFetched(true);
       }
    };
    fetchRagStatus();
  }, [apiClient]);

  // Use a dummy handleLoginSuccess if context doesn't provide one directly
  const handleLoginSuccess = () => {
      console.log("Login successful callback in App.tsx");
      contextLoginSuccess();
  };

  // Use the logout function from context
  const handleLogout = () => {
      logout();
  };

  if (loading || authEnabled === null || !ragStatusFetched) { // Wait for context loading & RAG status
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Spin size="large" />
      </div>
    );
  }

  return (
    <Router>
      <Routes>
        {/* Public Login Route */}
        <Route
          path="/login"
          element={
            isAuthenticated && authEnabled ? ( // Redirect only if auth is enabled AND logged in
              <Navigate to="/" replace />
            ) : (
              <LoginPage apiClient={apiClient} onLoginSuccess={handleLoginSuccess} />
            )
          }
        />

        {/* Protected Application Routes */}
        <Route
          element={
            <ProtectedRoute isAllowed={!authEnabled || isAuthenticated}>
                <PageLayout ragEnabled={!!ragEnabled} onLogout={handleLogout} />
             </ProtectedRoute>
          }
        >
              <Route index element={<Navigate to="/test" replace />} />
              {/* Apply permission checks inline or via a wrapper component */}
              <Route path="/test" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('classify:item')}><TestPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/batch" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('classify:batch')}><BatchPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/batch/jobs" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('classify:batch')}><BatchJobsPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/history" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('history:view')}><HistoryPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/rag-info" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('rag:view')}><RagInfoPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/chat" element={
                <ProtectedRoute isAllowed={!authEnabled || checkPermission('chat:use')}> {/* Example permission */}
                  <ChatPage />
                </ProtectedRoute>
              } />
              <Route path="/settings" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('config:view')}><SettingsPage apiClient={apiClient} /></ProtectedRoute>} />

              {/* Admin Routes */}
              <Route path="/admin/users" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('users:manage')}><UserManagementPage apiClient={apiClient} /></ProtectedRoute>} />
              <Route path="/admin/roles" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('roles:manage')}><RoleManagementPage apiClient={apiClient} /></ProtectedRoute>} />              {/* LangGraph Routes */}
              <Route path="/langgraph" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('langgraph:view')}><LangGraphListPage /></ProtectedRoute>} />
              <Route path="/langgraph/view/:graphId" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('langgraph:view')}><LangGraphViewPage /></ProtectedRoute>} />
              <Route path="/langgraph/create" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('langgraph:create')}><LangGraphCreatePage /></ProtectedRoute>} />
              <Route path="/langgraph/edit/:graphId" element={<ProtectedRoute isAllowed={!authEnabled || checkPermission('langgraph:edit')}><LangGraphEditPage /></ProtectedRoute>} />

              {/* ServiceNow (SNOW) Routes */}
              <Route
                path="/snow/analyze"
                element={
                  <ProtectedRoute isAllowed={!authEnabled || checkPermission('snow:analyze')}>
                    <SnowAnalyzePage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/snow/history"
                element={
                  <ProtectedRoute isAllowed={!authEnabled || checkPermission('snow:history:view')}>
                    <SnowHistoryPage />
                  </ProtectedRoute>
                }
              />

              <Route path="*" element={<Navigate to="/test" replace />} />
        </Route>
      </Routes>
    </Router>
  );
}

export default App;

File: src/snow/types/snow.types.ts
// src/snow/types/snow.types.ts

export interface SnowAnalysisFeedbackItemFE {
  score: number;
  feedback: string;
}

export interface SnowAnalysisResultFE {
  validation_result: 'pass' | 'fail';
  quality_score: number;
  missing_elements: string[];
  improvement_suggestions: string[];
  feedback: Record<string, SnowAnalysisFeedbackItemFE>; // Keys like "title", "description"
  summary: string;
}

export interface SnowHistoryItemFE {
  id: string;
  ticket_subset: Record<string, string>; // Key fields sent to LLM
  llm_prompt: string;
  llm_response_raw: string;
  analysis: SnowAnalysisResultFE;
  created_at: string; // ISO date string
  // created_by_user_id?: number; // Optional
}

export interface SnowHistoryPageFE {
  items: SnowHistoryItemFE[];
  totalCount: number;
  nextCursor?: string;
}

// Request for analyzing a ticket
export type SnowAnalyzeRequestFE = Record<string, any>;

// Response for analyzing a ticket is the analysis result itself
export type SnowAnalyzeResponseFE = SnowAnalysisResultFE;

// ServiceNow validation status type (distinct from classification status)
export type SnowValidationStatus = 'pass' | 'fail';

// Request parameters for fetching SNOW history
export interface SnowHistoryRequestParamsFE {
  cursor?: string;
  limit?: number;
  startDate?: string; // ISO Date string (YYYY-MM-DD)
  endDate?: string;   // ISO Date string (YYYY-MM-DD)
  search?: string;
}

// Filter state for SNOW history UI
export interface SnowHistoryFiltersState {
  search: string;
  startDate: string | null;
  endDate: string | null;
}

File: src/snow/pages/SnowHistoryPage.tsx
// src/snow/pages/SnowHistoryPage.tsx
import React, { useEffect, useState, useCallback } from 'react';
import { Card, Alert, Pagination, Empty, Button } from 'antd';
import { useAuth } from '../../context/AuthContext';
import { useSnowHistory } from '../hooks/useSnowHistory';
import SnowHistoryTable from '../components/SnowHistoryTable';
import SnowHistoryFilters from '../components/SnowHistoryFilters';
import SnowAnalysisDetailsModal from '../components/SnowAnalysisDetailsModal';
import { SnowHistoryItemFE, SnowHistoryFiltersState, SnowHistoryRequestParamsFE } from '../types/snow.types';

const SnowHistoryPage: React.FC = () => {
  const { apiClient, checkPermission } = useAuth();
  const {
    historyItems,
    loading,
    error,
    totalCount,
    currentPage,
    totalPages,
    fetchHistory,
    deleteHistoryItem,
    pageCursors,
    setCurrentPage,
  } = useSnowHistory(apiClient);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState<SnowHistoryItemFE | null>(null);
  const [filters, setFilters] = useState<SnowHistoryFiltersState>({
    search: '',
    startDate: null,
    endDate: null,
  });

  const handleFetchHistory = useCallback((page: number, currentFilters: SnowHistoryFiltersState) => {
    const params: SnowHistoryRequestParamsFE = {
      search: currentFilters.search || undefined,
      startDate: currentFilters.startDate || undefined,
      endDate: currentFilters.endDate || undefined,
    };
    const cursor = page === 1 ? undefined : pageCursors[page - 1];
    fetchHistory(page, params, cursor);
  }, [fetchHistory, pageCursors]);

  useEffect(() => {
    if (checkPermission('snow:history:view')) {
      handleFetchHistory(currentPage, filters);
    }
  }, [currentPage, filters, checkPermission, handleFetchHistory]);


  const handleFilterChange = (newFilters: SnowHistoryFiltersState) => {
    setFilters(newFilters);
    setCurrentPage(1); // Reset to first page on filter change
  };

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  const handleDelete = async (id: string) => {
    if (!checkPermission('snow:history:delete')) {
      alert("Permission denied to delete history items.");
      return;
    }
    await deleteHistoryItem(id);
    // The hook should handle refreshing the list or adjusting pagination
  };

  const handleViewDetails = (item: SnowHistoryItemFE) => {
    setSelectedItem(item);
    setIsModalOpen(true);
  };

  if (!checkPermission('snow:history:view')) {
    return (
      <div className="page-container">
        <Alert
          message="Permission Denied"
          description="You do not have permission to view ServiceNow analysis history. Please contact your administrator."
          type="error"
          showIcon
        />
      </div>
    );
  }

  return (
    <div className="page-container snow-history-page">
      <Card title="ServiceNow Analysis History" bordered={false}>
        <SnowHistoryFilters onFilter={handleFilterChange} loading={loading} />

        {error && <Alert message="Error" description={error} type="error" showIcon className="my-4" />}

        <SnowHistoryTable
          items={historyItems}
          loading={loading}
          onDelete={handleDelete}
          onViewDetails={handleViewDetails}
          canDelete={checkPermission('snow:history:delete')}
        />

        {historyItems.length === 0 && !loading && !error && (
          <Empty description="No analysis history found matching your criteria." className="my-8" />
        )}

        {totalCount > 0 && (
          <Pagination
            current={currentPage}
            total={totalCount}
            pageSize={10} // Should match PAGE_SIZE in hook
            onChange={handlePageChange}
            showSizeChanger={false}
            className="mt-6 text-center"
            disabled={loading}
          />
        )}
      </Card>

      {selectedItem && (
        <SnowAnalysisDetailsModal
          item={selectedItem}
          isOpen={isModalOpen}
          onClose={() => setIsModalOpen(false)}
        />
      )}
    </div>
  );
};

export default SnowHistoryPage;

File: src/App.css
/* App.css */
/* Main app container */
.app-container {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  
  /* Header styles */
  .app-header {
    background-color: #1e40af; /* primary-900 */
    color: white;
    height: 64px;
    display: flex;
    align-items: center;
    padding: 0 24px;
    position: fixed;
    top: 0;
    width: 100%;
    z-index: 10;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }
  
  .app-title {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0;
  }
  
  /* Main content area */
  .app-content {
    display: flex;
    flex: 1;
    margin-top: 64px; /* Header height */
    position: relative;
    height: calc(100vh - 64px);
  }
  
  /* Sidebar wrapper - fixed width plus transition */
  .sidebar-wrapper {
    position: fixed;
    width: 60px;
    height: calc(100vh - 64px);
    z-index: 5;
  }
  
  /* Main content styles - adjust margin to sidebar width */
  .main-content {
    flex: 1;
    padding: 24px;
    margin-left: 60px; /* Match sidebar width */
    transition: margin-left 0.3s ease-in-out;
    background-color: #f9fafb; /* gray-50 */
    overflow-y: auto;
    width: calc(100% - 60px); /* Ensure content takes remaining space */
  }
  
  /* When sidebar is expanded, adjust margin of content */
  .main-content.sidebar-expanded {
    margin-left: 230px;
    width: calc(100% - 230px);
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .sidebar-wrapper {
      position: fixed;
      z-index: 5;
      height: calc(100vh - 64px);
    }
    
    .main-content {
      margin-left: 0;
      padding: 16px;
    }
  }


File: src/index.css
/* Import sidebar styles - moved to top to fix warning */
@import url('./components/Sidebar/left-sidebar.css');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-synthesis: none;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  html {
    @apply antialiased;
  }

  body {
    @apply min-h-screen bg-secondary-50 text-secondary-900;
    margin: 0;
    padding: 0;
  }

  #root {
    @apply min-h-screen;
  }
}

@layer components {
  /* Button variants */
  .btn {
    @apply inline-flex items-center justify-center px-4 py-2.5 border border-transparent text-sm font-medium rounded-card shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2;
  }

  .btn-primary {
    @apply bg-primary-600 text-white hover:bg-primary-700 focus:ring-primary-500;
  }

  .btn-secondary {
    @apply bg-white text-secondary-700 border-secondary-300 hover:bg-secondary-50 focus:ring-primary-500;
  }

  /* Input styles */
  .input {
    @apply block w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm;
    @apply focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent;
    @apply disabled:bg-secondary-100 disabled:text-secondary-500 disabled:cursor-not-allowed;
  }

  .label {
    @apply block text-sm font-medium text-secondary-700 mb-1;
  }

  /* Card component */
  .card {
    @apply bg-white shadow-card rounded-card p-8 w-full;
    @apply hover:shadow-card-hover transition-shadow;
  }

  /* Page container */
  .page-container {
    @apply max-w-full w-full mx-auto;
  }
}


File: src/pages/BatchPage.tsx
import React, { useState, useEffect } from 'react';
import BatchTab from '../components/BatchTab/BatchTab';
import { ApiClient, ClassificationSystem } from '../api/types';
import { useAuth } from '../context/AuthContext';

interface BatchPageProps {
  apiClient: ApiClient;
}

const BatchPage: React.FC<BatchPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  const [availableSystems, setAvailableSystems] = useState<ClassificationSystem[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [canSubmit, setCanSubmit] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Load available systems
  useEffect(() => {
    const loadSystems = async () => {
      try {
        const systems = await apiClient.getClassificationSystems();
        setAvailableSystems(systems);
      } catch (err) {
        console.error('Failed to load classification systems:', err);
      }
    };
    loadSystems();
  }, [apiClient]);

  const handleSubmit = async () => {
    // Check permission before submitting batch
    if (!checkPermission('classify:batch')) {
      setError('You do not have permission to perform batch classifications');
      return;
    }
  };

  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Batch Classification</h1>
        <p className="text-secondary-600">Process multiple items for classification at once</p>
      </div>

      {/* Add permission check warning if user lacks permission */}
      {!checkPermission('classify:batch') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to perform batch classifications. Please contact your administrator for access.
          </p>
        </div>
      )}
      
      <BatchTab apiClient={apiClient} availableSystems={availableSystems.map(s => ({ system: s }))} />
    </div>
  );
};

export default BatchPage;

File: src/pages/BatchJobsPage.tsx
import React from 'react';
import BatchJobsTab from '../components/BatchJobsTab/BatchJobsTab';
import { ApiClient } from '../api/types';

interface BatchJobsPageProps {
  apiClient: ApiClient;
}

const BatchJobsPage: React.FC<BatchJobsPageProps> = ({ apiClient }) => {
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Batch Jobs</h1>
        <p className="text-secondary-600">
          View and manage batch classification jobs
        </p>
      </div>
      
      <BatchJobsTab apiClient={apiClient} />
    </div>
  );
};

export default BatchJobsPage;

File: src/snow/hooks/useSnowHistory.ts
// src/snow/hooks/useSnowHistory.ts
import { useState, useCallback, useEffect, useRef } from 'react';
import { message } from 'antd';
import { ApiClient } from '../../api/types';
import { SnowHistoryItemFE, SnowHistoryPageFE, SnowHistoryRequestParamsFE } from '../types/snow.types';

export interface UseSnowHistoryResult {
  historyItems: SnowHistoryItemFE[];
  loading: boolean;
  error: string | null;
  totalCount: number;
  currentPage: number;
  totalPages: number;
  fetchHistory: (page: number, filters: SnowHistoryRequestParamsFE, cursor?: string) => Promise<void>;
  deleteHistoryItem: (id: string) => Promise<boolean>;
  pageCursors: Record<number, string | undefined>; // Store cursor for each page number
  setCurrentPage: React.Dispatch<React.SetStateAction<number>>;
}

const PAGE_SIZE = 10;

export function useSnowHistory(apiClient: ApiClient): UseSnowHistoryResult {
  const mountedRef = useRef(true);
  const [historyItems, setHistoryItems] = useState<SnowHistoryItemFE[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [totalCount, setTotalCount] = useState<number>(0);
  const [currentPage, setCurrentPage] = useState<number>(1);
  const [totalPages, setTotalPages] = useState<number>(1);
  const [pageCursors, setPageCursors] = useState<Record<number, string | undefined>>({});

  const safeSetState = <T,>(setter: React.Dispatch<React.SetStateAction<T>>) => (value: T | ((prevState: T) => T)) => {
    if (mountedRef.current) setter(value);
  };

  const safeSetHistoryItems = safeSetState(setHistoryItems);
  const safeSetLoading = safeSetState(setLoading);
  const safeSetError = safeSetState(setError);
  const safeSetTotalCount = safeSetState(setTotalCount);
  const safeSetCurrentPage = safeSetState(setCurrentPage);
  const safeSetTotalPages = safeSetState(setTotalPages);
  const safeSetPageCursors = safeSetState(setPageCursors);

  const fetchHistory = useCallback(async (page: number, filters: SnowHistoryRequestParamsFE, cursor?: string) => {
    safeSetLoading(true);
    safeSetError(null);
    try {
      const params: SnowHistoryRequestParamsFE = {
        limit: PAGE_SIZE,
        cursor: page === 1 ? undefined : cursor, // Use cursor only if not page 1
        ...filters,
      };
      console.log('Fetching SNOW history with params:', params);
      const result: SnowHistoryPageFE = await apiClient.getSnowHistory(params);
      
      safeSetHistoryItems(result.items || []);
      safeSetTotalCount(result.totalCount || 0);
      safeSetTotalPages(Math.ceil((result.totalCount || 0) / PAGE_SIZE) || 1);
      safeSetCurrentPage(page);

      if (result.nextCursor) {
        safeSetPageCursors(prev => ({ ...prev, [page]: result.nextCursor }));
      }

    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Failed to load SNOW analysis history.';
      console.error('SNOW History fetch error:', err);
      safeSetError(errorMsg);
      message.error(errorMsg);
      safeSetHistoryItems([]);
      safeSetTotalCount(0);
      safeSetTotalPages(1);
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, safeSetLoading, safeSetError, safeSetHistoryItems, safeSetTotalCount, safeSetCurrentPage, safeSetTotalPages, safeSetPageCursors]);

  const deleteHistoryItem = useCallback(async (id: string): Promise<boolean> => {
    safeSetLoading(true);
    safeSetError(null);
    try {
      await apiClient.deleteSnowHistory(id);
      message.success('History item deleted successfully.');
      // Refresh current page or go to page 1 if current page becomes empty
      const newTotal = totalCount - 1;
      if (newTotal <= (currentPage - 1) * PAGE_SIZE && currentPage > 1) {
        setCurrentPage(prev => prev - 1); // This will trigger fetch in useEffect
      } else {
        // Re-fetch current page, using the cursor for the current page's *previous* page
        // (as that cursor leads to the current page). For page 1, cursor is undefined.
        await fetchHistory(currentPage, {}, currentPage > 1 ? pageCursors[currentPage - 1] : undefined);
      }
      return true;
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Failed to delete history item.';
      console.error('SNOW History delete error:', err);
      safeSetError(errorMsg);
      message.error(errorMsg);
      return false;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, fetchHistory, totalCount, currentPage, pageCursors, safeSetLoading, safeSetError]);

  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  return {
    historyItems,
    loading,
    error,
    totalCount,
    currentPage,
    totalPages,
    fetchHistory,
    deleteHistoryItem,
    pageCursors,
    setCurrentPage: safeSetCurrentPage,
  };
}

File: src/snow/components/SnowHistoryTable.tsx
// src/snow/components/SnowHistoryTable.tsx
import React from 'react';
import { Table, Button, Tag, Tooltip, Space } from 'antd';
import { EyeOutlined, DeleteOutlined } from '@ant-design/icons';
import { SnowHistoryItemFE } from '../types/snow.types';
import { formatDate } from '../../utils/dateFormat'; // Ensure this utility exists

interface SnowHistoryTableProps {
  items: SnowHistoryItemFE[];
  loading: boolean;
  onDelete: (id: string) => void;
  onViewDetails: (item: SnowHistoryItemFE) => void;
  canDelete: boolean;
}

const SnowHistoryTable: React.FC<SnowHistoryTableProps> = ({
  items,
  loading,
  onDelete,
  onViewDetails,
  canDelete,
}) => {
  const columns = [
    {
      title: 'Analysis ID',
      dataIndex: 'id',
      key: 'id',
      width: 150,
      render: (id: string) => <Tooltip title={id}><span className="font-mono truncate block max-w-[120px]">{id.substring(0, 8)}...</span></Tooltip>,
    },
    {
      title: 'Ticket Summary',
      dataIndex: ['analysis', 'summary'],
      key: 'summary',
      ellipsis: true,
      render: (summary: string) => (
        <Tooltip title={summary} placement="topLeft">
          <span className="line-clamp-2">{summary || 'N/A'}</span>
        </Tooltip>
      ),
    },
    {
      title: 'Quality Score',
      dataIndex: ['analysis', 'quality_score'],
      key: 'quality_score',
      width: 120,
      align: 'center' as const,
      render: (score: number) => {
        let color = 'red';
        if (score >= 8) color = 'green';
        else if (score >= 5) color = 'gold';
        return <Tag color={color}>{score}/10</Tag>;
      },
      sorter: (a: SnowHistoryItemFE, b: SnowHistoryItemFE) => a.analysis.quality_score - b.analysis.quality_score,
    },
    {
      title: 'Created At',
      dataIndex: 'created_at',
      key: 'created_at',
      width: 180,
      render: (dateString: string) => {
        const formatted = formatDate(dateString);
        return <Tooltip title={formatted.fullText}>{formatted.displayText}</Tooltip>;
      },
      sorter: (a: SnowHistoryItemFE, b: SnowHistoryItemFE) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 120,
      align: 'center' as const,
      render: (_: any, record: SnowHistoryItemFE) => (
        <Space>
          <Tooltip title="View Details">
            <Button icon={<EyeOutlined />} onClick={() => onViewDetails(record)} size="small" />
          </Tooltip>
          {canDelete && (
            <Tooltip title="Delete Analysis">
              <Button
                icon={<DeleteOutlined />}
                onClick={() => onDelete(record.id)}
                danger
                size="small"
                disabled={!canDelete}
              />
            </Tooltip>
          )}
        </Space>
      ),
    },
  ];

  return (
    <Table
      dataSource={items}
      columns={columns}
      rowKey="id"
      loading={loading}
      pagination={false} // Pagination handled by parent component
      scroll={{ x: 'max-content' }}
      className="snow-history-table mt-6"
    />
  );
};

export default SnowHistoryTable;

File: src/snow/components/SnowAnalyzeForm.tsx
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Form, Input, Button, Alert, Row, Col, Select, Typography, Popover, Tooltip } from 'antd';
import { InfoCircleOutlined, CloseCircleOutlined } from '@ant-design/icons'; // No longer need SyncOutlined for real-time sync
import { SnowAnalyzeRequestFE } from '../types/snow.types';
import _ from 'lodash'; // Using lodash for deep cloning and debounce

const { TextArea } = Input;
const { Option } = Select;
const { Text } = Typography;

interface SnowAnalyzeFormProps {
  onSubmit: (ticketData: SnowAnalyzeRequestFE) => void;
  loading: boolean;
  disabled?: boolean;
}

// --- Constants for Ticket Types and Fields ---

type TicketType = 'incident' | 'universal_request';

// Define the core set of fields that are typically relevant for the LLM
// Based on internal/services/analyzer_service.go -> extractRelevantFields
const CORE_SNOW_FIELDS: string[] = [
  "number", "sys_id", "state", "priority", "impact", "urgency",
  "short_description", "description",
  "assignment_group", "service_offering", "cmdb_ci", "category", "subcategory",
  "opened_at", "opened_by", "caller_id",
  "contact_type", "close_code", "close_notes"
];

// Example data for different ticket types
// Note: The backend expects a single ticket object, not a "records" array.
// The `extractPrimaryTicket` helper below handles this if the input has a "records" key.
const EXAMPLE_TICKET_DATA: Record<TicketType, Record<string, any>> = {
  universal_request: {
    "number": "UR0114676",
    "short_description": "P3 | OPEN APPLICATION P-25032006 [Problem]:[Container restarts] [Severity]:[ERROR]",
    "description": "OPEN Problem P-25032006 in environment TAMM Staging\nProblem detected at: 17:06 (EDT) 30.03.2025\n\n1 impacted application\n\nKubernetes workload\ntamm-svc-nexus-backend\n\nContainer restarts\nObserved container restarts exceed the specified threshold.\nSource: Kubernetes anomaly detection\ndt.entity.cloud_application_namespace: CLOUD_APPLICATION_NAMESPACE-F1FB6D0B1AC6C3E3\ndt.entity.kubernetes_cluster: KUBERNETES_CLUSTER-3A366C89FFCE7B84\nk8s.cluster.name: tamm-svc\nk8s.cluster.uid: 24536e39-4381-4c58-b893-4317243306a8\nk8s.namespace.name: tamm-svc-internal-stg\n\nRoot cause\n\nBased on our dependency analysis all incidents are part of the same overall problem.\n\nhttps:\/\/dmm-srv-stg.tamm.abudhabi\/e\/39e893a9-c325-499f-b61b-856ba82a4865\/#problems\/problemdetails;pid=-3911365896398794816_1743368760000V2",
    "opened_by": "3ed272c89decd25087cf3827c448e228",
    "opened_at": "2025-03-30 21:21:28",
    "state": "7",
    "priority": "3",
    "impact": "2",
    "urgency": "2",
    "assignment_group": "1e1cfbb29f4cde9c416bf275ae24ab4d",
    "service_offering": "0d4a192b7d19929087cfc5c6d3fd1e39",
    "cmdb_ci": "example_ci_for_ur",
    "contact_type": "web",
    "close_notes": "Incident is Closed",
    "close_code": "Resolved by workaround",
    "category": "Software",
    "subcategory": "Application Issue"
  },
  incident: {
    "number": "INC0440897",
    "short_description": "P3 | OPEN APPLICATION P-2504280 [Problem]:[Out-of-memory kills] [Severity]:[ERROR]",
    "description": "OPEN Problem P-2504280 in environment TAMM Staging\nProblem detected at: 15:48 (EDT) 06.04.2025\n\n1 impacted application\n\nKubernetes workload\ntamm-svc-payment-hub-backend\n\nOut-of-memory kills\nOut-of-memory kills have been observed for pods of this workload.\nSource: Kubernetes anomaly detection\ndt.entity.cloud_application_namespace: CLOUD_APPLICATION_NAMESPACE-F1FB6D0B1AC6C3E3\ndt.entity.kubernetes_cluster: KUBERNETES_CLUSTER-3A366C89FFCE7B84\nk8s.cluster.name: tamm-svc\nk8s.cluster.uid: 24536e39-4381-4c58-b893-4317243306a8\nk8s.namespace.name: tamm-svc-internal-stg\n\nRoot cause\n\nBased on our dependency analysis all incidents are part of the same overall problem.\n\nhttps:\/\/dmm-srv-stg.tamm.abudhabi\/e\/39e893a9-c325-499f-b61b-856ba82a4865\/#problems\/problemdetails;pid=2801568736737721973_1743968880000V2",
    "opened_by": "3ed272c89decd25087cf3827c448e228",
    "opened_at": "2025-04-06 20:03:36",
    "state": "6",
    "priority": "3",
    "impact": "2",
    "urgency": "2",
    "assignment_group": "1e1cfbb29f4cde9c416bf275ae24ab4d",
    "service_offering": "0d4a192b7d19929087cfc5c6d3fd1e39",
    "cmdb_ci": "example_ci_for_incident",
    "contact_type": "alert",
    "close_notes": "Dynatrace detected recovery",
    "close_code": "Resolved â€“ Fixed Without Action",
    "category": "Network",
    "subcategory": "Connectivity"
  }
};

// Helper to extract the primary ticket object from various ServiceNow API response formats.
// The backend `AnalyzeTicket` endpoint expects a single ticket object directly,
// not an object with a "records" array. This helper handles parsing JSON that
// might come in a "records" wrapper.
function extractPrimaryTicket(data: any): Record<string, any> | null {
  if (!data) return null;
  // If 'records' array exists and is not empty, use the first record
  if (Array.isArray(data.records) && data.records.length > 0) {
    return data.records[0];
  }
  // Otherwise, assume the top-level object is the ticket
  if (typeof data === 'object' && data !== null) {
    return data;
  }
  return null;
}

// Function to safely get a value from a potentially complex object given a dot-separated path.
// Necessary because Ant Design's Form.Item `name` prop supports arrays for nesting,
// but our ticket data is a flat object where keys might contain dots (e.g., 'sys_id' vs 'user.name').
// For this form, we'll assume flat top-level keys as defined in CORE_SNOW_FIELDS.
// If you had deeply nested keys like 'user.name', you'd adapt CORE_SNOW_FIELDS and this helper.
function getFieldValue(obj: Record<string, any>, fieldName: string): any {
    return obj[fieldName];
}

// Function to safely set a value in a ticket object.
function setFieldValue(obj: Record<string, any>, fieldName: string, value: any): Record<string, any> {
    const newObj = { ...obj }; // Shallow clone is fine for top-level fields
    newObj[fieldName] = value;
    return newObj;
}


const SnowAnalyzeForm: React.FC<SnowAnalyzeFormProps> = ({ onSubmit, loading, disabled }) => {
  const [form] = Form.useForm();
  const [rawJsonInput, setRawJsonInput] = useState<string>(
    JSON.stringify(EXAMPLE_TICKET_DATA.universal_request, null, 2)
  );
  const [parsedTicketData, setParsedTicketData] = useState<Record<string, any> | null>(
    EXAMPLE_TICKET_DATA.universal_request
  );
  const [jsonError, setJsonError] = useState<string | null>(null);
  const [selectedTicketType, setSelectedTicketType] = useState<TicketType>('universal_request');

  // Debounce the JSON input parsing to avoid frequent re-renders while typing
  const debouncedParseJson = useMemo(
    () =>
      _.debounce((jsonString: string) => {
        try {
          const parsed = JSON.parse(jsonString);
          const primaryTicket = extractPrimaryTicket(parsed);
          setParsedTicketData(primaryTicket); // Update parsed data
          setJsonError(null); // Clear any previous JSON errors
        } catch (e: any) {
          setParsedTicketData(null); // Clear parsed data on error
          setJsonError(e.message || 'Invalid JSON format'); // Set JSON parsing error
        }
      }, 500), // 500ms debounce delay
    [] // Memoize debounce function
  );

  // Effect to sync raw JSON input -> parsed data -> form fields
  useEffect(() => {
    // Call the debounced function whenever rawJsonInput changes
    debouncedParseJson(rawJsonInput);
    // Cleanup debounce on component unmount
    return () => debouncedParseJson.cancel();
  }, [rawJsonInput, debouncedParseJson]);

  // Effect to sync parsed data -> Ant Design form fields
  // This ensures form fields reflect changes from both JSON input and direct field edits.
  useEffect(() => {
    if (parsedTicketData) {
        // Create a flat object to set form values, ensuring all CORE_SNOW_FIELDS are represented
        const formFields: Record<string, any> = {};
        CORE_SNOW_FIELDS.forEach(field => {
            formFields[field] = getFieldValue(parsedTicketData, field);
        });
        form.setFieldsValue(formFields);
    } else {
      form.resetFields(); // Clear form fields if parsed data is null
    }
  }, [parsedTicketData, form]); // Rerun when parsedTicketData changes

  // Handle changes in the raw JSON input textarea
  const handleRawJsonChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setRawJsonInput(e.target.value);
  };

  // Handle changes in individual form fields
  const handleFieldChange = useCallback(
    (fieldName: string, value: any) => {
      // Create a new object based on current parsedTicketData, or an empty one if null
      const currentTicketData = parsedTicketData || {};
      const updatedTicketData = setFieldValue(currentTicketData, fieldName, value);
      
      setParsedTicketData(updatedTicketData); // Update parsed data state
      setRawJsonInput(JSON.stringify(updatedTicketData, null, 2)); // Update raw JSON input
      setJsonError(null); // Clear JSON error if user is actively editing fields
    },
    [parsedTicketData] // Dependency: parsedTicketData to ensure we work with the latest state
  );

  // Handle form submission (from the "Analyze Ticket" button)
  const handleSubmit = () => {
    // Only submit if parsedTicketData is available and there's no JSON parsing error
    if (parsedTicketData && !jsonError) {
      onSubmit(parsedTicketData);
    } else if (jsonError) {
      // JSON error is already displayed by the Alert component
      // No additional action needed here
    } else {
      // This case should ideally not be reachable if the button is disabled correctly
      setJsonError('No ticket data to analyze. Please provide valid JSON.');
    }
  };

  // Handle loading example data when ticket type selection changes
  const loadExample = (type: TicketType) => {
    const example = EXAMPLE_TICKET_DATA[type];
    const exampleJson = JSON.stringify(example, null, 2);
    setRawJsonInput(exampleJson); // Update raw JSON string
    // setParsedTicketData(example) will be called by the useEffect watching rawJsonInput
    // form.setFieldsValue will then be called by the useEffect watching parsedTicketData
    setSelectedTicketType(type); // Update selected type state
    setJsonError(null); // Clear any errors
  };

  // Handle clearing all input fields and JSON
  const handleClear = () => {
    setRawJsonInput('');
    setParsedTicketData(null); // Clear parsed data
    setJsonError(null); // Clear any errors
    form.resetFields(); // Reset Ant Design form fields
  };

  return (
    <Form
      form={form} // Pass the form instance
      layout="vertical"
      onFinish={handleSubmit} // Bind to the Ant Design Form's onFinish
      disabled={disabled || loading} // Disable entire form if loading or prop-disabled
    >
      <Row gutter={[16, 16]}>
        {/* Left Column: Raw JSON Input */}
        <Col span={12}>
          <div className="flex justify-between items-center mb-2">
            <Text strong>Raw JSON Input</Text>
            <Popover
              content={
                <div style={{ maxWidth: 300 }}>
                  <p>Paste the full ServiceNow ticket data in JSON format here.</p>
                  <p>Changes here will update the fields on the right, and vice-versa.</p>
                  <p>The system will automatically extract relevant fields for analysis.</p>
                </div>
              }
              title="JSON Input Guide"
              trigger="hover"
            >
              <InfoCircleOutlined style={{ color: 'rgba(0,0,0,.45)' }} />
            </Popover>
          </div>
          <TextArea
            value={rawJsonInput}
            onChange={handleRawJsonChange}
            rows={20}
            placeholder='Paste your ServiceNow ticket JSON here...'
            disabled={disabled || loading}
            style={{ fontFamily: 'monospace' }}
          />
          {jsonError && (
            <Alert message="JSON Error" description={jsonError} type="error" showIcon className="mt-2" />
          )}
        </Col>

        {/* Right Column: Extracted Ticket Fields */}
        <Col span={12}>
          <div className="flex justify-between items-center mb-2">
            <Text strong>Extracted Ticket Fields</Text>
            <Select
              value={selectedTicketType}
              onChange={loadExample} // Load example data when type changes
              disabled={disabled || loading}
              style={{ width: 180 }}
            >
              <Option value="universal_request">Universal Request</Option>
              <Option value="incident">Incident</Option>
            </Select>
            <Tooltip title="Clear all input">
                 <Button icon={<CloseCircleOutlined />} onClick={handleClear} disabled={disabled || loading} />
            </Tooltip>
          </div>
          <div className="snow-ticket-fields-form" style={{ maxHeight: '450px', overflowY: 'auto', paddingRight: '10px' }}>
            {CORE_SNOW_FIELDS.map((field) => (
              <Form.Item label={_.startCase(field)} name={field} key={field}>
                {/* Use Input.TextArea for multiline fields like description/notes, otherwise Input */}
                {field.includes('description') || field.includes('notes') ? (
                  <Input.TextArea
                    autoSize={{ minRows: 1, maxRows: 4 }}
                    // Use Ant Design's Form.Item value management,
                    // but also call handleFieldChange to sync back to raw JSON
                    onChange={(e) => handleFieldChange(field, e.target.value)}
                    disabled={disabled || loading}
                  />
                ) : (
                  <Input
                    onChange={(e) => handleFieldChange(field, e.target.value)}
                    disabled={disabled || loading}
                  />
                )}
              </Form.Item>
            ))}
            {/* If there's an active ticket, but no core fields populated, indicate */}
            {!parsedTicketData && !jsonError && (
              <Alert message="No data or invalid ticket selected. Load an example or paste JSON." type="info" showIcon />
            )}
          </div>
        </Col>
      </Row>

      {/* Submit Button */}
      <Form.Item className="mt-4">
        <Button
          type="primary"
          htmlType="submit" // Triggers form's onFinish
          loading={loading}
          // Button is disabled if: disabled prop is true, loading, there's a JSON error, or no valid parsed data
          disabled={disabled || loading || jsonError !== null || !parsedTicketData}
          size="large"
        >
          Analyze Ticket
        </Button>
      </Form.Item>
    </Form>
  );
};

export default SnowAnalyzeForm;

File: src/snow/pages/SnowAnalyzePage.tsx
// src/snow/pages/SnowAnalyzePage.tsx
import React, { useState } from 'react';
import { Card, Alert, Spin } from 'antd';
import { useAuth } from '../../context/AuthContext';
import SnowAnalyzeForm from '../components/SnowAnalyzeForm';
import SnowAnalysisResultDisplay from '../components/SnowAnalysisResultDisplay';
import { SnowAnalysisResultFE } from '../types/snow.types';

const SnowAnalyzePage: React.FC = () => {
  const { apiClient, checkPermission } = useAuth();
  const [analysisResult, setAnalysisResult] = useState<SnowAnalysisResultFE | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const handleAnalysis = async (ticketData: Record<string, any>) => {
    if (!checkPermission('snow:analyze')) {
      setError('You do not have permission to analyze ServiceNow tickets.');
      return;
    }
    setIsLoading(true);
    setError(null);
    setAnalysisResult(null);
    try {
      const result = await apiClient.analyzeSnowTicket(ticketData);
      setAnalysisResult(result);
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Failed to analyze ticket.';
      setError(errorMsg);
      console.error("SNOW Analysis error:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="page-container snow-analyze-page">
      <Card title="ServiceNow Ticket Analyzer" bordered={false}>
        <p className="mb-6 text-secondary-600">
          Input ServiceNow ticket data (in JSON format) to get an AI-powered quality analysis.
        </p>

        {!checkPermission('snow:analyze') && (
          <Alert
            message="Permission Denied"
            description="You do not have permission to use the ServiceNow ticket analyzer. Please contact your administrator."
            type="warning"
            showIcon
            className="mb-6"
          />
        )}

        <SnowAnalyzeForm onSubmit={handleAnalysis} loading={isLoading} disabled={!checkPermission('snow:analyze')} />

        {isLoading && (
          <div className="text-center my-8">
            <Spin size="large" tip="Analyzing ticket..." />
          </div>
        )}

        {error && (
          <Alert message="Analysis Error" description={error} type="error" showIcon className="my-6" />
        )}

        {analysisResult && !isLoading && (
          <div className="mt-8">
            <h2 className="text-xl font-semibold text-secondary-900 mb-4">Analysis Result</h2>
            <SnowAnalysisResultDisplay result={analysisResult} />
          </div>
        )}
      </Card>
    </div>
  );
};

export default SnowAnalyzePage;

File: src/pages/LoginPage.tsx
import React from 'react';
import { ApiClient } from '../api/types'; 
import '../components/LoginForm';
import LoginForm from '../components/LoginForm';

interface LoginPageProps {
    apiClient: ApiClient;
    onLoginSuccess: () => void;
}

const LoginPage: React.FC<LoginPageProps> = ({ apiClient, onLoginSuccess }) => {
  return (
    <div className="flex items-center justify-center min-h-screen bg-secondary-100">
      <div className="w-full max-w-md px-8 py-10 bg-white shadow-xl rounded-lg">
        <h1 className="text-3xl font-bold text-center text-secondary-900 mb-8">
          Classifier Login
        </h1>
        <LoginForm apiClient={apiClient} onLoginSuccess={onLoginSuccess} />
      </div>
    </div>
  );
};

export default LoginPage;

File: src/pages/UserManagementPage.tsx
// src/pages/UserManagementPage.tsx
import React from 'react';
import { ApiClient } from '../api/types';
import { useAuth } from '../context/AuthContext';
import { UserManagementComponent } from '../components/UserManagement/UserManagementComponent';

interface UserManagementPageProps {
  apiClient: ApiClient;
}

const UserManagementPage: React.FC<UserManagementPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">User Management</h1>
        <p className="text-secondary-600">
          View and manage user accounts and permissions
        </p>
      </div>
      
      {/* Display permission warning if needed */}
      {!checkPermission('users:manage') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to view or manage users. 
            Please contact your administrator for access.
          </p>
        </div>
      )}
      
      {/* Only show user management component if user has permission */}
      {checkPermission('users:manage') && <UserManagementComponent apiClient={apiClient} />}
    </div>
  );
};

export default UserManagementPage;

File: src/snow/components/SnowAnalysisResultDisplay.tsx
// src/snow/components/SnowAnalysisResultDisplay.tsx
import React from 'react';
import { Card, Descriptions, List, Tag, Typography, Progress, Row, Col } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined, BulbOutlined, WarningOutlined } from '@ant-design/icons';
import { SnowAnalysisResultFE, SnowValidationStatus } from '../types/snow.types';

const { Title, Paragraph, Text } = Typography;

interface SnowAnalysisResultDisplayProps {
  result: SnowAnalysisResultFE;
}

const SnowAnalysisResultDisplay: React.FC<SnowAnalysisResultDisplayProps> = ({ result }) => {
  const getScoreColor = (score: number) => {
    if (score >= 8) return 'success';
    if (score >= 5) return 'warning';
    return 'error';
  };
  // Using the SnowValidationStatus type for type checking
  const validationTag = (result.validation_result as SnowValidationStatus) === 'pass' ? (
    <Tag icon={<CheckCircleOutlined />} color="success">Pass</Tag>
  ) : (
    <Tag icon={<CloseCircleOutlined />} color="error">Fail</Tag>
  );

  return (
    <Card className="snow-analysis-result-display" bordered={false}>
      <Row gutter={[16, 24]}>
        <Col xs={24} md={12} lg={8}>
          <Card title="Overall Assessment" size="small">
            <Descriptions column={1} bordered size="small">
              <Descriptions.Item label="Validation Result">{validationTag}</Descriptions.Item>
              <Descriptions.Item label="Quality Score">
                <Progress
                  percent={result.quality_score * 10}
                  steps={10}
                  strokeColor={getScoreColor(result.quality_score) === 'success' ? '#52c41a' : getScoreColor(result.quality_score) === 'warning' ? '#faad14' : '#f5222d'}
                  format={() => `${result.quality_score}/10`}
                />
              </Descriptions.Item>
            </Descriptions>
          </Card>
        </Col>

        <Col xs={24} md={12} lg={16}>
          <Card title={<><BulbOutlined /> Summary & Suggestions</>} size="small">
            <Paragraph strong>Summary:</Paragraph>
            <Paragraph>{result.summary}</Paragraph>

            {result.missing_elements.length > 0 && (
              <>
                <Paragraph strong className="mt-4">Missing Elements:</Paragraph>
                <List
                  size="small"
                  dataSource={result.missing_elements}
                  renderItem={(item) => <List.Item><WarningOutlined className="mr-2 text-red-500" />{item}</List.Item>}
                  bordered
                  className="bg-red-50"
                />
              </>
            )}

            {result.improvement_suggestions.length > 0 && (
              <>
                <Paragraph strong className="mt-4">Improvement Suggestions:</Paragraph>
                <List
                  size="small"
                  dataSource={result.improvement_suggestions}
                  renderItem={(item) => <List.Item><BulbOutlined className="mr-2 text-blue-500" />{item}</List.Item>}
                  bordered
                  className="bg-blue-50"
                />
              </>
            )}
          </Card>
        </Col>
      </Row>

      <Title level={4} className="mt-8 mb-4">Detailed Feedback</Title>
      <Row gutter={[16, 16]}>
        {Object.entries(result.feedback).map(([criterion, feedbackItem]) => (
          <Col xs={24} sm={12} lg={8} key={criterion}>
            <Card
              title={<Text strong className="capitalize">{criterion.replace(/_/g, ' ')}</Text>}
              size="small"
              extra={<Tag color={getScoreColor(feedbackItem.score)}>{feedbackItem.score}/10</Tag>}
              className="h-full"
            >
              <Paragraph type="secondary" className="text-sm">{feedbackItem.feedback}</Paragraph>
            </Card>
          </Col>
        ))}
      </Row>
    </Card>
  );
};

export default SnowAnalysisResultDisplay;

File: src/snow/components/SnowHistoryFilters.tsx
// src/snow/components/SnowHistoryFilters.tsx
import React, { useState } from 'react';
import { Input, DatePicker, Button, Row, Col, Form, Space } from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { SnowHistoryFiltersState } from '../types/snow.types';
import dayjs from 'dayjs'; // Import dayjs

const { RangePicker } = DatePicker;

interface SnowHistoryFiltersProps {
  onFilter: (filters: SnowHistoryFiltersState) => void;
  loading: boolean;
}

const SnowHistoryFilters: React.FC<SnowHistoryFiltersProps> = ({ onFilter, loading }) => {
  const [form] = Form.useForm();

  const handleFinish = (values: any) => {
    onFilter({
      search: values.search || '',
      startDate: values.dateRange?.[0] ? values.dateRange[0].format('YYYY-MM-DD') : null,
      endDate: values.dateRange?.[1] ? values.dateRange[1].format('YYYY-MM-DD') : null,
    });
  };

  const handleReset = () => {
    form.resetFields();
    onFilter({ search: '', startDate: null, endDate: null });
  };

  return (
    <Form form={form} onFinish={handleFinish} layout="vertical" className="snow-history-filters mb-6">
      <Row gutter={16}>
        <Col xs={24} sm={12} md={10}>
          <Form.Item name="search" label="Search Summary / Description">
            <Input
              placeholder="Enter search term..."
              prefix={<SearchOutlined />}
              allowClear
              disabled={loading}
            />
          </Form.Item>
        </Col>
        <Col xs={24} sm={12} md={10}>
          <Form.Item name="dateRange" label="Date Range">
            <RangePicker
              style={{ width: '100%' }}
              disabled={loading}
              // Default to last 7 days and today
              defaultValue={[dayjs().subtract(7, 'days'), dayjs()]}
            />
          </Form.Item>
        </Col>
        <Col xs={24} md={4} className="flex items-end">
          <Form.Item className="w-full">
            <Space className="w-full" direction="vertical" style={{ width: '100%'}}>
                 <Button type="primary" htmlType="submit" loading={loading} block>
                   Apply Filters
                 </Button>
                 <Button onClick={handleReset} disabled={loading} block>
                   Reset
                 </Button>
            </Space>
          </Form.Item>
        </Col>
      </Row>
    </Form>
  );
};

export default SnowHistoryFilters;

File: src/test-data/create-excel.js
import XLSX from 'xlsx';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Read the CSV file
const csvPath = path.join(__dirname, 'sample_products.csv');
const csvContent = fs.readFileSync(csvPath, 'utf-8');

// Parse CSV content
const workbook = XLSX.utils.book_new();
const worksheet = XLSX.utils.csv_to_sheet(csvContent);

// Add the worksheet to the workbook
XLSX.utils.book_append_sheet(workbook, worksheet, 'Products');

// Write to Excel file
const excelPath = path.join(__dirname, 'sample_products.xlsx');
XLSX.writeFile(workbook, excelPath);

console.log('Excel file created successfully at:', excelPath);

File: src/status-utils/index.ts
// src/status-utils/index.ts
/**
 * Status Types & Utilities
 * 
 * This module exports all status-related components and utility functions
 * for both the Categorization and ServiceNow (SNOW) systems.
 */

// Re-export types
export type { ClassificationStatus, ClassificationSourceType, BatchStatus, BatchJobStatusFilterType } from '../api/types';
export type { SnowValidationStatus } from '../snow/types/snow.types';

// Re-export utility functions
export {
  isInformationalError,
  getClassificationStatusColor,
  getSnowValidationStatusColor,
  getClassificationStatusDescription,
  getSnowValidationStatusDescription,
  INFORMATIONAL_ERROR_MESSAGES
} from '../utils/statusUtils';

// Re-export components
export { default as StatusTypeGuide } from '../components/StatusTypeGuide';
export { default as StatusTypeTooltip } from '../components/StatusTypeTooltip';
export { default as StatusTypesDemo } from '../components/StatusTypesDemo';


File: src/snow/components/SnowAnalysisDetailsModal.tsx
// src/snow/components/SnowAnalysisDetailsModal.tsx
import React from 'react';
import { Modal, Descriptions, Tabs, Typography, Card } from 'antd';
import { SnowHistoryItemFE } from '../types/snow.types';
import SnowAnalysisResultDisplay from './SnowAnalysisResultDisplay'; // Reuse existing component
import { formatDate } from '../../utils/dateFormat';

const { TabPane } = Tabs;
const { Paragraph } = Typography;

interface SnowAnalysisDetailsModalProps {
  item: SnowHistoryItemFE | null;
  isOpen: boolean;
  onClose: () => void;
}

const SnowAnalysisDetailsModal: React.FC<SnowAnalysisDetailsModalProps> = ({ item, isOpen, onClose }) => {
  if (!item) return null;

  return (
    <Modal
      title={`Analysis Details - ${item.id.substring(0,8)}...`}
      open={isOpen}
      onCancel={onClose}
      footer={null} // No OK/Cancel buttons, just close
      width="70vw" // Wider modal
      destroyOnClose
      className="snow-analysis-details-modal"
      styles={{ body: { maxHeight: '75vh', overflowY: 'auto' } }}
    >
      <Tabs defaultActiveKey="1">
        <TabPane tab="Analysis Result" key="1">
          <SnowAnalysisResultDisplay result={item.analysis} />
        </TabPane>
        <TabPane tab="Ticket & LLM Data" key="2">
          <Descriptions bordered column={1} size="small" className="mb-6">
            <Descriptions.Item label="Analysis ID">{item.id}</Descriptions.Item>
            <Descriptions.Item label="Created At">
              {formatDate(item.created_at).fullText}
            </Descriptions.Item>
          </Descriptions>

          <Card title="Ticket Subset Sent to LLM" size="small" className="mb-6">
            <Paragraph
             ellipsis={{ rows: 10, expandable: true, symbol: 'more' }}
             className="text-xs bg-gray-100 p-2 rounded font-mono"
            >
              <pre>{JSON.stringify(item.ticket_subset, null, 2)}</pre>
            </Paragraph>
          </Card>

          <Card title="LLM Prompt" size="small" className="mb-6">
            <Paragraph
              ellipsis={{ rows: 15, expandable: true, symbol: 'more' }}
              className="text-xs bg-gray-100 p-2 rounded font-mono"
            >
               <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>{item.llm_prompt}</pre>
            </Paragraph>
          </Card>

          <Card title="Raw LLM Response" size="small">
             <Paragraph
                ellipsis={{ rows: 15, expandable: true, symbol: 'more' }}
                className="text-xs bg-gray-100 p-2 rounded font-mono"
             >
                <pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>{item.llm_response_raw}</pre>
             </Paragraph>
          </Card>
        </TabPane>
      </Tabs>
    </Modal>
  );
};

export default SnowAnalysisDetailsModal;

File: src/pages/HistoryPage.tsx
import React from 'react';
import { HistoryTab } from '../components/HistoryTab';
import { ApiClient } from '../api/types';

interface HistoryPageProps {
  apiClient: ApiClient;
}

const HistoryPage: React.FC<HistoryPageProps> = ({ apiClient }) => {
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Classification History</h1>
        <p className="text-secondary-600">
          View and manage previous classification results
        </p>
      </div>
      
      <HistoryTab apiClient={apiClient} />
    </div>
  );
};

export default HistoryPage;

File: src/pages/RoleManagementPage.tsx
import React from 'react';
import { ApiClient } from '../api/types';
import { useAuth } from '../context/AuthContext';
import { RoleManagementComponent } from '../components/RoleManagement/RoleManagementComponent';

interface RoleManagementPageProps {
  apiClient: ApiClient;
}

const RoleManagementPage: React.FC<RoleManagementPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  
  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Role Management</h1>
        <p className="text-secondary-600">
          View and manage roles and their permissions
        </p>
      </div>
      
      {/* Display permission warning if needed */}
      {!checkPermission('roles:manage') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to view or manage roles. 
            Please contact your administrator for access.
          </p>
        </div>
      )}
      
      {/* Only show role management component if user has permission */}
      {checkPermission('roles:manage') && <RoleManagementComponent apiClient={apiClient} />}
    </div>
  );
};

export default RoleManagementPage;

File: src/langgraph/types/langgraph.ts
// src/langgraph/types/langgraph.ts

/**
 * Represents the UI position of a node for visualization.
 * Mirrors backend: NodeUIPosition
 */
export interface UINodePosition {
  x: number;
  y: number;
}

/**
 * Defines a single node in the graph structure for frontend use.
 * Mirrors backend: NodeDefinition
 */
export interface FrontendNodeDef {
  id: string;
  type: string; // Maps to backend logic (e.g., 'llm_node', 'tool_node')
  config: Record<string, any>; // Configuration specific to this node type
  uiPosition?: UINodePosition; // Optional UI positioning
  // Frontend-specific display properties can be added here if needed
  // e.g., customData?: { label?: string; icon?: string; status?: 'running' | 'completed' | 'error' };
}

/**
 * Defines a directed edge between two nodes for frontend use.
 * Mirrors backend: EdgeDefinition
 */
export interface FrontendEdgeDef {
  id: string;
  source: string; // ID of the source node
  target: string; // ID of the target node
  label?: string; // Optional label for the edge
  animated?: boolean;
  // type?: string; // For custom React Flow edge rendering
}

/**
 * Defines the target node for a specific condition name.
 * Mirrors backend: ConditionalEdgeMapping
 */
export interface FrontendConditionalEdgeMapping {
  conditionName: string; // The name of the condition
  targetNodeId: string;  // The ID of the node to transition to
}

/**
 * Defines conditional outgoing edges for a specific source node.
 * Mirrors backend: ConditionalEdgesDefinition
 */
export interface FrontendConditionalEdgesDef {
  sourceNodeId: string;
  // routerFunctionName?: string; // Name of the router function in backend's ROUTER_IMPLEMENTATIONS
  mappings: FrontendConditionalEdgeMapping[];
}

/**
 * Full definition of a LangGraph workflow for frontend use.
 * Mirrors backend: GraphDefinition
 */
export interface FrontendGraphDef {
  id: string;
  name: string;
  description?: string;
  stateSchemaName: string; // Name of the Pydantic model for LangGraph state
  nodes: FrontendNodeDef[];
  edges: FrontendEdgeDef[];
  conditionalEdges: FrontendConditionalEdgesDef[];
  entryPointNodeId: string;
  terminalNodeIds?: string[];
  version?: number;
  createdAt?: string; // ISO date string
  updatedAt?: string; // ISO date string
}

/**
 * Minimal identifier for a graph definition, used in listings.
 * Mirrors backend: GraphDefinitionIdentifier
 */
export interface GraphDefinitionIdentifierFE {
  id: string;
  name: string;
  updatedAt?: string; // ISO date string
}

/**
 * Response for listing graph definitions.
 * Mirrors backend: GraphDefinitionListResponse
 */
export interface GraphDefinitionListResponseFE {
  graphs: GraphDefinitionIdentifierFE[];
}

/**
 * Request payload for creating a new graph definition.
 * Mirrors backend: CreateGraphRequest
 */
export interface CreateGraphRequestFE extends Omit<FrontendGraphDef, 'id' | 'createdAt' | 'updatedAt' | 'version'> {
  // id, createdAt, updatedAt, version are typically server-generated
}

/**
 * Request payload for updating an existing graph definition.
 * Mirrors backend: UpdateGraphRequest
 */
export interface UpdateGraphRequestFE extends CreateGraphRequestFE {
  // Inherits all fields from CreateGraphRequestFE.
  // The ID of the graph to update is usually passed as a path parameter.
}


// --- WebSocket Event Types (mirroring backend schemas) ---

export type WebSocketEventType =
  | 'graph_execution_start'
  | 'node_start'
  | 'node_end'
  | 'edge_taken' // You might need to infer this or have backend send it explicitly
  | 'graph_execution_end'
  | 'graph_error'
  | 'pong'; // For keep-alive if implemented

export interface WebSocketBaseEventFE {
  eventType: WebSocketEventType;
  timestamp: string; // ISO date string
  executionId: string;
  graphId: string;
}

export interface GraphExecutionStartEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_start';
  inputArgs: Record<string, any>;
}

export interface NodeLifecycleEventFE extends WebSocketBaseEventFE {
  nodeId: string;
  nodeType?: string;
}

export interface NodeStartEventFE extends NodeLifecycleEventFE {
  eventType: 'node_start';
  inputData: Record<string, any>;
}

export interface NodeEndEventFE extends NodeLifecycleEventFE {
  eventType: 'node_end';
  outputData: Record<string, any>;
  status: 'success' | 'failure';
  errorMessage?: string;
  durationMs?: number;
}

export interface EdgeTakenEventFE extends WebSocketBaseEventFE {
  eventType: 'edge_taken';
  sourceNodeId: string;
  targetNodeId: string;
  edgeLabel?: string;
  isConditional: boolean;
}

export interface GraphExecutionEndEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_end';
  finalState: Record<string, any>;
  status: 'completed' | 'failed' | 'interrupted';
  totalDurationMs?: number;
}

export interface GraphErrorEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_error';
  message: string;
  details?: string;
  nodeId?: string;
}

export interface PongEventFE extends Omit<WebSocketBaseEventFE, 'executionId' | 'graphId'> {
    eventType: 'pong';
    serverTime: string;
}

// Union type for all possible incoming WebSocket messages
export type LangGraphExecutionEvent =
  | GraphExecutionStartEventFE
  | NodeStartEventFE
  | NodeEndEventFE
  | EdgeTakenEventFE
  | GraphExecutionEndEventFE
  | GraphErrorEventFE
  | PongEventFE;

// --- HTTP API Request/Response Types for LangGraph Management ---

/**
 * Request to initiate execution of a graph via HTTP (if implemented).
 * This is also the structure of the initial message sent over WebSocket.
 */
export interface ExecuteGraphRequestFE {
  inputArgs?: Record<string, any>;
  configOverrides?: Record<string, any>; // Keep if you plan to use it
  simulation_delay_ms?: number; // Milliseconds to delay each node step
}

/**
 * Response after initiating a graph execution via HTTP.
 * Mirrors backend: ExecuteGraphResponse
 */
export interface ExecuteGraphResponseFE {
  executionId: string;
  message: string;
  websocketUrl?: string;
}

/**
 * Generic message response.
 * Mirrors backend: MessageResponse
 */
export interface MessageResponseFE {
    message: string;
}

// --- React Flow Specific Types (can be extended as needed) ---
// These types are what React Flow expects for its `nodes` and `edges` props.
// We will adapt FrontendNodeDef and FrontendEdgeDef to these.

export interface ReactFlowNodeData {
  label: string;
  // Custom data for rendering or logic
  type?: string; // Original node type from definition
  status?: 'idle' | 'running' | 'success' | 'error' | 'active'; // For visual styling
  config?: Record<string, any>; // Original config for inspection
  inputs?: Record<string, any>; // Last known inputs to this node
  outputs?: Record<string, any>; // Last known outputs from this node
}

export interface ReactFlowEdgeData {
  label?: string;
  // Custom data for rendering or logic
  status?: 'idle' | 'traversed'; // For visual styling
}

// Example of how you might type the nodes and edges for React Flow itself
// import { Node, Edge } from 'reactflow';
// export type LangGraphReactFlowNode = Node<ReactFlowNodeData>;
// export type LangGraphReactFlowEdge = Edge<ReactFlowEdgeData>;

File: src/pages/RagInfoPage.tsx
// src/pages/RagInfoPage.tsx
import React from 'react';
import { ApiClient } from '../api/types';
import { RagInfoTab } from '../components/RagInfoTab'; // Correct import for the main tab component
import { useAuth } from '../context/AuthContext';

interface RagInfoPageProps {
  apiClient: ApiClient;
}

const RagInfoPage: React.FC<RagInfoPageProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();

  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Information Management</h1>
        <p className="text-secondary-600">
          Manage information for RAG classification assistance
        </p>
      </div>

      {/* Display permission warning if needed */}
      {!checkPermission('rag:view') && (
        <div className="mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded-lg">
          <p className="text-yellow-800">
            You don't have permission to view or manage RAG information.
            Please contact your administrator for access.
          </p>
        </div>
      )}

      {/* Only show RAG info component if user has permission */}
      {/* Render RagInfoTab (which contains the table, filters, buttons etc.) */}
      {checkPermission('rag:view') && <RagInfoTab apiClient={apiClient} />}

    </div>
  );
};

export default RagInfoPage;

File: src/langgraph/services/langGraphApiService.ts
// src/langgraph/services/langGraphApiService.ts
// Content from the original langGraphApiService.fixed.ts

/**
 * Represents the UI position of a node for visualization.
 * Mirrors backend: NodeUIPosition
 */
export interface UINodePosition {
  x: number;
  y: number;
}

/**
 * Defines a single node in the graph structure for frontend use.
 * Mirrors backend: NodeDefinition
 */
export interface FrontendNodeDef {
  id: string;
  type: string; // Maps to backend logic (e.g., 'llm_node', 'tool_node')
  config: Record<string, any>; // Configuration specific to this node type
  uiPosition?: UINodePosition; // Optional UI positioning
}

/**
 * Defines a directed edge between two nodes for frontend use.
 * Mirrors backend: EdgeDefinition
 */
export interface FrontendEdgeDef {
  id: string;
  source: string; // ID of the source node
  target: string; // ID of the target node
  label?: string; // Optional label for the edge
  animated?: boolean;
}

/**
 * Defines the target node for a specific condition name.
 * Mirrors backend: ConditionalEdgeMapping
 */
export interface FrontendConditionalEdgeMapping {
  conditionName: string; // The name of the condition
  targetNodeId: string;  // The ID of the node to transition to
}

/**
 * Defines conditional outgoing edges for a specific source node.
 * Mirrors backend: ConditionalEdgesDefinition
 */
export interface FrontendConditionalEdgesDef {
  sourceNodeId: string;
  mappings: FrontendConditionalEdgeMapping[];
}

/**
 * Full definition of a LangGraph workflow for frontend use.
 * Mirrors backend: GraphDefinition
 */
export interface FrontendGraphDef {
  id: string;
  name: string;
  description?: string;
  stateSchemaName: string; 
  nodes: FrontendNodeDef[];
  edges: FrontendEdgeDef[];
  conditionalEdges: FrontendConditionalEdgesDef[];
  entryPointNodeId: string;
  terminalNodeIds?: string[];
  version?: number;
  createdAt?: string; 
  updatedAt?: string; 
}

/**
 * Minimal identifier for a graph definition, used in listings.
 * Mirrors backend: GraphDefinitionIdentifier
 */
export interface GraphDefinitionIdentifierFE {
  id: string;
  name: string;
  updatedAt?: string; 
}

/**
 * Response for listing graph definitions.
 * Mirrors backend: GraphDefinitionListResponse
 */
export interface GraphDefinitionListResponseFE {
  graphs: GraphDefinitionIdentifierFE[];
}

/**
 * Request payload for creating a new graph definition.
 * Mirrors backend: CreateGraphRequest
 */
export interface CreateGraphRequestFE extends Omit<FrontendGraphDef, 'id' | 'createdAt' | 'updatedAt' | 'version'> {}

/**
 * Request payload for updating an existing graph definition.
 * Mirrors backend: UpdateGraphRequest
 */
export interface UpdateGraphRequestFE extends CreateGraphRequestFE {}

// --- WebSocket Event Types (mirroring backend schemas) ---
export type WebSocketEventType =
  | 'graph_execution_start'
  | 'node_start'
  | 'node_end'
  | 'edge_taken'
  | 'graph_execution_end'
  | 'graph_error'
  | 'pong';

export interface WebSocketBaseEventFE {
  eventType: WebSocketEventType;
  timestamp: string; 
  executionId: string;
  graphId: string;
}

export interface GraphExecutionStartEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_start';
  inputArgs: Record<string, any>;
}

export interface NodeLifecycleEventFE extends WebSocketBaseEventFE {
  nodeId: string;
  nodeType?: string;
}

export interface NodeStartEventFE extends NodeLifecycleEventFE {
  eventType: 'node_start';
  inputData: Record<string, any>;
}

export interface NodeEndEventFE extends NodeLifecycleEventFE {
  eventType: 'node_end';
  outputData: Record<string, any>;
  status: 'success' | 'failure';
  errorMessage?: string;
  durationMs?: number;
}

export interface EdgeTakenEventFE extends WebSocketBaseEventFE {
  eventType: 'edge_taken';
  sourceNodeId: string;
  targetNodeId: string;
  edgeLabel?: string;
  isConditional: boolean;
}

export interface GraphExecutionEndEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_execution_end';
  finalState: Record<string, any>;
  status: 'completed' | 'failed' | 'interrupted';
  totalDurationMs?: number;
}

export interface GraphErrorEventFE extends WebSocketBaseEventFE {
  eventType: 'graph_error';
  message: string;
  details?: string;
  nodeId?: string;
}

export interface PongEventFE extends Omit<WebSocketBaseEventFE, 'executionId' | 'graphId'> {
    eventType: 'pong';
    serverTime: string;
}

export type LangGraphExecutionEvent =
  | GraphExecutionStartEventFE
  | NodeStartEventFE
  | NodeEndEventFE
  | EdgeTakenEventFE
  | GraphExecutionEndEventFE
  | GraphErrorEventFE
  | PongEventFE;

// --- HTTP API Request/Response Types for LangGraph Management ---
export interface ExecuteGraphRequestFE {
  inputArgs?: Record<string, any>;
}

export interface ExecuteGraphResponseFE {
  executionId: string;
  message: string;
}

export interface MessageResponseFE {
  message: string;
  details?: any;
}

import { ApiClient } from '../../api/types'; // ApiClient is used for type hint, but not for its methods in direct*

// --- LangGraphApiService Class ---
export class LangGraphApiService {
  private apiClient: ApiClient; // Retained for type consistency or potential future use
  private prefix: string;

  constructor(apiClient: ApiClient, prefix: string = '/v1/lg-vis') {
    this.apiClient = apiClient;
    this.prefix = prefix;
    console.log(`[LangGraphApiService] Initialized with prefix: ${this.prefix}`);
  }
  private async directGet<T = any>(path: string, params?: Record<string, any>): Promise<T> {
    // Ensure path starts with /api to match the Vite proxy configuration
    const fullPath = path.startsWith('/api') ? path : `/api${path.startsWith('/') ? path : `/${path}`}`;
    
    let urlString = fullPath;
    if (params && Object.keys(params).length > 0) {
      const queryParams = new URLSearchParams();
      Object.keys(params).forEach(key => {
        if (params[key] !== undefined && params[key] !== null) {
          queryParams.append(key, String(params[key]));
        }
      });
      const queryString = queryParams.toString();
      if (queryString) {
        urlString = `${fullPath}?${queryString}`;
      }
    }
    
    console.log(`[LangGraphApiService] Making direct GET request to: ${urlString}`);
    const response = await fetch(urlString, { method: 'GET' }); // Direct fetch
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async listGraphDefinitions(includeStatic: boolean = false): Promise<GraphDefinitionListResponseFE> {
    console.log(`[LangGraphApiService] Listing graph definitions. Prefix: ${this.prefix}. Path for directGet: ${this.prefix}/graphs`);
    return this.directGet<GraphDefinitionListResponseFE>(`${this.prefix}/graphs`, { include_static: includeStatic });
  }

  async getGraphDefinition(graphId: string): Promise<FrontendGraphDef> {
    return this.directGet<FrontendGraphDef>(`${this.prefix}/graphs/${graphId}`);
  }
  private async directPost<T = any>(path: string, body: any): Promise<T> {
    // Ensure path starts with /api to match the Vite proxy configuration
    const fullPath = path.startsWith('/api') ? path : `/api${path.startsWith('/') ? path : `/${path}`}`;
    console.log(`[LangGraphApiService] Making direct POST request to: ${fullPath}`);
    const response = await fetch(fullPath, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async createGraphDefinition(data: CreateGraphRequestFE): Promise<FrontendGraphDef> {
    const transformedData = {
      name: data.name,
      description: data.description,
      state_schema_name: data.stateSchemaName,
      entry_point_node_id: data.entryPointNodeId,
      nodes: data.nodes.map(node => ({
        id: node.id, type: node.type, config: node.config,
        ui_position: node.uiPosition ? { x: node.uiPosition.x, y: node.uiPosition.y } : undefined
      })),
      edges: data.edges.map(edge => ({
        id: edge.id, source: edge.source, target: edge.target, label: edge.label, animated: edge.animated
      })),
      conditional_edges: data.conditionalEdges.map(condEdge => ({
        source_node_id: condEdge.sourceNodeId,
        mappings: condEdge.mappings.map(mapping => ({
          condition_name: mapping.conditionName, target_node_id: mapping.targetNodeId
        }))
      })),
      terminal_node_ids: data.terminalNodeIds
    };
    return this.directPost<FrontendGraphDef>(`${this.prefix}/graphs`, transformedData);
  }

  private async directPut<T = any>(path: string, body: any): Promise<T> {
    const fullPath = path.startsWith('/') ? path : `/${path}`;
    console.log(`[LangGraphApiService] Making direct PUT request to: ${fullPath}`);
    const response = await fetch(fullPath, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${fullPath}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async updateGraphDefinition(graphId: string, data: UpdateGraphRequestFE): Promise<FrontendGraphDef> {
    const transformedData = {
      name: data.name,
      description: data.description,
      state_schema_name: data.stateSchemaName,
      entry_point_node_id: data.entryPointNodeId,
      nodes: data.nodes.map(node => ({
        id: node.id, type: node.type, config: node.config,
        ui_position: node.uiPosition ? { x: node.uiPosition.x, y: node.uiPosition.y } : undefined
      })),
      edges: data.edges.map(edge => ({
        id: edge.id, source: edge.source, target: edge.target, label: edge.label, animated: edge.animated
      })),
      conditional_edges: data.conditionalEdges.map(condEdge => ({
        source_node_id: condEdge.sourceNodeId,
        mappings: condEdge.mappings.map(mapping => ({
          condition_name: mapping.conditionName, target_node_id: mapping.targetNodeId
        }))
      })),
      terminal_node_ids: data.terminalNodeIds
    };
    return this.directPut<FrontendGraphDef>(`${this.prefix}/graphs/${graphId}`, transformedData);
  }

  private async directDelete<T = any>(path: string): Promise<T> {
    const fullPath = path.startsWith('/') ? path : `/${path}`;
    console.log(`[LangGraphApiService] Making direct DELETE request to: ${fullPath}`);
    const response = await fetch(fullPath, {
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' }
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${fullPath}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async deleteGraphDefinition(graphId: string): Promise<MessageResponseFE> {
    return this.directDelete<MessageResponseFE>(`${this.prefix}/graphs/${graphId}`);
  }

  async executeGraph(graphId: string, request: ExecuteGraphRequestFE): Promise<ExecuteGraphResponseFE> {
    return this.directPost<ExecuteGraphResponseFE>(`${this.prefix}/graphs/${graphId}/execute`, request);
  }
}

File: src/pages/ChatPage.tsx
// src/pages/ChatPage.tsx
import React from 'react';
import { useChat, Message as VercelMessage } from '@ai-sdk/react';
import { Input, Button, List, Avatar, Alert, Form } from 'antd';
import { UserOutlined, RobotOutlined, SendOutlined } from '@ant-design/icons';
import { API_ENDPOINTS, formatEndpoint } from '../config/api'; // To construct the API path
import { useAuth } from '../context/AuthContext'; // To get user info for display

import './ChatPage.css'; // We'll create this file for custom styles

const ChatPage: React.FC = () => {
  const { user } = useAuth(); // Get current user for avatar or display name
  const { messages, input, handleInputChange, handleSubmit, isLoading, error } = useChat({
    api: formatEndpoint(API_ENDPOINTS.chat.completions), // Your Go backend endpoint
    onError: (err) => {
      // Handle API errors (e.g., display a toast message)
      console.error("Chat API error:", err);
    },
  });

  const onFormSubmit = () => {
    handleSubmit({ preventDefault: () => {} } as React.FormEvent<HTMLFormElement>);
  };

  // Scroll to bottom of message list when new messages are added
  const messagesEndRef = React.useRef<HTMLDivElement | null>(null);
  React.useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="page-container chat-page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">AI Chat</h1>
        <p className="text-secondary-600">
          Chat with the AI assistant for to discusss your classification tasks.
        </p>
      </div>

      {error && (
        <Alert
          message="Chat Error"
          description={error.message || 'An unexpected error occurred.'}
          type="error"
          showIcon
          closable
          className="mb-4"
        />
      )}

      <div className="chat-messages-list">
        <List
          itemLayout="horizontal"
          dataSource={messages}
          renderItem={(message: VercelMessage, index: number) => (
            <List.Item
              key={message.id || `msg-${index}`}
              className={message.role === 'user' ? 'chat-message user' : 'chat-message assistant'}
            >
              <List.Item.Meta
                avatar={
                  message.role === 'user' ? (
                    <Avatar icon={<UserOutlined />} />
                  ) : (
                    <Avatar icon={<RobotOutlined />} style={{ backgroundColor: '#1890ff' }} />
                  )
                }
                title={
                  message.role === 'user'
                    ? (user?.username || 'You')
                    : 'AI Assistant'
                }
                description={
                  <div className="message-content">
                    {message.content.split('\n').map((line, i) => (
                      <React.Fragment key={i}>
                        {line}
                        {i < message.content.split('\n').length - 1 && <br />}
                      </React.Fragment>
                    ))}
                  </div>
                }
              />
            </List.Item>
          )}
        />
        {isLoading && messages.length > 0 && messages[messages.length -1].role === 'user' && (
          <div className="chat-message assistant loading-dots-container">
             <Avatar icon={<RobotOutlined />} style={{ backgroundColor: '#1890ff' }} />
             <div className="loading-dots">
                <span></span><span></span><span></span>
             </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <Form onFinish={onFormSubmit} className="chat-input-form">
        <Input.Group compact style={{ display: 'flex' }}>
          <Input.TextArea
            value={input}
            onChange={handleInputChange}
            placeholder="Type your message..."
            disabled={isLoading}
            onPressEnter={(e) => {
              if (!e.shiftKey && !isLoading && input.trim()) {
                e.preventDefault();
                onFormSubmit();
              }
            }}
            autoSize={{ minRows: 1, maxRows: 5 }}
            style={{ flexGrow: 1, marginRight: 8 }}
          />
          <Button
            type="primary"
            htmlType="submit"
            icon={<SendOutlined />}
            loading={isLoading}
            disabled={!input.trim()}
          >
            Send
          </Button>
        </Input.Group>
      </Form>
    </div>
  );
};

export default ChatPage;

File: src/langgraph/services/langGraphSSEService.ts
// src/langgraph/services/langGraphSSEService.ts
import { LangGraphExecutionEvent, ExecuteGraphRequestFE } from '../types/langgraph';

export type LangGraphSSEMessageHandler = (event: LangGraphExecutionEvent) => void;
export type LangGraphSSEErrorHandler = (error: Error) => void;
export type LangGraphSSEOpenHandler = () => void;
export type LangGraphSSECloseHandler = () => void;

interface LangGraphSSEServiceOptions {
  onOpen?: LangGraphSSEOpenHandler;
  onMessage: LangGraphSSEMessageHandler;
  onError?: LangGraphSSEErrorHandler;
  onClose?: LangGraphSSECloseHandler;
  baseUrl?: string;
}

export class LangGraphSSEService {
  private eventSource: EventSource | null = null;
  private readonly onOpenCallback?: LangGraphSSEOpenHandler;
  private readonly onMessageCallback: LangGraphSSEMessageHandler;
  private readonly onErrorCallback?: LangGraphSSEErrorHandler;
  private readonly onCloseCallback?: LangGraphSSECloseHandler;
  private baseUrl: string;
  private abortController: AbortController | null = null;

  constructor(options: LangGraphSSEServiceOptions) {
    this.onOpenCallback = options.onOpen;
    this.onMessageCallback = options.onMessage;
    this.onErrorCallback = options.onError;
    this.onCloseCallback = options.onClose;
    this.baseUrl = options.baseUrl || '/api/v1/lg-vis';
  }

  public async connect(graphId: string, executionRequest: ExecuteGraphRequestFE): Promise<string> {
    this.close(); // Close any existing connection

    try {
      // First, make a POST request to initiate execution
      const response = await fetch(`${this.baseUrl}/graphs/${graphId}/execute/stream`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          inputArgs: executionRequest.inputArgs,
          simulation_delay_ms: executionRequest.simulation_delay_ms,
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to start execution: ${response.status}`);
      }

      // Get execution ID from response header
      const executionId = response.headers.get('X-Execution-ID') || 'unknown';

      // Create EventSource from the response
      const reader = response.body?.getReader();
      const decoder = new TextDecoder();

      if (!reader) {
        throw new Error('No response body available');
      }

      // Process the SSE stream
      this.processSSEStream(reader, decoder, executionId);

      return executionId;
    } catch (error) {
      console.error('[LangGraphSSEService] Connection error:', error);
      this.onErrorCallback?.(error as Error);
      throw error;
    }
  }

  private async processSSEStream(
    reader: ReadableStreamDefaultReader<Uint8Array>,
    decoder: TextDecoder,
    executionId: string
  ): Promise<void> {
    let buffer = '';

    try {
      this.onOpenCallback?.();

      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          console.log('[LangGraphSSEService] Stream completed');
          this.onCloseCallback?.();
          break;
        }

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        
        // Keep the last incomplete line in the buffer
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              console.log('[LangGraphSSEService] Received event:', data);
              this.onMessageCallback(data as LangGraphExecutionEvent);
            } catch (e) {
              console.error('[LangGraphSSEService] Error parsing SSE data:', e, line);
            }
          } else if (line.startsWith('event: ')) {
            // Event type is in the event field, we can use it for routing if needed
            console.log('[LangGraphSSEService] Event type:', line.slice(7));
          }
        }
      }
    } catch (error) {
      console.error('[LangGraphSSEService] Stream processing error:', error);
      this.onErrorCallback?.(error as Error);
    } finally {
      reader.releaseLock();
    }
  }

  public close(): void {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
  }
}

File: src/pages/SettingsPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { ApiClient, LlmConfig, UpdateConfigRequest } from '../api/types';
import SettingsTab from '../components/Settings/SettingsTab';
import { useAuth } from '../context/AuthContext';
import { Button, Spin, Alert, message, Form } from 'antd';
import { EditOutlined, SaveOutlined, CloseOutlined } from '@ant-design/icons';

interface SettingsPageProps {
  apiClient: ApiClient;
}

const SettingsPage: React.FC<SettingsPageProps> = ({ apiClient }) => {
  const { checkPermission } = useAuth();
  const [form] = Form.useForm(); // Create form instance here

  const [config, setConfig] = useState<LlmConfig | null>(null);
  const [loading, setLoading] = useState(true); // Loading state for initial fetch
  const [saving, setSaving] = useState(false); // Separate state for saving operation
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);

  const canView = checkPermission('config:view');
  const canUpdate = checkPermission('config:update');

  const loadConfig = useCallback(async () => {
    if (!canView) {
        setLoading(false);
        return; // Don't load if user can't view
    }
    setLoading(true);
    setError(null);
    try {
      const fetchedConfig = await apiClient.getConfig();
      setConfig(fetchedConfig);
      form.resetFields(); // Reset form when new config is loaded
    } catch (err) {
      console.error('Failed to load settings:', err);
      setError(err instanceof Error ? err.message : 'Failed to load configuration');
      setConfig(null);
    } finally {
      setLoading(false);
    }
  }, [apiClient, canView, form]); // Add form dependency

  useEffect(() => {
    loadConfig();
  }, [loadConfig]); // Reload if loadConfig changes

  const handleEdit = () => {
    if (canUpdate) {
      setIsEditing(true);
      // Form initialization happens in SettingsTab's useEffect
    }
  };

  const handleCancel = () => {
    setIsEditing(false);
    form.resetFields(); // Reset form to initial values on cancel
    message.info('Changes discarded.');
  };

  // This function will be called by SettingsTab's Form onFinish
  const handleSave = async () => {
    if (!canUpdate) return;
    setSaving(true);
    setError(null);
    try {
      const formValues = await form.validateFields();

      // Construct the UpdateConfigRequest payload
      // Only include sections that have changed or contain updatable fields
      const updatePayload: UpdateConfigRequest = {};

      // Helper function to prune unchanged/sensitive fields before sending
      const buildUpdateSection = (sectionKey: keyof LlmConfig, formSectionValues: any) => {
        if (!formSectionValues || typeof formSectionValues !== 'object') return null;
        const originalSection = config?.[sectionKey] as any;
        const updateSection: any = {};
        let hasChanges = false;

        Object.keys(formSectionValues).forEach(key => {
          const fullKey = `${sectionKey}.${key}`;
          const newValue = formSectionValues[key];
          const originalValue = originalSection?.[key];

          // Special handling for sensitive fields: only include if non-empty
          if (['llmApiKey', 'smtpPassword'].includes(key)) {
            if (newValue && typeof newValue === 'string' && newValue.trim() !== '') {
              updateSection[key] = newValue.trim();
              hasChanges = true;
              console.log(`[SAVE] Including updated sensitive field: ${fullKey}`);
            } else {
              console.log(`[SAVE] Skipping empty/unchanged sensitive field: ${fullKey}`);
            }
          } else if (newValue !== originalValue) {
            // Basic change detection (might need deep compare for objects/arrays)
            updateSection[key] = newValue;
            hasChanges = true;
            console.log(`[SAVE] Field changed: ${fullKey}`, { from: originalValue, to: newValue });
          } else {
            console.log(`[SAVE] Field unchanged: ${fullKey}`);
          }
        });
        return hasChanges ? updateSection : null;
      };

      // Iterate through top-level keys present in the form
      const topLevelKeys = ['server', 'service', 'database', 'auth', 'validation', 'alert'] as const; // Add all keys
      topLevelKeys.forEach(key => {
        if (formValues[key]) {
          const updateSectionData = buildUpdateSection(key, formValues[key]);
          if (updateSectionData) {
            updatePayload[key] = updateSectionData;
          }
        }
      });

      if (Object.keys(updatePayload).length === 0) {
        message.info('No changes detected to save.');
        setIsEditing(false); // Exit edit mode if no changes
        setSaving(false);
        return;
      }

      console.log("Submitting update payload:", updatePayload); // Log the final payload

      await apiClient.updateConfig(updatePayload);
      message.success('Configuration updated successfully!');
      setIsEditing(false);
      await loadConfig(); // Reload config to show persisted values

    } catch (err) {
      console.error('Failed to save settings:', err);
      setError(err instanceof Error ? err.message : 'Failed to save configuration');
      message.error(`Save failed: ${err instanceof Error ? err.message : 'Unknown error'}`);
      // Keep form values on error so user can fix them
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="page-container">
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-semibold text-secondary-900">Settings</h1>
          <p className="text-secondary-600">
            {isEditing ? 'Modify' : 'View'} application and service configuration.
          </p>
        </div>
        {canView && ( // Show buttons only if user can view
          <div className="flex space-x-2">
            {isEditing ? (
              <>
                <Button
                  icon={<CloseOutlined />}
                  onClick={handleCancel}
                  disabled={saving}
                >
                  Cancel
                </Button>
                <Button
                  type="primary"
                  icon={<SaveOutlined />}
                  onClick={() => form.submit()} // Trigger form submission via AntD form instance
                  loading={saving}
                  disabled={!canUpdate} // Also disable if user lost update permission while editing
                >
                  Save Changes
                </Button>
              </>
            ) : (
              <Button
                icon={<EditOutlined />}
                onClick={handleEdit}
                disabled={loading || !canUpdate} // Disable if loading or no update permission
                title={!canUpdate ? "Permission denied to edit settings" : "Edit Settings"}
              >
                Edit
              </Button>
            )}
          </div>
        )}
      </div>

      {/* Permission Warning */}
      {!canView ? (
        <Alert
          message="Permission Denied"
          description="You don't have permission to view configuration settings. Please contact your administrator."
          type="warning"
          showIcon
        />
      ) : loading ? (
          <div className="flex justify-center items-center py-10">
            <Spin size="large" tip="Loading configuration..." />
          </div>
      ) : error ? (
         <Alert
             message="Error Loading Configuration"
             description={error}
             type="error"
             showIcon
             closable
             onClose={() => setError(null)}
             className="mb-4"
           />
      ) : (
        // Pass relevant state and handlers to SettingsTab
        <SettingsTab
          apiClient={apiClient}
          isEditing={isEditing}
          onSave={handleSave} // Pass the save handler
          form={form} // Pass the form instance
          initialConfig={config} // Pass the loaded config
          loading={saving} // Indicate loading state during save
          error={error} // Pass error to potentially display within tabs
        />
      )}
       {/* Display persistent errors from save below the tabs */}
       {error && !loading && (
           <Alert
             message="Save Error"
             description={error}
             type="error"
             showIcon
             closable
             onClose={() => setError(null)}
             className="mt-4"
           />
        )}
    </div>
  );
};

export default SettingsPage;

File: src/langgraph/hooks/useLangGraphDefinitions.ts
// src/langgraph/hooks/useLangGraphDefinitions.ts
import { useState, useCallback, useMemo } from 'react';
import {
  FrontendGraphDef,
  GraphDefinitionIdentifierFE,
  GraphDefinitionListResponseFE,
  CreateGraphRequestFE,
  UpdateGraphRequestFE,
  MessageResponseFE,
} from '../types/langgraph';
import { LangGraphApiService } from '../services/langGraphApiService';
import { ApiClient } from '../../api/types'; // main ApiClient type

export interface UseLangGraphDefinitionsResult {
  graphDefinitions: GraphDefinitionIdentifierFE[];
  isLoading: boolean;
  error: string | null;
  fetchGraphDefinitions: (includeStatic?: boolean) => Promise<void>;
  getGraphDefinition: (graphId: string) => Promise<FrontendGraphDef | null>;
  createGraphDefinition: (data: CreateGraphRequestFE) => Promise<FrontendGraphDef | null>;
  updateGraphDefinition: (graphId: string, data: UpdateGraphRequestFE) => Promise<FrontendGraphDef | null>;
  deleteGraphDefinition: (graphId: string) => Promise<boolean>;
}

export const useLangGraphDefinitions = (
  apiClient: ApiClient, // Pass your main ApiClient instance
  lgVisApiPrefix: string = '/v1/lg-vis' // Default prefix for LangGraph Vis backend
): UseLangGraphDefinitionsResult => {
  const [graphDefinitions, setGraphDefinitions] = useState<GraphDefinitionIdentifierFE[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);  // Initialize the langGraphApiService once and memoize it to prevent recreation on every render
  const langGraphService = useMemo(
    () => new LangGraphApiService(apiClient, lgVisApiPrefix),
    [apiClient, lgVisApiPrefix]
  );

  const fetchGraphDefinitions = useCallback(async (includeStatic: boolean = false) => {
    setIsLoading(true);
    setError(null);
    try {
      console.log('[useLangGraphDefinitions] Fetching graphs with includeStatic =', includeStatic);
      const response: GraphDefinitionListResponseFE = await langGraphService.listGraphDefinitions(includeStatic);
      console.log('[useLangGraphDefinitions] Received response:', response);
      setGraphDefinitions(response.graphs || []);
    } catch (err) {
      console.error('[useLangGraphDefinitions] Error fetching graph definitions:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to load graph definitions.';
      setError(errorMessage);
      // Only clear data on error if we don't have any existing data to maintain UX
      if (graphDefinitions.length === 0) {
        setGraphDefinitions([]);
      }
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, graphDefinitions.length]); // Dependency: langGraphService and current graphDefinitions length

  const getGraphDefinition = useCallback(async (graphId: string): Promise<FrontendGraphDef | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const graphDef: FrontendGraphDef = await langGraphService.getGraphDefinition(graphId);
      return graphDef;
    } catch (err) {
      console.error(`[useLangGraphDefinitions] Error fetching graph definition ${graphId}:`, err);
      const errorMessage = err instanceof Error ? err.message : `Failed to load graph definition ${graphId}.`;
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService]); // Dependency: langGraphService

  const createGraphDefinition = useCallback(async (data: CreateGraphRequestFE): Promise<FrontendGraphDef | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const newGraphDef: FrontendGraphDef = await langGraphService.createGraphDefinition(data);
      // After creating, refresh the list of definitions
      await fetchGraphDefinitions(); // Or optimistically add to list
      return newGraphDef;
    } catch (err) {
      console.error('[useLangGraphDefinitions] Error creating graph definition:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to create graph definition.';
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, fetchGraphDefinitions]);

  const updateGraphDefinition = useCallback(async (graphId: string, data: UpdateGraphRequestFE): Promise<FrontendGraphDef | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const updatedGraphDef: FrontendGraphDef = await langGraphService.updateGraphDefinition(graphId, data);
      // After updating, refresh the list of definitions
      await fetchGraphDefinitions(); // Or optimistically update in list
      return updatedGraphDef;
    } catch (err) {
      console.error(`[useLangGraphDefinitions] Error updating graph definition ${graphId}:`, err);
      // Ensure err is treated as Error type for message property
      const errorMessage = err instanceof Error ? err.message : `Failed to update graph definition ${graphId}.`;
      setError(errorMessage);
      return null; // Ensure null is returned here
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, fetchGraphDefinitions]);

  const deleteGraphDefinition = useCallback(async (graphId: string): Promise<boolean> => {
    setIsLoading(true);
    setError(null);
    try {
      const response: MessageResponseFE = await langGraphService.deleteGraphDefinition(graphId);
      console.log(response.message); // Keep or remove logging as needed
      // After deleting, refresh the list of definitions
      await fetchGraphDefinitions();
      return true;
    } catch (err) {
      console.error(`[useLangGraphDefinitions] Error deleting graph definition ${graphId}:`, err);
      const errorMessage = err instanceof Error ? err.message : `Failed to delete graph definition ${graphId}.`;
      setError(errorMessage);
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [langGraphService, fetchGraphDefinitions]);

  // Removed initial useEffect for fetching definitions, as per original commented-out code.
  // Pages can trigger fetchGraphDefinitions as needed.

  return {
    graphDefinitions,
    isLoading,
    error,
    fetchGraphDefinitions,
    getGraphDefinition,
    createGraphDefinition,
    updateGraphDefinition,
    deleteGraphDefinition,
  };
};

File: src/langgraph/services/langGraphStreamService.ts
// src/langgraph/services/langGraphStreamService.ts
import { LangGraphExecutionEvent, ExecuteGraphRequestFE } from '../types/langgraph';

export type LangGraphStreamMessageHandler = (event: LangGraphExecutionEvent) => void;
export type LangGraphStreamErrorHandler = (error: Error) => void;
export type LangGraphStreamOpenHandler = () => void;
export type LangGraphStreamCloseHandler = () => void;

interface LangGraphStreamServiceOptions {
  onOpen?: LangGraphStreamOpenHandler;
  onMessage: LangGraphStreamMessageHandler;
  onError?: LangGraphStreamErrorHandler;
  onClose?: LangGraphStreamCloseHandler;
  baseUrl?: string;
}

export class LangGraphStreamService {
  private abortController: AbortController | null = null;
  private readonly onOpenCallback?: LangGraphStreamOpenHandler;
  private readonly onMessageCallback: LangGraphStreamMessageHandler;
  private readonly onErrorCallback?: LangGraphStreamErrorHandler;
  private readonly onCloseCallback?: LangGraphStreamCloseHandler;
  private baseUrl: string;

  constructor(options: LangGraphStreamServiceOptions) {
    this.onOpenCallback = options.onOpen;
    this.onMessageCallback = options.onMessage;
    this.onErrorCallback = options.onError;
    this.onCloseCallback = options.onClose;
    this.baseUrl = options.baseUrl || '/api/v1/lg-vis';
  }

  public async connect(graphId: string, executionRequest: ExecuteGraphRequestFE): Promise<string> {
    this.close(); // Close any existing connection

    this.abortController = new AbortController();

    try {
      const response = await fetch(`${this.baseUrl}/graphs/${graphId}/execute/stream`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/x-ndjson',
        },
        body: JSON.stringify({
          input_args: executionRequest.inputArgs,
          simulation_delay_ms: executionRequest.simulation_delay_ms,
        }),
        signal: this.abortController.signal,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to start execution: ${response.status} - ${errorText}`);
      }

      // Get execution ID from response header
      const executionId = response.headers.get('X-Execution-ID') || 'unknown';
      
      // Process the stream
      this.processStream(response, executionId);

      return executionId;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('[LangGraphStreamService] Stream aborted');
      } else {
        console.error('[LangGraphStreamService] Connection error:', error);
        this.onErrorCallback?.(error as Error);
      }
      throw error;
    }
  }

  private async processStream(response: Response, executionId: string): Promise<void> {
    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    if (!reader) {
      throw new Error('No response body available');
    }

    let buffer = '';

    try {
      this.onOpenCallback?.();

      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          console.log('[LangGraphStreamService] Stream completed');
          // Process any remaining data in buffer
          if (buffer.trim()) {
            this.processLine(buffer);
          }
          this.onCloseCallback?.();
          break;
        }

        // Decode the chunk and add to buffer
        buffer += decoder.decode(value, { stream: true });
        
        // Process complete lines
        const lines = buffer.split('\n');
        // Keep the last incomplete line in the buffer
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim()) {
            this.processLine(line);
          }
        }
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        console.log('[LangGraphStreamService] Stream processing aborted');
      } else {
        console.error('[LangGraphStreamService] Stream processing error:', error);
        this.onErrorCallback?.(error as Error);
      }
    } finally {
      reader.releaseLock();
    }
  }

  private processLine(line: string): void {
    try {
      const event = JSON.parse(line) as LangGraphExecutionEvent;
      console.log('[LangGraphStreamService] Received event:', event.eventType, event);
      this.onMessageCallback(event);
    } catch (error) {
      console.error('[LangGraphStreamService] Error parsing line:', error, 'Line:', line);
    }
  }

  public close(): void {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }
}

File: src/langgraph/services/streamServiceFactory.ts
// src/langgraph/services/streamServiceFactory.ts
import { LangGraphExecutionEvent, ExecuteGraphRequestFE } from '../types/langgraph';
import { LangGraphSocketService } from './langGraphSocketService';
import { LangGraphSSEService } from './langGraphSSEService';
import { LangGraphStreamService } from './langGraphStreamService';

// Define the transport types
export type StreamTransportType = 'websocket' | 'sse' | 'http-stream';

// Common interface for all stream services
export interface ILangGraphStreamService {
  connect(graphId: string, executionRequest: ExecuteGraphRequestFE): Promise<string>;
  close(): void;
  send?(message: any): void; // Optional - only for WebSocket
}

// Event handlers interface
export interface StreamServiceHandlers {
  onOpen?: () => void;
  onMessage: (event: LangGraphExecutionEvent) => void;
  onError?: (error: Error) => void;
  onClose?: () => void;
}

// Adapter for WebSocket to match the common interface
class WebSocketServiceAdapter implements ILangGraphStreamService {
  private service: LangGraphSocketService;
  private executionRequest?: ExecuteGraphRequestFE;

  constructor(handlers: StreamServiceHandlers, baseUrl?: string) {
    this.service = new LangGraphSocketService({
      onOpen: () => {
        handlers.onOpen?.();
        // Send initial message after connection opens
        if (this.executionRequest) {
          this.service.send(this.executionRequest);
        }
      },
      onMessage: handlers.onMessage,
      onError: handlers.onError 
        ? (event: Event) => {
            // Convert Event to Error with details
            const errorMessage = event instanceof ErrorEvent 
              ? `WebSocket error: ${event.message}` 
              : `WebSocket error: ${event.type}`;
            const error = new Error(errorMessage);
            handlers.onError?.(error);
          }
        : undefined,
      onClose: handlers.onClose,
      baseWsUrl: baseUrl,
    });
  }

  async connect(graphId: string, executionRequest: ExecuteGraphRequestFE): Promise<string> {
    this.executionRequest = executionRequest;
    // Generate execution ID for WebSocket (since it doesn't return one)
    const executionId = `ws_exec_${Math.random().toString(36).substr(2, 9)}`;
    this.service.connect(graphId, executionId);
    return executionId;
  }

  close(): void {
    this.service.close();
  }

  send(message: any): void {
    this.service.send(message);
  }
}

// Configuration for the factory
export interface StreamServiceConfig {
  transport: StreamTransportType;
  baseUrl?: string;
  handlers: StreamServiceHandlers;
}

// Factory class
export class StreamServiceFactory {
  private static instance: StreamServiceFactory;
  private defaultTransport: StreamTransportType = 'http-stream';

  private constructor() {}

  static getInstance(): StreamServiceFactory {
    if (!StreamServiceFactory.instance) {
      StreamServiceFactory.instance = new StreamServiceFactory();
    }
    return StreamServiceFactory.instance;
  }

  // Set default transport type (can be from environment or config)
  setDefaultTransport(transport: StreamTransportType): void {
    this.defaultTransport = transport;
    console.log(`[StreamServiceFactory] Default transport set to: ${transport}`);
  }

  // Create a stream service based on configuration
  createService(config: StreamServiceConfig): ILangGraphStreamService {
    const transport = config.transport || this.defaultTransport;
    console.log(`[StreamServiceFactory] Creating ${transport} service`);

    switch (transport) {
      case 'websocket':
        return new WebSocketServiceAdapter(config.handlers, config.baseUrl);

      case 'sse':
        // SSE service already matches the interface
        return new LangGraphSSEService({
          ...config.handlers,
          baseUrl: config.baseUrl,
        });

      case 'http-stream':
        // HTTP Stream service already matches the interface
        return new LangGraphStreamService({
          ...config.handlers,
          baseUrl: config.baseUrl,
        });

      default:
        throw new Error(`Unknown transport type: ${transport}`);
    }
  }

  // Get transport type from environment or config
  static getTransportFromConfig(): StreamTransportType {
    // Check environment variable
    const envTransport = process.env.REACT_APP_LANGGRAPH_TRANSPORT;
    if (envTransport && ['websocket', 'sse', 'http-stream'].includes(envTransport)) {
      return envTransport as StreamTransportType;
    }

    // Check local storage for user preference
    const storageTransport = localStorage.getItem('langgraph_transport');
    if (storageTransport && ['websocket', 'sse', 'http-stream'].includes(storageTransport)) {
      return storageTransport as StreamTransportType;
    }

    // Default to http-stream
    return 'http-stream';
  }
}

File: src/langgraph/hooks/useLangGraphRunner.ts
// src/langgraph/hooks/useLangGraphRunner.ts
import { useState, useCallback, useRef, useEffect } from 'react';
import {
  LangGraphExecutionEvent,
  ExecuteGraphRequestFE,
  GraphErrorEventFE,
} from '../types/langgraph';
import { 
  StreamServiceFactory, 
  ILangGraphStreamService,
  StreamTransportType 
} from '../services/streamServiceFactory';

export type GraphExecutionStatus =
  | 'idle'
  | 'connecting'
  | 'running'
  | 'completed'
  | 'error';

export interface ExecutionState {
  activeNodeIds: Set<string>;
  completedNodeIds: Set<string>;
  errorNodeIds: Set<string>;
  traversedEdgeIds: Set<string>;
  lastInputByNode: Record<string, any>;
  lastOutputByNode: Record<string, any>;
}

const initialExecutionState: ExecutionState = {
  activeNodeIds: new Set(),
  completedNodeIds: new Set(),
  errorNodeIds: new Set(),
  traversedEdgeIds: new Set(),
  lastInputByNode: {},
  lastOutputByNode: {},
};

export interface UseLangGraphRunnerOptions {
  baseUrl?: string;
  transport?: StreamTransportType;
  autoSelectTransport?: boolean; // Auto-select based on capabilities
}

export interface UseLangGraphRunnerResult {
  connectAndExecute: (
    graphId: string,
    executionRequest: ExecuteGraphRequestFE
  ) => Promise<void>;
  disconnect: () => void;
  executionEvents: LangGraphExecutionEvent[];
  currentExecutionId: string | null;
  status: GraphExecutionStatus;
  error: string | null;
  graphError: GraphErrorEventFE | null;
  currentGraphState: ExecutionState;
  currentTransport: StreamTransportType;
  setTransport: (transport: StreamTransportType) => void;
}

export const useLangGraphRunner = (
  options: UseLangGraphRunnerOptions = {}
): UseLangGraphRunnerResult => {
  const factory = StreamServiceFactory.getInstance();
  const [streamService, setStreamService] = useState<ILangGraphStreamService | null>(null);
  const [executionEvents, setExecutionEvents] = useState<LangGraphExecutionEvent[]>([]);
  const [currentExecutionId, setCurrentExecutionId] = useState<string | null>(null);
  const [status, setStatus] = useState<GraphExecutionStatus>('idle');
  const [error, setError] = useState<string | null>(null);
  const [graphError, setGraphError] = useState<GraphErrorEventFE | null>(null);
  const [currentGraphState, setCurrentGraphState] = useState<ExecutionState>(initialExecutionState);
  
  // Transport selection
  const [currentTransport, setCurrentTransport] = useState<StreamTransportType>(() => {
    return options.transport || StreamServiceFactory.getTransportFromConfig();
  });

  const mountedRef = useRef(true);

  useEffect(() => {
    mountedRef.current = true;
    // Set default transport in factory
    factory.setDefaultTransport(currentTransport);
    
    return () => {
      mountedRef.current = false;
      disconnect();
    };
  }, []);

  const handleNewEvent = useCallback((event: LangGraphExecutionEvent) => {
    if (!mountedRef.current) return;

    console.log(`[useLangGraphRunner] Received event: ${event.eventType}`, event);
    setExecutionEvents((prevEvents) => [...prevEvents, event]);

    switch (event.eventType) {
      case 'graph_execution_start':
        setStatus('running');
        setCurrentExecutionId(event.executionId);
        setCurrentGraphState(initialExecutionState);
        break;

      case 'node_start':
        setCurrentGraphState((prevState) => {
          const newState = {
            ...prevState,
            activeNodeIds: new Set(prevState.activeNodeIds),
            completedNodeIds: new Set(prevState.completedNodeIds),
            errorNodeIds: new Set(prevState.errorNodeIds),
            lastInputByNode: { ...prevState.lastInputByNode },
          };
          
          newState.activeNodeIds.add(event.nodeId);
          newState.completedNodeIds.delete(event.nodeId);
          newState.errorNodeIds.delete(event.nodeId);
          newState.lastInputByNode[event.nodeId] = event.inputData;
          
          return newState;
        });
        break;

      case 'node_end':
        setCurrentGraphState((prevState) => {
          const newState = {
            ...prevState,
            activeNodeIds: new Set(prevState.activeNodeIds),
            completedNodeIds: new Set(prevState.completedNodeIds),
            errorNodeIds: new Set(prevState.errorNodeIds),
            lastOutputByNode: { ...prevState.lastOutputByNode },
          };
          
          newState.activeNodeIds.delete(event.nodeId);
          
          if (event.status === 'success') {
            newState.completedNodeIds.add(event.nodeId);
          } else {
            newState.errorNodeIds.add(event.nodeId);
          }
          
          newState.lastOutputByNode[event.nodeId] = event.outputData;
          
          return newState;
        });
        break;

      case 'edge_taken':
        setCurrentGraphState((prevState) => {
          const newState = {
            ...prevState,
            traversedEdgeIds: new Set(prevState.traversedEdgeIds),
          };
          
          const edgeId = `${event.sourceNodeId}__${event.targetNodeId}${
            event.edgeLabel ? `__${event.edgeLabel}` : ''
          }`;
          newState.traversedEdgeIds.add(edgeId);
          
          return newState;
        });
        break;

      case 'graph_execution_end':
        setStatus('completed');
        break;

      case 'graph_error':
        setGraphError(event as GraphErrorEventFE);
        setStatus('error');
        break;
    }
  }, []);

  const connectAndExecute = useCallback(async (
    graphId: string,
    executionRequest: ExecuteGraphRequestFE
  ) => {
    if (streamService) {
      streamService.close();
    }

    if (!mountedRef.current) return;

    setExecutionEvents([]);
    setCurrentGraphState(initialExecutionState);
    setStatus('connecting');
    setError(null);
    setGraphError(null);

    // Create service using factory
    const newService = factory.createService({
      transport: currentTransport,
      baseUrl: options.baseUrl,
      handlers: {
        onOpen: () => {
          if (!mountedRef.current) return;
          console.log(`[useLangGraphRunner] ${currentTransport} connection opened`);
          setStatus('running');
        },
        onMessage: handleNewEvent,
        onError: (err) => {
          if (!mountedRef.current) return;
          console.error(`[useLangGraphRunner] ${currentTransport} Error:`, err);
          setError(err.message);
          setStatus('error');
        },
        onClose: () => {
          if (!mountedRef.current) return;
          console.log(`[useLangGraphRunner] ${currentTransport} connection closed`);
          if (status === 'running' || status === 'connecting') {
            setStatus('completed');
          }
        },
      },
    });

    try {
      const executionId = await newService.connect(graphId, executionRequest);
      if (mountedRef.current) {
        setCurrentExecutionId(executionId);
        setStreamService(newService);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('[useLangGraphRunner] Failed to connect:', err);
        setError(err instanceof Error ? err.message : 'Failed to connect');
        setStatus('error');
      }
    }
  }, [streamService, handleNewEvent, currentTransport, options.baseUrl, factory, status]);

  const disconnect = useCallback(() => {
    if (streamService) {
      streamService.close();
      setStreamService(null);
      if (status === 'running' || status === 'connecting') {
        setStatus('completed');
      }
    }
  }, [streamService, status]);

  const setTransport = useCallback((transport: StreamTransportType) => {
    console.log(`[useLangGraphRunner] Changing transport from ${currentTransport} to ${transport}`);
    
    // Disconnect current service if any
    disconnect();
    
    // Update transport
    setCurrentTransport(transport);
    factory.setDefaultTransport(transport);
    
    // Save preference
    localStorage.setItem('langgraph_transport', transport);
  }, [currentTransport, disconnect, factory]);

  return {
    connectAndExecute,
    disconnect,
    executionEvents,
    currentExecutionId,
    status,
    error,
    graphError,
    currentGraphState,
    currentTransport,
    setTransport,
  };
};

File: src/langgraph/hooks/useLangGraphSSERunner.ts
// src/langgraph/hooks/useLangGraphSSERunner.ts
import { useState, useCallback, useRef } from 'react';
import {
  LangGraphExecutionEvent,
  ExecuteGraphRequestFE,
  GraphErrorEventFE,
} from '../types/langgraph';
import { LangGraphSSEService } from '../services/langGraphSSEService';

export type GraphExecutionStatus =
  | 'idle'
  | 'connecting'
  | 'running'
  | 'completed'
  | 'error';

export interface ExecutionState {
  activeNodeIds: Set<string>;
  completedNodeIds: Set<string>;
  errorNodeIds: Set<string>;
  traversedEdgeIds: Set<string>;
  lastInputByNode: Record<string, any>;
  lastOutputByNode: Record<string, any>;
}

const initialExecutionState: ExecutionState = {
  activeNodeIds: new Set(),
  completedNodeIds: new Set(),
  errorNodeIds: new Set(),
  traversedEdgeIds: new Set(),
  lastInputByNode: {},
  lastOutputByNode: {},
};

export interface UseLangGraphSSERunnerResult {
  connectAndExecute: (
    graphId: string,
    executionRequest: ExecuteGraphRequestFE
  ) => Promise<void>;
  disconnect: () => void;
  executionEvents: LangGraphExecutionEvent[];
  currentExecutionId: string | null;
  status: GraphExecutionStatus;
  error: string | null;
  graphError: GraphErrorEventFE | null;
  currentGraphState: ExecutionState;
}

export const useLangGraphSSERunner = (
  baseUrl?: string
): UseLangGraphSSERunnerResult => {
  const [sseService, setSseService] = useState<LangGraphSSEService | null>(null);
  const [executionEvents, setExecutionEvents] = useState<LangGraphExecutionEvent[]>([]);
  const [currentExecutionId, setCurrentExecutionId] = useState<string | null>(null);
  const [status, setStatus] = useState<GraphExecutionStatus>('idle');
  const [error, setError] = useState<string | null>(null);
  const [graphError, setGraphError] = useState<GraphErrorEventFE | null>(null);
  const [currentGraphState, setCurrentGraphState] = useState<ExecutionState>(initialExecutionState);

  const mountedRef = useRef(true);

  const handleNewEvent = useCallback((event: LangGraphExecutionEvent) => {
    if (!mountedRef.current) return;

    console.log(`[useLangGraphSSERunner] Received event: ${event.eventType}`, event);
    setExecutionEvents((prevEvents) => [...prevEvents, event]);

    switch (event.eventType) {
      case 'graph_execution_start':
        setStatus('running');
        setCurrentExecutionId(event.executionId);
        setCurrentGraphState(initialExecutionState);
        break;

      case 'node_start':
        setCurrentGraphState((prevState) => {
          const newState = { ...prevState };
          newState.activeNodeIds = new Set(prevState.activeNodeIds);
          newState.activeNodeIds.add(event.nodeId);
          newState.completedNodeIds = new Set(prevState.completedNodeIds);
          newState.completedNodeIds.delete(event.nodeId);
          newState.errorNodeIds = new Set(prevState.errorNodeIds);
          newState.errorNodeIds.delete(event.nodeId);
          newState.lastInputByNode = { ...prevState.lastInputByNode };
          newState.lastInputByNode[event.nodeId] = event.inputData;
          return newState;
        });
        break;

      case 'node_end':
        setCurrentGraphState((prevState) => {
          const newState = { ...prevState };
          newState.activeNodeIds = new Set(prevState.activeNodeIds);
          newState.activeNodeIds.delete(event.nodeId);
          
          if (event.status === 'success') {
            newState.completedNodeIds = new Set(prevState.completedNodeIds);
            newState.completedNodeIds.add(event.nodeId);
          } else {
            newState.errorNodeIds = new Set(prevState.errorNodeIds);
            newState.errorNodeIds.add(event.nodeId);
          }
          
          newState.lastOutputByNode = { ...prevState.lastOutputByNode };
          newState.lastOutputByNode[event.nodeId] = event.outputData;
          return newState;
        });
        break;

      case 'graph_execution_end':
        setStatus('completed');
        break;

      case 'graph_error':
        setGraphError(event as GraphErrorEventFE);
        setStatus('error');
        break;
    }
  }, []);

  const connectAndExecute = useCallback(async (
    graphId: string,
    executionRequest: ExecuteGraphRequestFE
  ) => {
    if (sseService) {
      sseService.close();
    }

    setExecutionEvents([]);
    setCurrentGraphState(initialExecutionState);
    setStatus('connecting');
    setError(null);
    setGraphError(null);

    const newSSEService = new LangGraphSSEService({
      onOpen: () => {
        console.log('[useLangGraphSSERunner] SSE connection opened');
        setStatus('running');
      },
      onMessage: handleNewEvent,
      onError: (err) => {
        console.error('[useLangGraphSSERunner] SSE Error:', err);
        setError(err.message);
        setStatus('error');
      },
      onClose: () => {
        console.log('[useLangGraphSSERunner] SSE connection closed');
        if (status === 'running') {
          setStatus('completed');
        }
      },
      baseUrl,
    });

    try {
      const executionId = await newSSEService.connect(graphId, executionRequest);
      setCurrentExecutionId(executionId);
      setSseService(newSSEService);
    } catch (err) {
      console.error('[useLangGraphSSERunner] Failed to connect:', err);
      setError(err instanceof Error ? err.message : 'Failed to connect');
      setStatus('error');
    }
  }, [sseService, handleNewEvent, baseUrl, status]);

  const disconnect = useCallback(() => {
    if (sseService) {
      sseService.close();
      setSseService(null);
      if (status === 'running') {
        setStatus('completed');
      }
    }
  }, [sseService, status]);

  return {
    connectAndExecute,
    disconnect,
    executionEvents,
    currentExecutionId,
    status,
    error,
    graphError,
    currentGraphState,
  };
};

File: src/langgraph/pages/LangGraphViewPage.tsx
// src/langgraph/pages/LangGraphViewPage.tsx

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
// Import ReactFlowProvider and ensure useReactFlow is imported
import { useReactFlow, ReactFlowProvider, Node, Edge, NodeMouseHandler, EdgeMouseHandler } from 'reactflow'; 
import { Button, Input, Card, Spin, Alert, Typography, Tooltip, Modal, Row, Col, Tag, Checkbox, InputNumber } from 'antd';
import { PlayCircleOutlined, StopOutlined, EditOutlined, ReloadOutlined, ShareAltOutlined } from '@ant-design/icons';

import { useAuth } from '../../context/AuthContext'; 
import { useLangGraphDefinitions } from '../hooks/useLangGraphDefinitions';
import { useReactFlowGraphAdapter } from '../hooks/useReactFlowGraphAdapter';
import { FrontendGraphDef, ReactFlowNodeData, ReactFlowEdgeData, ExecuteGraphRequestFE } from '../types/langgraph';
import LangGraphCanvas from '../components/LangGraphCanvas';
import NodeInspectorPanel from '../components/NodeInspectorPanel';
import { useLangGraphRunner } from '../hooks/useLangGraphRunner';
import { TransportSelector } from '../components/TransportSelector';

const { Title, Text, Paragraph } = Typography;
const { TextArea } = Input;

// Using direct string comparisons for execution status checks
const LangGraphViewPageContent: React.FC = () => {
  const { graphId } = useParams<{ graphId: string }>();
  const navigate = useNavigate();
  const { apiClient, checkPermission } = useAuth();
  const { fitView } = useReactFlow();

  const { getGraphDefinition, isLoading: isLoadingDefinition, error: definitionLoadingError } = useLangGraphDefinitions(apiClient, '/v1/lg-vis');
  const [graphDefinition, setGraphDefinition] = useState<FrontendGraphDef | null>(null);

  const {
    nodes: rfNodes,
    edges: rfEdges,
    layoutGraph,
    isLoadingLayout,
    errorLayout,
  } = useReactFlowGraphAdapter();
  
  const {
    currentGraphState,
    connectAndExecute,
    status,
    // executionEvents, // Commented out as unused for now
    currentExecutionId,
    error, 
    graphError, 
    currentTransport,
    setTransport,
    disconnect, // <-- Add disconnect here
  }  = useLangGraphRunner({
    transport: 'http-stream', // Optional: override default
    baseUrl: '/api/v1/lg-vis',
  });

  const [initialArgsJson, setInitialArgsJson] = useState<string>('{}');
  const [selectedElement, setSelectedElement] = useState<Node<ReactFlowNodeData> | Edge<ReactFlowEdgeData> | null>(null);
  const [isInspectorPanelOpen, setIsInspectorPanelOpen] = useState<boolean>(false);
  const [simulateDelay, setSimulateDelay] = useState<boolean>(false);
  const [delayMs, setDelayMs] = useState<number>(1000);

  useEffect(() => {
    if (graphId) {
      const fetchDef = async () => {
        setSelectedElement(null); 
        setIsInspectorPanelOpen(false);
        setGraphDefinition(null); 
        const definition = await getGraphDefinition(graphId);
        if (definition) {
          setGraphDefinition(definition);
        }
      };
      fetchDef();
    }
    // Optional: return disconnect function from useLangGraphSSERunner if needed for cleanup
    // return () => { disconnect?.(); }; 
  }, [graphId, getGraphDefinition]);

  useEffect(() => {
    if (graphDefinition) {
      layoutGraph(graphDefinition);
    }
  }, [graphDefinition, layoutGraph]);

  useEffect(() => {
    if (rfNodes.length > 0 && fitView) {
      const timer = setTimeout(() => fitView({ duration: 500, padding: 0.1 }), 100);
      return () => clearTimeout(timer);
    }
  }, [rfNodes, fitView, status]); 

  const handleExecuteGraph = useCallback(() => {
    if (!graphId || !graphDefinition) {
      Modal.error({ title: 'Error', content: 'Graph definition not loaded.' });
      return;
    }
   
    if (status === 'running' || status === 'connecting') { 
      Modal.warn({ title: 'In Progress', content: 'Graph is already running or attempting to connect.' });
      return;
    }
    
    let parsedArgs: Record<string, any> = {};
    try {
      parsedArgs = JSON.parse(initialArgsJson);
    } catch (e) {
      Modal.error({ title: 'Invalid Input', content: 'Initial arguments must be valid JSON.' });
      return;
    }

    const executionOptions: ExecuteGraphRequestFE = {
      inputArgs: parsedArgs,
    };

    if (simulateDelay && delayMs > 0) {
      executionOptions.simulation_delay_ms = delayMs;
    }

    connectAndExecute(graphId, executionOptions);
  }, [graphId, graphDefinition, initialArgsJson, connectAndExecute, status, simulateDelay, delayMs]);

  const handleStopExecution = useCallback(() => {
    if (disconnect) {
      disconnect(); // <-- Call disconnect
    }
  }, [disconnect]); // <-- Add disconnect to dependency array

  const onNodeClickHandler: NodeMouseHandler = useCallback((_event: React.MouseEvent, node: Node<ReactFlowNodeData>) => { // Prefixed event with _
    const enrichedNodeData: ReactFlowNodeData = {
      ...node.data,
      inputs: currentGraphState.lastInputByNode[node.id],
      outputs: currentGraphState.lastOutputByNode[node.id],
    };
    setSelectedElement({ ...node, data: enrichedNodeData } as Node<ReactFlowNodeData>);
    setIsInspectorPanelOpen(true);
  }, [currentGraphState]);

  const onEdgeClickHandler: EdgeMouseHandler = useCallback((_event: React.MouseEvent, edge: Edge<ReactFlowEdgeData>) => { // Prefixed event with _
    setSelectedElement(edge as Edge<ReactFlowEdgeData>);
    setIsInspectorPanelOpen(true);
  }, []);

  const closeInspectorPanel = useCallback(() => {
    setIsInspectorPanelOpen(false);
    setSelectedElement(null); 
  }, []);

  const styledNodes = useMemo(() => {
    if (!rfNodes) return [];
    return rfNodes.map(node => {
      const graphNodeState: ReactFlowNodeData['status'] =
                             currentGraphState.activeNodeIds.has(node.id) ? 'running' :
                             currentGraphState.completedNodeIds.has(node.id) ? 'success' : 
                             currentGraphState.errorNodeIds.has(node.id) ? 'error' : 
                             'idle';
      const lastOutput = currentGraphState.lastOutputByNode[node.id];
      const nodeSpecificError = graphError?.nodeId === node.id ? graphError : null;

      return {
        ...node,
        data: {
          ...node.data,
          status: graphNodeState,
          outputData: lastOutput,
          errorMessage: nodeSpecificError?.message, // Use .message from GraphErrorEventFE
        },
      };
    });
  }, [rfNodes, currentGraphState, graphError]);

  const styledEdges = useMemo(() => {
    if (!rfEdges) return [];
    return rfEdges.map(edge => {
      const currentEdgeData = edge.data || {};
      return {
        ...edge,
        animated: false,
        style: {
          stroke: '#b1b1b7',
          strokeWidth: 1.5,
        },
        data: {
          ...currentEdgeData,
          status: 'idle', // This should now be correctly typed via ReactFlowEdgeData
        } as ReactFlowEdgeData, // Explicitly cast the data object
      };
    });
  }, [rfEdges]);

  if (isLoadingDefinition) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 'calc(100vh - 64px)' }}>
        <Spin size="large" tip="Loading graph definition...">
          {/* Added a placeholder div for Spin to wrap, can be adjusted if there's specific content to show while loading */}
          <div style={{ width: '100%', height: '100px' }} />
        </Spin>
      </div>
    );
  }

  if (definitionLoadingError) {
    return (
      <div style={{ padding: '20px' }}>
        <Alert message="Error Loading Graph Definition" description={definitionLoadingError} type="error" showIcon />
      </div>
    );
  }

  if (!graphDefinition) {
    return (
      <div style={{ padding: '20px' }}>
        <Alert message="Graph Not Found" description={`The graph with ID "${graphId}" could not be found or loaded.`} type="warning" showIcon />
        <Button onClick={() => navigate('/langgraph/graphs')} style={{ marginTop: '10px' }}>Back to Graphs List</Button>
      </div>
    );
  }

  return (
    <div className="page-container" style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 64px)'}}>
      <Card
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Title level={3} style={{ margin: 0, display: 'flex', alignItems: 'center' }}>
              <ShareAltOutlined style={{ marginRight: '10px' }} />
              {graphDefinition.name}
              <Text type="secondary" style={{ marginLeft: '10px', fontSize: '0.9em' }}>(ID: {graphDefinition.id})</Text>
            </Title>
            {checkPermission('langgraph:edit') && !graphDefinition.id.startsWith('static_') && (
                <Tooltip title="Edit Graph Definition">
                    <Button
                        htmlType="button"
                        icon={<EditOutlined />}
                        onClick={(e) => {
                            e.preventDefault();
                            navigate(`/langgraph/edit/${graphId}`);
                        }}
                    >
                        Edit
                    </Button>                
                </Tooltip>
            )}
          </div>
        }
        variant="borderless"
        style={{ marginBottom: '16px' }}
      >
        {graphDefinition.description && <Paragraph type="secondary">{graphDefinition.description}</Paragraph>}
        
        <div>
          <Row gutter={16} align="bottom" style={{ marginBottom: '16px' }}>
            <Col flex="auto">
              <Text strong>Initial Arguments (JSON):</Text>
              <TextArea
                rows={3}
                value={initialArgsJson}
                onChange={(e) => setInitialArgsJson(e.target.value)}
                placeholder='e.g., {"input": "User query here..."}'
                disabled={status === 'running' || status === 'connecting'} 
                style={{ fontFamily: 'monospace', fontSize: '12px' }}
              />
            </Col>
          </Row>
          
          {/* Unified controls row */}
          <Row gutter={16} align="middle" style={{ marginBottom: '16px' }}>
            <Col>
              <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                {!['running', 'connecting'].includes(status) ? ( 
                  <Tooltip title="Start graph execution">
                    <Button
                      type="primary"
                      icon={<PlayCircleOutlined />}
                      onClick={handleExecuteGraph}
                      loading={status === 'connecting'}
                      disabled={!checkPermission('langgraph:execute') || ['running', 'connecting'].includes(status)} 
                    >
                      Execute
                    </Button>
                  </Tooltip>
                ) : (
                  <Tooltip title="Stop graph execution (Note: SSE stop might be server-side or client-side navigation)">
                    <Button
                      type="default"
                      danger
                      icon={<StopOutlined />}
                      onClick={handleStopExecution} // Ensure this function correctly stops SSE if possible
                      disabled={!['running'].includes(status)} 
                    >
                      Stop
                    </Button>
                  </Tooltip>
                )}
                <Tooltip title="Reload graph definition and reset layout">
                  <Button
                    icon={<ReloadOutlined />}
                    onClick={() => {
                      // disconnect?.(); // Optional: disconnect before reloading
                      if(graphId) getGraphDefinition(graphId).then(def => def && setGraphDefinition(def));
                    }}
                    disabled={isLoadingDefinition || isLoadingLayout}
                  >
                    Reload Graph
                  </Button>
                </Tooltip>
                
                <Text>Execution Status: <Tag color={
                  status === 'running' ? 'blue' : 
                  status === 'completed' ? 'green' :
                  status === 'error' ? 'red' :
                  status === 'connecting' ? 'geekblue' :
                  'default'
                }>{status.toUpperCase()}</Tag></Text>
                {currentExecutionId && <Text type="secondary">Run ID: <Text copyable code style={{fontSize: '1em'}}>{currentExecutionId}</Text></Text>}
              </div>
            </Col>
            <Col>
              <TransportSelector
                currentTransport={currentTransport}
                onTransportChange={setTransport}
                disabled={['running', 'connecting'].includes(status)}
              />
            </Col>
            <Col>
              <Checkbox
                checked={simulateDelay}
                onChange={(e) => setSimulateDelay(e.target.checked)}
                disabled={status === 'running' || status === 'connecting'} 
              >
                Simulate Node Delay
              </Checkbox>
            </Col>
            <Col>
              <InputNumber
                min={100}
                max={10000}
                step={100}
                value={delayMs}
                onChange={(value) => setDelayMs(value || 100)}
                disabled={!simulateDelay || status === 'running' || status === 'connecting'} 
                addonAfter="ms"
              />
            </Col>
          </Row>
          
          {error && <Alert message="Connection Error" description={error} type="error" showIcon style={{marginTop: '8px'}} />}
          {graphError && (
            <Alert
              message={`Graph Execution Error (Node: ${graphError.nodeId || 'N/A'})`}
              description={graphError.message + (graphError.details ? ` | Details: ${graphError.details}` : '')}
              type="error"
              showIcon
              style={{marginTop: '8px'}}
            />
          )}
        </div>
      </Card>

      <div style={{ display: 'flex', flexGrow: 1, height: '100%', overflow: 'hidden' }}>
        <div style={{ flexGrow: 1, height: '100%', position: 'relative' }}>
          {isLoadingLayout ? (
             <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                <Spin size="large" tip="Applying graph layout...">
                  {/* Added a placeholder div for Spin to wrap */}
                  <div style={{ width: '100%', height: '100px' }} />
                </Spin>
             </div>
          ) : errorLayout ? (
            <Alert message="Layout Error" description={errorLayout} type="error" showIcon />
          ) : (
            <LangGraphCanvas
              nodes={styledNodes}
              edges={styledEdges}
              onNodeClick={onNodeClickHandler}
              onEdgeClick={onEdgeClickHandler}
            />
          )}
        </div>
        {isInspectorPanelOpen && (
          <div style={{ width: '320px', minWidth: '280px', height: '100%', borderLeft: '1px solid #f0f0f0', backgroundColor: '#ffffff' }}>
            <NodeInspectorPanel
              selectedElement={selectedElement}
              onClose={closeInspectorPanel}
            />
          </div>
        )}
      </div>
    </div>
  );
};

// Wrapper component that provides the ReactFlowProvider
const LangGraphViewPage: React.FC = () => {
  return (
    <ReactFlowProvider>
      <LangGraphViewPageContent />
    </ReactFlowProvider>
  );
};

export default LangGraphViewPage;

File: src/langgraph/services/langGraphSocketService.ts
// src/langgraph/services/langGraphSocketService.ts
import {
  LangGraphExecutionEvent,
  ExecuteGraphRequestFE,
} from '../types/langgraph'; // Assuming your types are here
import { API_CONFIG } from '../../config/api'; // To construct WebSocket URL

const DEFAULT_RECONNECT_INTERVAL_MS = 5000;
const MAX_RECONNECT_ATTEMPTS = 5;
const PING_INTERVAL_MS = 30000; // 30 seconds for keep-alive ping

export type LangGraphSocketMessageHandler = (event: LangGraphExecutionEvent) => void;
export type LangGraphSocketErrorHandler = (error: Event) => void;
export type LangGraphSocketCloseHandler = (event: CloseEvent) => void;
export type LangGraphSocketOpenHandler = () => void;

interface LangGraphSocketServiceOptions {
  onOpen?: LangGraphSocketOpenHandler;
  onMessage: LangGraphSocketMessageHandler;
  onError?: LangGraphSocketErrorHandler;
  onClose?: LangGraphSocketCloseHandler;
  autoReconnect?: boolean;
  baseWsUrl?: string; // e.g., ws://localhost:8000 or wss://yourdomain.com
}

export class LangGraphSocketService {
  private ws: WebSocket | null = null;
  private graphId: string | null = null;
  private executionId: string | null = null; // Can be predefined or generated
  private readonly onOpenCallback?: LangGraphSocketOpenHandler;
  private readonly onMessageCallback: LangGraphSocketMessageHandler;
  private readonly onErrorCallback?: LangGraphSocketErrorHandler;
  private readonly onCloseCallback?: LangGraphSocketCloseHandler;

  private readonly autoReconnect: boolean;
  private explicitlyClosed: boolean = false; // Flag to indicate explicit closure
  private reconnectAttempts: number = 0;
  private reconnectIntervalId: NodeJS.Timeout | null = null;
  private pingIntervalId: NodeJS.Timeout | null = null;

  private baseWsUrl: string;

  constructor(options: LangGraphSocketServiceOptions) {
    this.onOpenCallback = options.onOpen;
    this.onMessageCallback = options.onMessage;
    this.onErrorCallback = options.onError;
    this.onCloseCallback = options.onClose;
    this.autoReconnect = options.autoReconnect !== undefined ? options.autoReconnect : true;
    this.explicitlyClosed = false; // Initialize here  // Determine base WebSocket URL
    if (options.baseWsUrl) {
        this.baseWsUrl = options.baseWsUrl;
    } else {
        // Construct from API_CONFIG (assuming HTTP/HTTPS maps to WS/WSS)
        const httpBase = API_CONFIG.baseUrl.startsWith('http')
            ? API_CONFIG.baseUrl
            : `${window.location.protocol}//${window.location.host}${API_CONFIG.baseUrl}`; // Handle relative base URL
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        this.baseWsUrl = `${wsProtocol}//${window.location.host}`; // Use current host
    }
    console.log('[LangGraphSocketService] Base WebSocket URL set to:', this.baseWsUrl);
  }  private getWebSocketUrl(): string {
    if (!this.graphId) {
      // Consider throwing an error or handling this case more robustly
      console.error("[LangGraphSocketService] Graph ID is not set.");
      throw new Error("Graph ID is not set for WebSocket connection.");
    }
    
    // Path should be relative to the baseWsUrl (which includes the API prefix like /api/v1/lg-vis)
    // The backend WebSocket endpoint is typically mounted at something like /ws/langgraph/graphs/...
    // relative to its own router prefix.
    const wsPathPrefix = "/ws/langgraph/graphs"; // Changed from "/api/v1/lg-vis/ws/langgraph/graphs"
    
    console.log('[LangGraphSocketService] Creating WebSocket URL with baseWsUrl:', this.baseWsUrl);
    console.log('[LangGraphSocketService] Using wsPathPrefix:', wsPathPrefix);

    let fullUrl: string;
    // This 'else' branch is taken when WebSocketServiceAdapter generates a client-side executionId
    if (this.executionId && !this.executionId.includes('/')) { 
      // Assumes executionId is just an ID, not a path segment
      fullUrl = `${this.baseWsUrl}${wsPathPrefix}/${this.graphId}/execute/${this.executionId}`;
    } else if (this.executionId && this.executionId.includes('/')) {
      // This case would be if executionId itself is a pre-formed path segment from baseWsUrl
      // e.g., if backend returned "/ws/langgraph/graphs/graphId/execute/execId"
      // and baseWsUrl was just "ws://host:port"
      // For now, assuming the client-generated executionId path is the primary one for this service.
      // If executionId is a full path like /api/v1/lg-vis/ws/..., then baseWsUrl should be ws://host:port
      // and this logic would need adjustment or clarification on what executionId contains.
      // Based on current setup with WebSocketServiceAdapter, this branch is less likely.
      fullUrl = `${this.baseWsUrl}${this.executionId.startsWith('/') ? '' : '/'}${this.executionId}`;
    } else {
      // Fallback or error if executionId is expected but missing or in an unexpected format
      // This path was originally for when executionId was not known.
      // Given WebSocketServiceAdapter always generates one, this might indicate an issue.
      console.warn('[LangGraphSocketService] executionId is null or in an unexpected format, constructing URL without it or with a placeholder.');
      // Defaulting to the structure used when executionId is a simple ID.
      // Consider if a different structure or error is more appropriate here.
      fullUrl = `${this.baseWsUrl}${wsPathPrefix}/${this.graphId}/execute${this.executionId ? `/${this.executionId}` : ''}`;
    }
    
    console.log('[LangGraphSocketService] Constructed WebSocket URL:', fullUrl);
    return fullUrl;
  }

  public connect(graphId: string, executionId?: string): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      console.warn('[LangGraphSocketService] WebSocket is already open.');
      return;
    }
    this.graphId = graphId;
    this.executionId = executionId || null; // If undefined, it means server will generate one
    this.explicitlyClosed = false; // Reset flag on new connection attempt

    const wsUrl = this.getWebSocketUrl();
    console.log(`[LangGraphSocketService] Attempting to connect to: ${wsUrl}`);

    this.ws = new WebSocket(wsUrl);

    this.ws.onopen = () => {
      console.log(`[LangGraphSocketService] WebSocket connected for graph '${this.graphId}', execution '${this.executionId || 'NEW'}'.`);
      this.reconnectAttempts = 0; // Reset on successful connection
      if (this.reconnectIntervalId) {
        clearInterval(this.reconnectIntervalId);
        this.reconnectIntervalId = null;
      }
      this.startPing();
      this.onOpenCallback?.();
    };

    this.ws.onmessage = (event: MessageEvent) => {
      try {
        const data = JSON.parse(event.data as string) as LangGraphExecutionEvent;
        // console.debug('[LangGraphSocketService] Message received:', data);
        this.onMessageCallback(data);
      } catch (error) {
        console.error('[LangGraphSocketService] Error parsing message or in onMessage callback:', error, event.data);
        // Optionally, notify via error callback or a specific message type
      }
    };

    this.ws.onerror = (event: Event) => {
      console.error('[LangGraphSocketService] WebSocket error:', event);
      this.onErrorCallback?.(event);
    };

    this.ws.onclose = (event: CloseEvent) => {
      console.log(`[LangGraphSocketService] WebSocket closed for graph '${this.graphId}', execution '${this.executionId || 'PREVIOUS'}'. Code: ${event.code}, Reason: ${event.reason}`);
      this.stopPing();
      this.onCloseCallback?.(event);

      // MODIFIED: Check explicitlyClosed flag
      if (!this.explicitlyClosed && this.autoReconnect && this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS && !event.wasClean) {
        this.reconnectAttempts++;
        const delay = DEFAULT_RECONNECT_INTERVAL_MS * Math.pow(2, this.reconnectAttempts -1); // Exponential backoff
        console.log(`[LangGraphSocketService] Attempting to reconnect in ${delay / 1000}s (attempt ${this.reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
        this.reconnectIntervalId = setTimeout(() => {
          if (this.graphId && !this.explicitlyClosed) { // Check again before reconnecting
            this.connect(this.graphId, this.executionId || undefined); // Pass current executionId or let server generate
          }
        }, delay);
      } else if (this.reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        console.error('[LangGraphSocketService] Max reconnect attempts reached.');
      }
    };
  }

  public send(initialMessage: ExecuteGraphRequestFE): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      try {
        const messageString = JSON.stringify(initialMessage);
        console.log('[LangGraphSocketService] Sending initial message:', messageString);
        this.ws.send(messageString);
      } catch (error) {
        console.error('[LangGraphSocketService] Error sending initial message:', error);
      }
    } else {
      console.warn('[LangGraphSocketService] WebSocket is not open. Cannot send message.');
      // Optionally queue the message or throw an error
    }
  }

  private startPing(): void {
    this.stopPing(); // Clear any existing ping interval
    this.pingIntervalId = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        // console.debug('[LangGraphSocketService] Sending ping');
        this.ws.send(JSON.stringify({ eventType: 'ping', timestamp: new Date().toISOString() }));
      } else {
        // console.debug('[LangGraphSocketService] WebSocket not open, stopping ping.');
        this.stopPing(); // Stop pinging if connection is closed for any reason
      }
    }, PING_INTERVAL_MS);
  }

  private stopPing(): void {
    if (this.pingIntervalId) {
      clearInterval(this.pingIntervalId);
      this.pingIntervalId = null;
      // console.debug('[LangGraphSocketService] Ping interval stopped.');
    }
  }

  public close(code?: number, reason?: string): void {
    this.explicitlyClosed = true; // MODIFIED: Set the flag here
    this.stopPing();
    if (this.reconnectIntervalId) {
        clearInterval(this.reconnectIntervalId);
        this.reconnectIntervalId = null;
    }
    if (this.ws) {
      console.log(`[LangGraphSocketService] Closing WebSocket explicitly. Code: ${code}, Reason: ${reason}`);
      this.ws.close(code, reason);
      this.ws = null;
    }
    this.graphId = null;
    this.executionId = null;
  }

  public getReadyState(): number | undefined {
    return this.ws?.readyState;
  }
}

File: src/langgraph/components/TransportSelector.tsx
// src/langgraph/components/TransportSelector.tsx
import React from 'react';
import { Select, Tooltip, Space, Tag } from 'antd';
import { 
  ApiOutlined, 
  CloudDownloadOutlined, 
  ThunderboltOutlined,
  InfoCircleOutlined 
} from '@ant-design/icons';
import { StreamTransportType } from '../services/streamServiceFactory';

const { Option } = Select;

interface TransportSelectorProps {
  currentTransport: StreamTransportType;
  onTransportChange: (transport: StreamTransportType) => void;
  disabled?: boolean;
}

const transportInfo = {
  'websocket': {
    label: 'WebSocket',
    icon: <ThunderboltOutlined />,
    description: 'Bidirectional real-time connection. Requires special proxy configuration.',
    pros: ['Real-time bidirectional', 'Low latency'],
    cons: ['Complex proxy setup', 'Connection state management'],
    color: 'purple',
  },
  'sse': {
    label: 'Server-Sent Events',
    icon: <CloudDownloadOutlined />,
    description: 'Server-to-client streaming with automatic reconnection.',
    pros: ['Auto-reconnect', 'Simple implementation'],
    cons: ['Text-only data', 'One-way communication'],
    color: 'blue',
  },
  'http-stream': {
    label: 'HTTP Streaming',
    icon: <ApiOutlined />,
    description: 'Standard HTTP response streaming. Most compatible.',
    pros: ['Best compatibility', 'Standard HTTP', 'Binary support'],
    cons: ['Manual reconnection needed'],
    color: 'green',
  },
};

export const TransportSelector: React.FC<TransportSelectorProps> = ({
  currentTransport,
  onTransportChange,
  disabled = false,
}) => {
  const currentInfo = transportInfo[currentTransport];

  return (
    <Space>
      <Select
        value={currentTransport}
        onChange={onTransportChange}
        disabled={disabled}
        style={{ width: 200 }}
        suffixIcon={currentInfo.icon}
      >
        {Object.entries(transportInfo).map(([value, info]) => (
          <Option key={value} value={value}>
            <Space>
              {info.icon}
              <span>{info.label}</span>
            </Space>
          </Option>
        ))}
      </Select>
      
      <Tooltip
        title={
          <div>
            <p><strong>{currentInfo.label}</strong></p>
            <p>{currentInfo.description}</p>
            <div style={{ marginTop: 8 }}>
              <strong>Pros:</strong>
              <ul style={{ margin: '4px 0', paddingLeft: 20 }}>
                {currentInfo.pros.map((pro, i) => (
                  <li key={i}>{pro}</li>
                ))}
              </ul>
            </div>
            <div>
              <strong>Cons:</strong>
              <ul style={{ margin: '4px 0', paddingLeft: 20 }}>
                {currentInfo.cons.map((con, i) => (
                  <li key={i}>{con}</li>
                ))}
              </ul>
            </div>
          </div>
        }
      >
        <InfoCircleOutlined style={{ cursor: 'help' }} />
      </Tooltip>
      
      <Tag color={currentInfo.color}>{currentInfo.label}</Tag>
    </Space>
  );
};

// Usage in LangGraphViewPage.tsx:
/*
import { TransportSelector } from '../components/TransportSelector';

// In your component:
const { 
  connectAndExecute, 
  currentTransport, 
  setTransport,
  // ... other properties 
} = useLangGraphRunner();

// In the UI:
<TransportSelector
  currentTransport={currentTransport}
  onTransportChange={setTransport}
  disabled={executionStatus === 'running' || executionStatus === 'connecting'}
/>
*/

File: src/langgraph/hooks/useLangGraphStreamRunner.ts
// src/langgraph/hooks/useLangGraphStreamRunner.ts
import { useState, useCallback, useRef, useEffect, SetStateAction } from 'react';
import {
  LangGraphExecutionEvent,
  ExecuteGraphRequestFE,
  GraphErrorEventFE,
} from '../types/langgraph';
import { LangGraphStreamService } from '../services/langGraphStreamService';

export type GraphExecutionStatus =
  | 'idle'
  | 'connecting'
  | 'running'
  | 'completed'
  | 'error';

export interface ExecutionState {
  activeNodeIds: Set<string>;
  completedNodeIds: Set<string>;
  errorNodeIds: Set<string>;
  traversedEdgeIds: Set<string>;
  lastInputByNode: Record<string, any>;
  lastOutputByNode: Record<string, any>;
}

const initialExecutionState: ExecutionState = {
  activeNodeIds: new Set(),
  completedNodeIds: new Set(),
  errorNodeIds: new Set(),
  traversedEdgeIds: new Set(),
  lastInputByNode: {},
  lastOutputByNode: {},
};

export interface UseLangGraphStreamRunnerResult {
  connectAndExecute: (
    graphId: string,
    executionRequest: ExecuteGraphRequestFE
  ) => Promise<void>;
  disconnect: () => void;
  executionEvents: LangGraphExecutionEvent[];
  currentExecutionId: string | null;
  status: GraphExecutionStatus;
  error: string | null;
  graphError: GraphErrorEventFE | null;
  currentGraphState: ExecutionState;
  isStreaming: boolean;
}

export const useLangGraphStreamRunner = (
  baseUrl?: string
): UseLangGraphStreamRunnerResult => {
  const [streamService, setStreamService] = useState<LangGraphStreamService | null>(null);
  const [executionEvents, setExecutionEvents] = useState<LangGraphExecutionEvent[]>([]);
  const [currentExecutionId, setCurrentExecutionId] = useState<string | null>(null);
  const [status, setStatus] = useState<GraphExecutionStatus>('idle');
  const [error, setError] = useState<string | null>(null);
  const [graphError, setGraphError] = useState<GraphErrorEventFE | null>(null);
  const [currentGraphState, setCurrentGraphState] = useState<ExecutionState>(initialExecutionState);
  const [isStreaming, setIsStreaming] = useState(false);

  const mountedRef = useRef(true);

  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
      disconnect();
    };
  }, []);

  const handleNewEvent = useCallback((event: LangGraphExecutionEvent) => {
    if (!mountedRef.current) return;

    console.log(`[useLangGraphStreamRunner] Received event: ${event.eventType}`, event);
    setExecutionEvents((prevEvents) => [...prevEvents, event]);

    switch (event.eventType) {
      case 'graph_execution_start':
        setStatus('running');
        setCurrentExecutionId(event.executionId);
        setCurrentGraphState(initialExecutionState);
        break;

      case 'node_start':
        setCurrentGraphState((prevState) => {
          const newState = {
            ...prevState,
            activeNodeIds: new Set(prevState.activeNodeIds),
            completedNodeIds: new Set(prevState.completedNodeIds),
            errorNodeIds: new Set(prevState.errorNodeIds),
            lastInputByNode: { ...prevState.lastInputByNode },
          };
          
          newState.activeNodeIds.add(event.nodeId);
          newState.completedNodeIds.delete(event.nodeId);
          newState.errorNodeIds.delete(event.nodeId);
          newState.lastInputByNode[event.nodeId] = event.inputData;
          
          return newState;
        });
        break;

      case 'node_end':
        setCurrentGraphState((prevState) => {
          const newState = {
            ...prevState,
            activeNodeIds: new Set(prevState.activeNodeIds),
            completedNodeIds: new Set(prevState.completedNodeIds),
            errorNodeIds: new Set(prevState.errorNodeIds),
            lastOutputByNode: { ...prevState.lastOutputByNode },
          };
          
          newState.activeNodeIds.delete(event.nodeId);
          
          if (event.status === 'success') {
            newState.completedNodeIds.add(event.nodeId);
          } else {
            newState.errorNodeIds.add(event.nodeId);
          }
          
          newState.lastOutputByNode[event.nodeId] = event.outputData;
          
          return newState;
        });
        break;

      case 'edge_taken':
        setCurrentGraphState((prevState) => {
          const newState = {
            ...prevState,
            traversedEdgeIds: new Set(prevState.traversedEdgeIds),
          };
          
          const edgeId = `${event.sourceNodeId}__${event.targetNodeId}${
            event.edgeLabel ? `__${event.edgeLabel}` : ''
          }`;
          newState.traversedEdgeIds.add(edgeId);
          
          return newState;
        });
        break;

      case 'graph_execution_end':
        setStatus('completed');
        setIsStreaming(false);
        break;

      case 'graph_error':
        setGraphError(event as GraphErrorEventFE);
        setStatus('error');
        setIsStreaming(false);
        break;
    }
  }, []);

  const connectAndExecute = useCallback(async (
    graphId: string,
    executionRequest: ExecuteGraphRequestFE
  ) => {
    if (streamService) {
      streamService.close();
    }

    if (!mountedRef.current) return;

    setExecutionEvents([]);
    setCurrentGraphState(initialExecutionState);
    setStatus('connecting');
    setError(null);
    setGraphError(null);
    setIsStreaming(true);

    const newStreamService = new LangGraphStreamService({
      onOpen: () => {
        if (!mountedRef.current) return;
        console.log('[useLangGraphStreamRunner] Stream opened');
        setStatus('running');
      },
      onMessage: handleNewEvent,
      onError: (err: { message: SetStateAction<string | null>; }) => {
        if (!mountedRef.current) return;
        console.error('[useLangGraphStreamRunner] Stream Error:', err);
        setError(err.message);
        setStatus('error');
        setIsStreaming(false);
      },
      onClose: () => {
        if (!mountedRef.current) return;
        console.log('[useLangGraphStreamRunner] Stream closed');
        setIsStreaming(false);
        if (status === 'running' || status === 'connecting') {
          setStatus('completed');
        }
      },
      baseUrl,
    });

    try {
      const executionId = await newStreamService.connect(graphId, executionRequest);
      if (mountedRef.current) {
        setCurrentExecutionId(executionId);
        setStreamService(newStreamService);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('[useLangGraphStreamRunner] Failed to connect:', err);
        setError(err instanceof Error ? err.message : 'Failed to connect');
        setStatus('error');
        setIsStreaming(false);
      }
    }
  }, [streamService, handleNewEvent, baseUrl, status]);

  const disconnect = useCallback(() => {
    if (streamService) {
      streamService.close();
      setStreamService(null);
      setIsStreaming(false);
      if (status === 'running' || status === 'connecting') {
        setStatus('completed');
      }
    }
  }, [streamService, status]);

  return {
    connectAndExecute,
    disconnect,
    executionEvents,
    currentExecutionId,
    status,
    error,
    graphError,
    currentGraphState,
    isStreaming,
  };
};

File: src/langgraph/components/CustomGraphEdge.tsx
// src/langgraph/components/CustomGraphEdge.tsx
import React, { memo } from 'react';
import {
  EdgeProps,
  getSmoothStepPath, // Or use getBezierPath, getStraightPath
  EdgeLabelRenderer, // For custom label positioning
  BaseEdge,          // Renders the path and markers
} from 'reactflow';

import { ReactFlowEdgeData } from '../types/langgraph'; // Your custom edge data type

const CustomGraphEdge: React.FC<EdgeProps<ReactFlowEdgeData>> = ({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  data, // Contains { label?: string, status?: 'idle' | 'traversed' }
  markerEnd,
}) => {
  const { label, status } = data || {};

  // Use getSmoothStepPath for a nice curved edge.
  // You can adjust parameters like borderRadius.
  const [edgePath, labelX, labelY] = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    borderRadius: 10, // Adjust for more or less curve at corners
  });

  // --- Dynamic Styling based on status ---
  const edgeStyle: React.CSSProperties = {
    ...style, // Apply any base styles passed as props
    strokeWidth: status === 'traversed' ? 2.5 : 1.5,
    stroke: status === 'traversed' ? '#10B981' : '#a3a3a3', // Emerald-500 for traversed, neutral-400 for idle
    transition: 'stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out',
  };

  // --- Animated SVG Dash for Traversed Edges ---
  // This creates a "marching ants" effect.
  // Adjust dasharray and animation speed as needed.
  const animationStyle = status === 'traversed' ? {
    strokeDasharray: '5, 5',
    animation: 'dashdraw 0.5s linear infinite',
  } : {};

  return (
    <>
      <BaseEdge path={edgePath} markerEnd={markerEnd} style={{...edgeStyle, ...animationStyle}} />
      {label && (
        <EdgeLabelRenderer>
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
              background: status === 'traversed' ? '#d1fae5' : '#f3f4f6', // emerald-100 or gray-100
              padding: '2px 6px',
              borderRadius: '4px',
              fontSize: 10,
              fontWeight: 500,
              color: status === 'traversed' ? '#059669' : '#4b5563', // emerald-700 or gray-600
              pointerEvents: 'all', // Allow interaction with the label if needed
              border: status === 'traversed' ? '1px solid #6ee7b7' : '1px solid #e5e7eb', // emerald-300 or gray-200
            }}
            className="nodrag nopan" // Prevent dragging canvas when interacting with label
          >
            {label}
          </div>
        </EdgeLabelRenderer>
      )}
      {/* CSS for animation (can be put in a global CSS file or a style tag) */}
      <style>{`
        @keyframes dashdraw {
          to {
            stroke-dashoffset: -10;
          }
        }
      `}</style>
    </>
  );
};

export default memo(CustomGraphEdge);

File: src/langgraph/components/LangGraphCanvas.tsx
// src/langgraph/components/LangGraphCanvas.tsx
import React, { useMemo } from 'react';
import ReactFlow, {
  Node,
  Edge,
  Controls,
  Background,
  MiniMap,
  ReactFlowProvider, // Good practice to wrap if using hooks like useReactFlow
  BackgroundVariant,
} from 'reactflow';
import 'reactflow/dist/style.css'; // Ensure styles are imported

import { ReactFlowNodeData, ReactFlowEdgeData } from '../types/langgraph';
import CustomGraphNode from './CustomGraphNode'; // Custom node component
// import CustomGraphEdge from './CustomGraphEdge'; // Placeholder for custom edge

// --- Optional: Define Custom Node and Edge Types for React Flow ---
const nodeTypes = {
  customGraphNode: CustomGraphNode, // Maps 'customGraphNode' type from adapter to this component
  // You can add more types: 'llmNodeType': LlmNodeComponent, 'toolNodeType': ToolNodeComponent etc.
};

// const edgeTypes = {
//   customGraphEdge: CustomGraphEdge, // Maps 'customGraphEdge' type from adapter
// };
// --- End Optional Custom Types ---

interface LangGraphCanvasProps {
  nodes: Node<ReactFlowNodeData, string | undefined>[]; // Nodes from useReactFlowGraphAdapter
  edges: Edge<ReactFlowEdgeData>[];                   // Edges from useReactFlowGraphAdapter
  onNodeClick?: (event: React.MouseEvent, node: Node<ReactFlowNodeData>) => void;
  onEdgeClick?: (event: React.MouseEvent, edge: Edge<ReactFlowEdgeData>) => void;
  // Add other React Flow props you might need, like onConnect, onNodesChange, onEdgesChange if editable
  isLoading?: boolean; // To show a loading overlay or message
}

const LangGraphCanvas: React.FC<LangGraphCanvasProps> = ({
  nodes,
  edges,
  onNodeClick,
  onEdgeClick,
  isLoading = false,
}) => {  // Memoize node and edge types if they were defined
  const memoizedNodeTypes = useMemo(() => nodeTypes, []);
  // const memoizedEdgeTypes = useMemo(() => edgeTypes, []);

  if (isLoading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
        <p>Loading graph data...</p> {/* Or use an Ant Design Spin component */}
      </div>
    );
  }

  return (
    // It's good practice to wrap ReactFlow with ReactFlowProvider if you plan to use
    // React Flow hooks like useNodesState, useEdgesState, useReactFlow within this component
    // or its children, though for a display-only canvas it might not be strictly necessary
    // if nodes/edges are fully managed by the parent hook.
    <ReactFlowProvider>      <ReactFlow
        nodes={nodes}
        edges={edges}
        nodeTypes={memoizedNodeTypes} // Custom nodes
        // edgeTypes={memoizedEdgeTypes} // Uncomment if using custom edges
        onNodeClick={onNodeClick}
        onEdgeClick={onEdgeClick}
        fitView // Automatically fits the graph into the view on initial render or when nodes/edges change
        fitViewOptions={{ padding: 0.1, duration: 300 }}
        nodesDraggable={true} // Allow dragging nodes
        nodesConnectable={false} // Disable manual connection creation for display
        elementsSelectable={true} // Allow selecting nodes/edges
        attributionPosition="bottom-left" // Default position for React Flow attribution
        proOptions={{ hideAttribution: false }} // Shows "React Flow" attribution; set to true to hide
        // style={{ background: '#f8f9fa' }} // Optional: background color for the canvas
      >
        <Controls
          showInteractive={false} // Simplifies controls if graph is not interactive for connections
        />
        <MiniMap
          nodeStrokeColor={(n: Node): string => { // Type annotation for n
            if (n.type === 'input') return '#0041d0';
            if (n.type === 'output') return '#ff0072';
            if (n.data?.status === 'running') return '#fbbf24'; // amber-400
            if (n.data?.status === 'success') return '#34d399'; // emerald-400
            if (n.data?.status === 'error') return '#f87171'; // red-400
            return '#9ca3af'; // gray-400
          }}
          nodeColor={(n: Node): string => { // Type annotation for n
            if (n.data?.status === 'running') return '#fef3c7'; // amber-100
            if (n.data?.status === 'success') return '#d1fae5'; // emerald-100
            if (n.data?.status === 'error') return '#fee2e2'; // red-100
            return '#ffffff';
          }}
          nodeBorderRadius={2}
          pannable={true}
          zoomable={true}
        />
        <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
      </ReactFlow>
    </ReactFlowProvider>
  );
};

export default LangGraphCanvas;

File: src/langgraph/pages/LangGraphCreatePage.tsx
// src/langgraph/pages/LangGraphCreatePage.tsx
import React, { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button, Card, Input, Typography, Alert, Modal, Row, Col, Form } from 'antd';
import { SaveOutlined, CodeOutlined, ArrowLeftOutlined, InfoCircleOutlined } from '@ant-design/icons';

import { useAuth } from '../../context/AuthContext'; // Adjust path
import { useLangGraphDefinitions } from '../hooks/useLangGraphDefinitions';
import { CreateGraphRequestFE } from '../types/langgraph';
// You might want a JSON schema or examples to guide the user
// import exampleGraphJsonSchema from './exampleGraphSchema.json'; // Example

const { Title, Paragraph, Text } = Typography;
const { TextArea } = Input;

// Basic example JSON structure to guide the user
const EXAMPLE_GRAPH_JSON = `{
  "name": "My New Workflow",
  "description": "A brief description of what this workflow does.",
  "stateSchemaName": "BasicAgentState",
  "entryPointNodeId": "start_node",
  "nodes": [
    {
      "id": "start_node",
      "type": "simple_modifier",
      "config": { "message_prefix": "Entry: " },
      "uiPosition": { "x": 100, "y": 100 }
    }, 
    {
      "id": "next_step",
      "type": "simple_modifier",
      "config": { "message_prefix": "Next: " },
      "uiPosition": { "x": 300, "y": 100 }
    }
  ],
  "edges": [
    { "id": "e_start_to_next", "source": "start_node", "target": "next_step", "label": "Proceed" }
  ],
  "conditionalEdges": [],
  "terminalNodeIds": ["next_step"]
}`;

const LangGraphCreatePage: React.FC = () => {
  const navigate = useNavigate();  const { apiClient, checkPermission } = useAuth();
  const { createGraphDefinition, isLoading, error } = useLangGraphDefinitions(apiClient, '/v1/lg-vis');

  const [graphJson, setGraphJson] = useState<string>(EXAMPLE_GRAPH_JSON);
  const [formError, setFormError] = useState<string | null>(null);
  const [bordered] = useState(false); // Default to false to match previous behavior

  // Permission check
  const canCreate = checkPermission('langgraph:create'); // Example permission

  const handleSubmit = useCallback(async () => {
    if (!canCreate) {
      Modal.error({ title: 'Permission Denied', content: 'You do not have permission to create graph definitions.' });
      return;
    }

    setFormError(null);
    let parsedData: Partial<CreateGraphRequestFE>;

    try {
      parsedData = JSON.parse(graphJson);
      // Basic validation (more thorough validation should happen on the backend via Pydantic)
      if (!parsedData.name || !parsedData.stateSchemaName || !parsedData.entryPointNodeId || !parsedData.nodes) {
        setFormError('Required fields missing: name, stateSchemaName, entryPointNodeId, and nodes are mandatory.');
        return;
      }
    } catch (e) {
      setFormError('Invalid JSON format. Please check the syntax.');
      return;
    }

    const newGraph = await createGraphDefinition(parsedData as CreateGraphRequestFE);

    if (newGraph && newGraph.id) {
      Modal.success({
        title: 'Graph Created Successfully!',
        content: `Graph "${newGraph.name}" has been created.`,
        onOk: () => navigate(`/langgraph/view/${newGraph.id}`),
      });
    } else {
      // Error is handled by the hook and displayed via the 'error' state variable
      // but we can also set a form-specific error if the hook's error isn't user-friendly enough
      setFormError(error || 'Failed to create graph. Please check the details and try again.');
    }
  }, [graphJson, createGraphDefinition, navigate, error, canCreate]);

  if (!canCreate) {
    return (
         <div className="page-container">
            <Alert
                message="Permission Denied"
                description="You do not have permission to create new graph definitions. Please contact your administrator."
                type="error"
                showIcon
            />
            <Button icon={<ArrowLeftOutlined />} onClick={() => navigate('/langgraph')} style={{ marginTop: 16 }}>
                Back to Graph List
            </Button>
        </div>
    );
  }

  return (
    <div className="page-container" style={{ maxWidth: '1000px', margin: '0 auto' }}>
      <Card
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Title level={2} style={{ margin: 0 }}>
              <CodeOutlined style={{ marginRight: '12px' }} />
              Create New Agentic Workflow
            </Title>
            <Button icon={<ArrowLeftOutlined />} onClick={() => navigate('/langgraph')}>
                Back to List
            </Button>          </div>
        }
        variant={bordered ? "outlined" : "borderless"}
      >
        <Paragraph type="secondary">
          Define your LangGraph workflow by providing its structure in JSON format.
          Ensure the node types and state schema name correspond to definitions known by the backend.
          Refer to the documentation or examples for the correct schema.
        </Paragraph>

        <Form layout="vertical" onFinish={handleSubmit}>
          <Form.Item
            label="Graph Definition (JSON)"
            help={formError || (error && `API Error: ${error}`) || "Paste your graph definition JSON here."}
            validateStatus={formError || error ? 'error' : ''}
            required
          >
            <TextArea
              rows={20}
              value={graphJson}
              onChange={(e) => setGraphJson(e.target.value)}
              placeholder={EXAMPLE_GRAPH_JSON}
              style={{ fontFamily: 'monospace', fontSize: '13px' }}
              disabled={isLoading}
            />
          </Form.Item>

          <Row justify="end">
            <Col>
              <Button
                type="primary"
                htmlType="submit"
                icon={<SaveOutlined />}
                loading={isLoading}
                disabled={!graphJson.trim()}
              >
                Create Graph
              </Button>
            </Col>
          </Row>
        </Form>

        <details style={{ marginTop: '24px', cursor: 'pointer', border: '1px solid #e8e8e8', padding: '12px', borderRadius: '4px' }}>
            <summary style={{ fontWeight: '500', fontSize: '0.9em' }}>
                <InfoCircleOutlined style={{marginRight: '6px'}} />
                Example JSON Structure & Key Fields
            </summary>
            <Paragraph style={{marginTop: '8px', fontSize: '0.85em'}}>
                <Text strong>Required fields:</Text>
                <ul>
                    <li><Text code>name</Text>: (string) Human-readable name.</li>
                    <li><Text code>stateSchemaName</Text>: (string) Name of a Pydantic state model registered in the backend (e.g., "BasicAgentState", "DocumentProcessingState").</li>
                    <li><Text code>entryPointNodeId</Text>: (string) The ID of one of your defined nodes.</li>
                    <li><Text code>nodes</Text>: (array) List of node definitions. Each node needs:
                        <ul>
                            <li><Text code>id</Text>: (string) Unique ID for the node.</li>
                            <li><Text code>type</Text>: (string) Type string matching a key in backend's `NODE_IMPLEMENTATIONS` (e.g., "llm_node", "simple_modifier").</li>
                            <li><Text code>config</Text>: (object, optional) Configuration for the node type.</li>
                            <li><Text code>uiPosition</Text>: (object, optional) <Text code>{`{ "x": number, "y": number }`}</Text> for initial UI placement.</li>
                        </ul>
                    </li>
                </ul>
                <Text strong>Optional but important fields:</Text>
                <ul>
                    <li><Text code>description</Text>: (string) What the graph does.</li>
                    <li><Text code>edges</Text>: (array) Standard edges. Each edge needs:
                        <ul>
                             <li><Text code>id</Text>: (string) Unique ID for the edge.</li>
                             <li><Text code>source</Text>: (string) Source node ID.</li>
                             <li><Text code>target</Text>: (string) Target node ID.</li>
                             <li><Text code>label</Text>: (string, optional) Edge label.</li>
                        </ul>
                    </li>
                    <li><Text code>conditionalEdges</Text>: (array) For branching logic. Each entry needs:
                        <ul>
                            <li><Text code>sourceNodeId</Text>: (string) The node whose config specifies a `router_function_name`.</li>
                            <li><Text code>mappings</Text>: (array) Each mapping needs:
                                <ul>
                                    <li><Text code>conditionName</Text>: (string) Key returned by the router function.</li>
                                    <li><Text code>targetNodeId</Text>: (string) Target node ID for this condition.</li>
                                </ul>
                            </li>
                        </ul>
                        (Note: The router function itself is specified in the source node's `config` via `router_function_name`.)
                    </li>
                     <li><Text code>terminalNodeIds</Text>: (array of strings, optional) Node IDs that should implicitly connect to END.</li>
                </ul>
            </Paragraph>
        </details>
      </Card>
    </div>
  );
};

export default LangGraphCreatePage;

File: src/langgraph/components/CustomGraphNode.tsx
// src/langgraph/components/CustomGraphNode.tsx
import React, { memo } from 'react';
import { Handle, Position, NodeProps, NodeResizer } from 'reactflow';
import {
  PlayCircleOutlined, // Example for generic runnable
  ApiOutlined,        // Example for LLM/API calls
  ToolOutlined,       // Example for tools
  ForkOutlined,       // Example for routers/conditional
  CheckCircleFilled,  // Example for success
  CloseCircleFilled,  // Example for error
  LoadingOutlined,    // Example for running
  SettingOutlined,    // Example for config/data nodes
} from '@ant-design/icons'; // Using Ant Design icons for consistency

import { ReactFlowNodeData } from '../types/langgraph'; // Your custom node data type

// Define a type for node status for clarity
type NodeDisplayStatus = 'idle' | 'running' | 'success' | 'error' | 'active';

// Helper to map node type to an icon (customize as needed)
const getNodeIcon = (nodeType?: string, status?: NodeDisplayStatus) => {
  if (status === 'running') return <LoadingOutlined spin style={{ fontSize: '16px' }} />;
  if (status === 'success') return <CheckCircleFilled style={{ fontSize: '16px', color: '#34d399' }} />; // emerald-400
  if (status === 'error') return <CloseCircleFilled style={{ fontSize: '16px', color: '#f87171' }} />;   // red-400

  switch (nodeType?.toLowerCase()) {
    case 'llm_node':
    case 'apicallnode':
      return <ApiOutlined style={{ fontSize: '16px' }} />;
    case 'tool_node':
    case 'toolnode':
      return <ToolOutlined style={{ fontSize: '16px' }} />;
    case 'router_node':
    case 'conditional_edge_router':
    case 'conditionnode':
      return <ForkOutlined style={{ fontSize: '16px' }} />;
    case 'entry_point':
    case 'entrypointnode':
      return <PlayCircleOutlined style={{ fontSize: '16px', color: '#3b82f6' }} />; // blue-500
    case 'data_node': // Example type for nodes that just hold/transform data
      return <SettingOutlined style={{ fontSize: '16px' }} />;
    default:
      return <PlayCircleOutlined style={{ fontSize: '16px' }} />; // Default icon
  }
};

// Define styles based on status
const getStatusStyles = (status?: NodeDisplayStatus): React.CSSProperties => {
  switch (status) {
    case 'running':
      return {
        borderColor: '#fbbf24', // amber-400
        backgroundColor: '#fef3c7', // amber-100
        boxShadow: '0 0 8px rgba(251, 191, 36, 0.5)',
      };
    case 'success':
      return {
        borderColor: '#34d399', // emerald-400
        backgroundColor: '#d1fae5', // emerald-100
      };
    case 'error':
      return {
        borderColor: '#f87171', // red-400
        backgroundColor: '#fee2e2', // red-100
      };
    case 'active': // When node is selected
      return {
        borderColor: '#60a5fa', // blue-400
        boxShadow: '0 0 10px rgba(96, 165, 250, 0.6)',
      };
    case 'idle':
    default:
      return {
        borderColor: '#d1d5db', // gray-300
        backgroundColor: '#ffffff', // white
      };
  }
};

const CustomGraphNode: React.FC<NodeProps<ReactFlowNodeData>> = ({
  data,
  isConnectable, // Provided by React Flow
  selected,      // Provided by React Flow
  // sourcePosition = Position.Bottom, // Default can be overridden by node instance
  // targetPosition = Position.Top,   // Default can be overridden by node instance
}) => {
  const { label, type: nodeType, status, config } = data; // Status comes from useLangGraphRunner via useReactFlowGraphAdapter

  const displayStatus = selected && status === 'idle' ? 'active' : status;
  const statusStyles = getStatusStyles(displayStatus);
  const icon = getNodeIcon(nodeType, displayStatus);

  // Base style for the node
  const nodeStyle: React.CSSProperties = {
    border: '2px solid',
    borderRadius: '8px',
    padding: '10px 15px',
    minWidth: '150px', // Ensure a minimum width
    // maxWidth: '250px', // Optional: constraint width
    textAlign: 'center',
    fontSize: '12px',
    transition: 'all 0.2s ease-out',
    ...statusStyles, // Apply status-specific styles
  };

  return (
    <div style={nodeStyle}>
      {/* NodeResizer (optional) makes node user-resizable - install @reactflow/node-resizer if used */}
      {/* <NodeResizer minWidth={100} minHeight={40} isVisible={selected} /> */}

      {/* Handles for incoming connections (targets) */}
      {/* You can have multiple handles and position them differently */}
      <Handle
        type="target"
        position={Position.Top}
        id="target-top"
        isConnectable={isConnectable}
        style={{ background: '#9ca3af' }} // gray-400
      />
      {/* <Handle type="target" position={Position.Left} id="target-left" isConnectable={isConnectable} /> */}

      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', marginBottom: '5px' }}>
        {icon && <span style={{ marginRight: '8px' }}>{icon}</span>}
        <strong style={{ color: '#1f2937' /* gray-800 */, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
          {label}
        </strong>
      </div>

      {nodeType && (
        <div style={{ fontSize: '10px', color: '#6b7280' /* gray-500 */, marginBottom: '3px', textTransform: 'uppercase' }}>
          {nodeType.replace(/_/g, ' ')}
        </div>
      )}

      {/* Example: Displaying a piece of config if available */}
      {config?.action && typeof config.action === 'string' && (
        <div style={{ fontSize: '10px', color: '#4b5563' /* gray-600 */, fontStyle: 'italic' }}>
          Action: {config.action}
        </div>
      )}
      {/* You can add more details from `data` or `config` here */}

      {/* Handles for outgoing connections (sources) */}
      <Handle
        type="source"
        position={Position.Bottom}
        id="source-bottom"
        isConnectable={isConnectable}
        style={{ background: '#9ca3af' }} // gray-400
      />
      {/* <Handle type="source" position={Position.Right} id="source-right" isConnectable={isConnectable} /> */}
    </div>
  );
};

export default memo(CustomGraphNode); // Use memo for performance optimization

File: src/langgraph/pages/LangGraphEditPage.tsx
// src/langgraph/pages/LangGraphEditPage.tsx
import React, { useState, useEffect, useCallback, useRef } from 'react'; 
import { useParams, useNavigate } from 'react-router-dom';
import { Button, Card, Typography, Spin, Alert, Modal, Row, Col, Form } from 'antd';
import { SaveOutlined, CodeOutlined, ArrowLeftOutlined } from '@ant-design/icons'; 
import Editor, { Monaco } from '@monaco-editor/react';

import { useAuth } from '../../context/AuthContext';
import { useLangGraphDefinitions } from '../hooks/useLangGraphDefinitions';
import { UpdateGraphRequestFE, FrontendGraphDef } from '../types/langgraph';

const { Title, Paragraph } = Typography;
// const { TextArea } = Input; // No longer using Ant Design TextArea

const LangGraphEditPage: React.FC = () => {
  const { graphId } = useParams<{ graphId: string }>();
  const navigate = useNavigate();
  const { apiClient, checkPermission } = useAuth();
  const { getGraphDefinition, updateGraphDefinition, isLoading, error } = useLangGraphDefinitions(apiClient, '/v1/lg-vis');

  const [graphJson, setGraphJson] = useState<string>(''); // Store as string for Monaco
  const [initialGraphName, setInitialGraphName] = useState<string>('');
  const [formError, setFormError] = useState<string | null>(null);
  const [isFetching, setIsFetching] = useState<boolean>(false);
  const editorRef = useRef<any>(null); // Ref for Monaco editor instance

  const canEdit = checkPermission('langgraph:edit');

  useEffect(() => {
    if (graphId && canEdit) {
      setIsFetching(true);
      getGraphDefinition(graphId)
        .then(definition => {
          if (definition) {
            setInitialGraphName(definition.name);
            const editableDefinition: Partial<FrontendGraphDef> = { ...definition };
            delete editableDefinition.id;
            delete editableDefinition.createdAt;
            delete editableDefinition.updatedAt;
            delete editableDefinition.version;
            setGraphJson(JSON.stringify(editableDefinition, null, 2)); // Pretty print for editor
          } else {
            setFormError(`Graph definition with ID '${graphId}' not found.`);
            setGraphJson(''); // Clear JSON if not found
          }
        })
        .catch(fetchError => {
          setFormError(fetchError.message || `Failed to load graph definition for ID '${graphId}'.`);
          setGraphJson(''); // Clear JSON on error
        })
        .finally(() => setIsFetching(false));
    } else if (!canEdit) {
        setFormError("You do not have permission to edit this graph.");
        setGraphJson('');
    }
  }, [graphId, getGraphDefinition, canEdit]);
  const handleEditorDidMount = (editor: any, _monaco: Monaco) => {
    editorRef.current = editor;
    // You can configure the editor here, e.g., monaco.languages.json.jsonDefaults.setDiagnosticsOptions
    console.log('Monaco Editor mounted:', editor);
  };

  const handleEditorChange = (value: string | undefined) => {
    setGraphJson(value || '');
    if (formError) setFormError(null); // Clear parse error if user starts typing
  };

  const handleSubmit = useCallback(async () => {
    if (!canEdit) {
      Modal.error({ title: 'Permission Denied', content: 'You do not have permission to edit graph definitions.' });
      return;
    }
    if (!graphId) {
        setFormError('Graph ID is missing.');
        return;
    }

    setFormError(null);
    let parsedData: Partial<UpdateGraphRequestFE>;

    try {
      parsedData = JSON.parse(graphJson); // graphJson is directly from Monaco editor
      if (!parsedData.name || !parsedData.stateSchemaName || !parsedData.entryPointNodeId || !parsedData.nodes) {
        setFormError('Required fields missing: name, stateSchemaName, entryPointNodeId, and nodes are mandatory.');
        return;
      }
    } catch (e: any) {
      setFormError(`Invalid JSON format: ${e.message}. Please check the syntax.`);
      return;
    }

    const updatedGraph = await updateGraphDefinition(graphId, parsedData as UpdateGraphRequestFE);

    if (updatedGraph && updatedGraph.id) {
      Modal.success({
        title: 'Graph Updated Successfully!',
        content: `Graph "${updatedGraph.name}" has been updated.`,
        onOk: () => navigate(`/langgraph/view/${updatedGraph.id}`),
      });
    } else {
      setFormError(error || 'Failed to update graph. Please check the details and try again.');
    }
  }, [graphJson, updateGraphDefinition, navigate, error, graphId, canEdit]);


  if (!canEdit && !isFetching) {
     return (
         <div className="page-container">
            <Alert
                message="Permission Denied"
                description={formError || "You do not have permission to edit graph definitions. Please contact your administrator."}
                type="error"
                showIcon
            />
            <Button icon={<ArrowLeftOutlined />} onClick={() => navigate('/langgraph')} style={{ marginTop: 16 }}>
                Back to Graph List
            </Button>
        </div>
    );
  }

  if (isFetching && !graphJson) { // Show spinner only if no content is loaded yet
    return (
      <div className="page-container flex justify-center items-center" style={{ height: 'calc(100vh - 150px)' }}>
        <Spin size="large" tip={`Loading graph '${graphId}' for editing...`} />
      </div>
    );
  }

  if (formError && !isFetching && !graphJson) { 
    return (
      <div className="page-container">
        <Alert
          message="Error Loading Graph"
          description={formError}
          type="error"
          showIcon
        />
        <Button icon={<ArrowLeftOutlined />} onClick={() => navigate('/langgraph')} style={{ marginTop: 16 }}>
            Back to Graph List
        </Button>
      </div>
    );
  }

  return (
    <div className="page-container" style={{ maxWidth: '1000px', margin: '0 auto' }}>
      <Card
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Title level={2} style={{ margin: 0 }}>
              <CodeOutlined style={{ marginRight: '12px' }} />
              Edit Workflow: {initialGraphName || graphId}
            </Title>
            <Button icon={<ArrowLeftOutlined />} onClick={() => navigate(`/langgraph/view/${graphId}`)}>
                Back to View
            </Button>          </div>
        }
        variant="borderless"
      >
        <Paragraph type="secondary">
          Modify the LangGraph workflow definition in JSON format.
          The ID, creation date, and version are managed by the system.
        </Paragraph>

        {/* Ant Design Form is used for layout and button, not for direct field control of Monaco */}
        <Form layout="vertical" onFinish={handleSubmit}>
          <Form.Item
            label="Graph Definition (JSON)"
            help={formError || (error && `API Error: ${error}`)} // Display general API errors or JSON parse errors
            validateStatus={formError || error ? 'error' : ''}
            required
            style={{ marginBottom: '16px' }} // Add some bottom margin
          >
            {/* Monaco Editor Integration */}
            <div style={{ border: '1px solid #d9d9d9', borderRadius: '2px', height: '60vh', minHeight: '400px' }}>
              {isFetching && graphJson === '' ? ( // Show placeholder or spinner while fetching
                 <div className="flex justify-center items-center h-full">
                    <Spin tip="Loading definition..." />
                 </div>
              ) : (
                <Editor
                  height="100%" // Use 100% of the div's height
                  language="json"
                  value={graphJson}
                  onChange={handleEditorChange}
                  onMount={handleEditorDidMount}
                  theme="vs-dark" // Or "light"
                  options={{
                    selectOnLineNumbers: true,
                    minimap: { enabled: true },
                    automaticLayout: true, // Important for responsiveness
                    wordWrap: "on", // Enable word wrapping
                  }}
                />
              )}
            </div>
          </Form.Item>

          <Row justify="end">
            <Col>
              <Button
                type="primary"
                htmlType="submit"
                icon={<SaveOutlined />}
                loading={isLoading} 
                disabled={!graphJson.trim() || isFetching || !!formError} // Disable if JSON is empty, fetching, or has parse error
              >
                Save Changes
              </Button>
            </Col>
          </Row>
        </Form>
      </Card>
    </div>
  );
};

export default LangGraphEditPage;

File: src/pages/TestPage.tsx
import React from 'react'; // Remove unused useState and related hooks if not needed elsewhere
import { ClassificationForm } from '../components/ClassificationForm';
import { ApiClient } from '../api/types';
// Remove useAuth if checkPermission is no longer needed here
// import { useAuth } from '../context/AuthContext';

interface TestPageProps {
  apiClient: ApiClient;
}

const TestPage: React.FC<TestPageProps> = ({ apiClient }) => {
  // Remove state and handlers related to the deleted button
  // const { checkPermission } = useAuth();
  // const [isLoading, setIsLoading] = useState(false);
  // const [description, setDescription] = useState('');

  // const handleSubmit = () => { ... }; // This handler is no longer needed

  return (
    <div className="page-container">
      <div className="mb-6">
        <h1 className="text-2xl font-semibold text-secondary-900">Test Classification</h1>
        <p className="text-secondary-600">
          Use this tool to test classification of individual items
        </p>
      </div>

      {/* The ClassificationForm component already contains the necessary inputs and its own submit button */}
      <ClassificationForm apiClient={apiClient} />

      {/* The redundant button has been removed from here */}

    </div>
  );
};

export default TestPage;

File: src/langgraph/pages/LangGraphListPage.tsx
// src/langgraph/pages/LangGraphListPage.tsx
import React, { useEffect, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Adjust path as needed
import { useLangGraphDefinitions } from '../hooks/useLangGraphDefinitions';
import { Button, List, Card, Typography, Spin, Alert, Tag, Empty, Tooltip, Switch } from 'antd';
import { PlusOutlined, EyeOutlined, EditOutlined, DeleteOutlined, ShareAltOutlined } from '@ant-design/icons';
import { formatDate } from '../../utils/dateFormat'; // Your existing date formatter

const { Title, Text, Paragraph } = Typography;

const LangGraphListPage: React.FC = () => {
  const { apiClient, checkPermission } = useAuth(); // Get apiClient and permission checker
  const {
    graphDefinitions,
    isLoading,
    error,
    fetchGraphDefinitions,
    deleteGraphDefinition,
  } = useLangGraphDefinitions(apiClient, '/v1/lg-vis'); // Pass the apiClient and explicitly set the prefix
  const navigate = useNavigate();
  const [includeStatic, setIncludeStatic] = useState<boolean>(true);

  useEffect(() => {
    // Fetch definitions (including static ones if you want them listed here)
    // Set includeStatic to true if your listGraphDefinitions API and hook support it.
    fetchGraphDefinitions(includeStatic);
    
    // Clean up any pending requests
    return () => {
      // Any cleanup code if needed
    };
  }, [fetchGraphDefinitions, includeStatic]); // Add includeStatic as a dependency

  const handleDelete = async (graphId: string, graphName: string) => {
    if (!checkPermission('langgraph:delete')) { // Example permission
      alert('Permission denied to delete graph definitions.');
      return;
    }
    if (window.confirm(`Are you sure you want to delete the graph "${graphName}" (ID: ${graphId})? This action cannot be undone.`)) {
      const success = await deleteGraphDefinition(graphId);
      if (success) {
        // The list should refresh automatically due to the hook's logic
        alert(`Graph "${graphName}" deleted successfully.`);
      } else {
        // Error is handled by the hook and displayed
        alert(`Failed to delete graph "${graphName}".`);
      }
    }
  };

  const handleCreateNew = () => {
     if (!checkPermission('langgraph:create')) { // Example permission
       alert('Permission denied to create graph definitions.');
       return;
     }
    // Navigate to a create page or open a modal
    navigate('/langgraph/create'); // Assuming you have a LangGraphCreatePage
  };

  if (isLoading && graphDefinitions.length === 0) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 'calc(100vh - 150px)' }}>
        <Spin size="large">
          Loading graph definitions...
        </Spin>
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ padding: '20px' }}>
        <Alert message="Error Loading Graph Definitions" description={error} type="error" showIcon />
        <Button onClick={() => fetchGraphDefinitions(true)} style={{ marginTop: '16px' }}>
          Retry
        </Button>
      </div>
    );
  }

  return (
    <div className="page-container" style={{ maxWidth: '1200px', margin: '0 auto' }}>
      <Card
        title={
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Title level={2} style={{ margin: 0 }}>
              <ShareAltOutlined style={{ marginRight: '12px' }} />
              Agentic Workflows
            </Title>
            {checkPermission('langgraph:create') && (
              <Button type="primary" icon={<PlusOutlined />} onClick={handleCreateNew}>
                Create New Graph
              </Button>
            )}
          </div>
        }
        variant="outlined" // Changed from bordered={false}
      >        <Paragraph type="secondary">
          Manage and explore your automated agentic workflows powered by LangGraph.
          Each graph represents a sequence of operations that can be executed and visualized.
        </Paragraph>

        <div style={{ marginBottom: 16, display: 'flex', alignItems: 'center' }}>
          <Switch 
            checked={includeStatic} 
            onChange={(checked) => setIncludeStatic(checked)} 
            style={{ marginRight: 8 }}
          />
          <Text type="secondary">Include Static Graphs</Text>
          {isLoading && <Spin size="small" style={{ marginLeft: 16 }} />}
        </div>

        {graphDefinitions.length === 0 && !isLoading ? (
          <Empty description="No graph definitions found. Create one to get started!" style={{marginTop: '40px'}}>
            {checkPermission('langgraph:create') && (
                <Button type="primary" icon={<PlusOutlined />} onClick={handleCreateNew}>
                    Create Your First Graph
                </Button>
            )}
          </Empty>
        ) : (
          <List
            itemLayout="horizontal"
            dataSource={graphDefinitions}
            loading={isLoading} // Show loading indicator on list if fetching in background
            renderItem={(item) => {
              const isStatic = item.id.startsWith('static_');
              return (
                <List.Item
                  actions={[
                    <Tooltip title="View/Execute Graph" key="view">
                      <Link to={`/langgraph/view/${item.id}`}>
                        <Button icon={<EyeOutlined />} type="text" shape="circle" />
                      </Link>
                    </Tooltip>,
                    ...(checkPermission('langgraph:edit') && !isStatic ? [ // Assuming edit for non-static graphs
                      <Tooltip title="Edit Graph Definition" key="edit">
                         {/* Link to an edit page or open an edit modal */}
                         <Link to={`/langgraph/edit/${item.id}`}>
                            <Button icon={<EditOutlined />} type="text" shape="circle" />
                         </Link>
                      </Tooltip>
                    ] : []),
                    ...(checkPermission('langgraph:delete') && !isStatic ? [ // Prevent deleting static graphs via UI
                      <Tooltip title="Delete Graph" key="delete">
                        <Button
                          icon={<DeleteOutlined />}
                          type="text"
                          danger
                          shape="circle"
                          onClick={() => handleDelete(item.id, item.name)}
                        />
                      </Tooltip>
                    ] : []),
                  ]}
                >
                  <List.Item.Meta
                    avatar={<ShareAltOutlined style={{ fontSize: '24px', color: isStatic ? '#1677ff' : '#52c41a' }} />}
                    title={<Link to={`/langgraph/view/${item.id}`} style={{ fontSize: '1.1em' }}>{item.name}</Link>}
                    description={
                      <>
                        <Text type="secondary" style={{ display: 'block' }}>ID: <Text copyable code style={{fontSize: '0.8em'}}>{item.id}</Text></Text>
                        {item.updatedAt && (
                          <Text type="secondary" style={{ display: 'block' }}>
                            Last Updated: {formatDate(item.updatedAt).displayText}
                          </Text>
                        )}
                        {isStatic && <Tag color="geekblue" style={{marginTop: '4px'}}>Static Definition</Tag>}
                      </>
                    }
                  />
                </List.Item>
              );
            }}
            pagination={false} // Add pagination if list becomes very long
            // pagination={{
            //   pageSize: 10, // Or make it configurable
            //   total: graphDefinitions.length, // Hook doesn't provide total for this simple list yet
            //   showSizeChanger: true,
            // }}
          />
        )}
      </Card>
    </div>
  );
};

export default LangGraphListPage;

File: src/pages/ChatPage.css
/* src/pages/ChatPage.css */
.chat-page-container {
  display: flex;
  flex-direction: column;
  height: calc(100vh - 64px - 48px); /* Adjust based on your header/footer or PageLayout structure */
  /* Assuming header is 64px and some padding/margin of 48px */
  max-height: calc(100vh - 64px - 48px);
}

.chat-messages-list {
  flex-grow: 1;
  overflow-y: auto;
  padding: 16px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  margin-bottom: 16px;
  background-color: #f9f9f9;
}

.chat-message .ant-list-item-meta-title {
  margin-bottom: 2px !important;
  font-weight: 600;
}

.chat-message .ant-list-item-meta-description {
  color: rgba(0, 0, 0, 0.85);
}

.chat-message.user .ant-list-item-meta {
  flex-direction: row-reverse;
  text-align: right;
}

.chat-message.user .ant-list-item-meta-content {
  text-align: right; /* Align user's message text to the right */
}
.chat-message.user .ant-list-item-meta-avatar {
    margin-left: 12px;
    margin-right: 0;
}

.chat-message.assistant .ant-list-item-meta-avatar {
  margin-right: 12px;
}


.message-content {
  background-color: #ffffff;
  padding: 8px 12px;
  border-radius: 8px;
  display: inline-block;
  max-width: 80%; /* Prevent messages from taking full width */
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  white-space: pre-wrap; /* Preserve whitespace and newlines */
  word-wrap: break-word; /* Break long words */
}

.chat-message.user .message-content {
  background-color: #e6f7ff; /* Light blue for user messages */
  text-align: left; /* Keep text inside bubble left-aligned */
}

.chat-message.assistant .message-content {
  background-color: #f0f0f0; /* Light grey for assistant messages */
}


.chat-input-form {
  display: flex;
  align-items: center;
  padding-top: 16px; /* Add some space above input */
  border-top: 1px solid #f0f0f0; /* Separator line */
}

.loading-dots-container {
    display: flex;
    align-items: center;
    padding: 8px 0px;
}

.loading-dots span {
  display: inline-block;
  width: 8px;
  height: 8px;
  margin: 0 2px;
  background-color: #1890ff;
  border-radius: 50%;
  animation: loading-dots-animation 1.4s infinite ease-in-out both;
}

.loading-dots span:nth-child(1) {
  animation-delay: -0.32s;
}

.loading-dots span:nth-child(2) {
  animation-delay: -0.16s;
}

@keyframes loading-dots-animation {
  0%, 80%, 100% {
    transform: scale(0);
  }
  40% {
    transform: scale(1.0);
  }
}

File: src/langgraph/hooks/useReactFlowGraphAdapter.ts
// src/langgraph/hooks/useReactFlowGraphAdapter.ts
import { useState, useEffect, useCallback } from 'react';
import { Node as ReactFlowNode, Edge as ReactFlowEdge, Position, MarkerType } from 'reactflow';
import dagre from 'dagre'; 
import {
  FrontendGraphDef,
  FrontendNodeDef,
  FrontendEdgeDef,
  FrontendConditionalEdgesDef,
  UINodePosition,
  ReactFlowNodeData, 
  ReactFlowEdgeData, 
} from '../types/langgraph';

const dagreGraph = new dagre.graphlib.Graph({ compound: true }); 
dagreGraph.setDefaultEdgeLabel(() => ({})); 
dagreGraph.setGraph({
  rankdir: 'TB', 
  nodesep: 70,   
  ranksep: 90,   
});

const DEFAULT_NODE_WIDTH = 180;
const DEFAULT_NODE_HEIGHT = 60;

interface UseReactFlowGraphAdapterResult {
  nodes: ReactFlowNode<ReactFlowNodeData>[];
  edges: ReactFlowEdge<ReactFlowEdgeData>[];
  layoutGraph: (graphDefinition: FrontendGraphDef, currentExecutionState?: any) => void; 
  isLoadingLayout: boolean;
  errorLayout: string | null;
}

export const useReactFlowGraphAdapter = (): UseReactFlowGraphAdapterResult => {
  const [nodes, setNodes] = useState<ReactFlowNode<ReactFlowNodeData>[]>([]);
  const [edges, setEdges] = useState<ReactFlowEdge<ReactFlowEdgeData>[]>([]);
  const [isLoadingLayout, setIsLoadingLayout] = useState<boolean>(false);
  const [errorLayout, setErrorLayout] = useState<string | null>(null);

  const layoutGraph = useCallback((
    graphDefinition: FrontendGraphDef,
  ) => {
    if (!graphDefinition) {
      setNodes([]);
      setEdges([]);
      return;
    }

    setIsLoadingLayout(true);
    setErrorLayout(null);
    console.log("[useReactFlowGraphAdapter] Starting layoutGraph with definition:", JSON.parse(JSON.stringify(graphDefinition)));


    try {
      const dagreNodes: ReactFlowNode<ReactFlowNodeData>[] = [];
      const dagreEdges: ReactFlowEdge<ReactFlowEdgeData>[] = [];

      // 1. Prepare nodes for Dagre and React Flow
      // Ensure graphDefinition.nodes is an array before calling forEach
      (graphDefinition.nodes || []).forEach((nodeDef: FrontendNodeDef) => {
        dagreGraph.setNode(nodeDef.id, {
          width: DEFAULT_NODE_WIDTH,
          height: DEFAULT_NODE_HEIGHT,
        });

        const nodeData: ReactFlowNodeData = {
          label: nodeDef.id, 
          type: nodeDef.type, 
          config: nodeDef.config,
          status: 'idle', 
        };

        dagreNodes.push({
          id: nodeDef.id,
          type: 'customGraphNode', 
          data: nodeData,
          position: nodeDef.uiPosition || { x: 0, y: 0 }, 
          sourcePosition: Position.Bottom, 
          targetPosition: Position.Top,
        });
      });

      // 2. Prepare standard edges for Dagre and React Flow
      // Ensure graphDefinition.edges is an array before calling forEach
      (graphDefinition.edges || []).forEach((edgeDef: FrontendEdgeDef) => {
        dagreGraph.setEdge(edgeDef.source, edgeDef.target);
        dagreEdges.push({
          id: edgeDef.id || `e_${edgeDef.source}__${edgeDef.target}`,
          source: edgeDef.source,
          target: edgeDef.target,
          label: edgeDef.label,
          type: 'customGraphEdge', 
          animated: edgeDef.animated || false,
          markerEnd: { type: MarkerType.ArrowClosed },
          data: { label: edgeDef.label, status: 'idle' } as ReactFlowEdgeData,
        });
      });

      // 3. Prepare conditional edges for Dagre and React Flow
      // Ensure graphDefinition.conditionalEdges is an array before calling forEach
      (graphDefinition.conditionalEdges || []).forEach((condEdgesDef: FrontendConditionalEdgesDef) => {
        // Ensure condEdgesDef.mappings is an array before calling forEach
        (condEdgesDef.mappings || []).forEach((mapping) => {
          dagreGraph.setEdge(condEdgesDef.sourceNodeId, mapping.targetNodeId);
          dagreEdges.push({
            id: `ce_${condEdgesDef.sourceNodeId}__${mapping.targetNodeId}__${mapping.conditionName}`,
            source: condEdgesDef.sourceNodeId,
            target: mapping.targetNodeId,
            label: mapping.conditionName, 
            type: 'customGraphEdge', 
            animated: false,
            markerEnd: { type: MarkerType.ArrowClosed, color: '#FF0072' }, 
            style: { stroke: '#FF0072' }, 
            data: { label: mapping.conditionName, status: 'idle' } as ReactFlowEdgeData,
          });
        });
      });

      // 4. Run Dagre layout
      dagre.layout(dagreGraph);

      // 5. Update React Flow node positions with Dagre's calculated layout
      const layoutedNodes = dagreNodes.map((node) => {
        const dagreNode = dagreGraph.node(node.id);
        if (dagreNode) {
          return {
            ...node,
            position: {
              x: dagreNode.x - dagreNode.width / 2, 
              y: dagreNode.y - dagreNode.height / 2,
            },
          };
        }
        console.warn(`[useReactFlowGraphAdapter] Dagre node not found for ID: ${node.id} during position update.`);
        return node; 
      });

      setNodes(layoutedNodes);
      setEdges(dagreEdges);
      console.log("[useReactFlowGraphAdapter] Layout finished successfully.");

    } catch (err) {
      console.error('[useReactFlowGraphAdapter] Error during graph layout:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to layout graph.';
      setErrorLayout(errorMessage);
      setNodes([]); 
      setEdges([]);
    } finally {
      setIsLoadingLayout(false);
    }
  }, []); 

  useEffect(() => {
    return () => {
      setNodes([]);
      setEdges([]);
    };
  }, []);

  return {
    nodes,
    edges,
    layoutGraph,
    isLoadingLayout,
    errorLayout,
  };
};

File: src/constants/LeftSidebar.constants.ts
// src/constants/LeftSidebar.constants.ts
import {
  HomeOutlined,         // Test
  FileTextOutlined,     // Batch
  AppstoreOutlined,     // Batch Jobs (or use something else)
  HistoryOutlined,      // History
  MessageOutlined,      // Chat (Ant Design)
  DatabaseOutlined,     // RAG Info
  ShareAltOutlined,     // LangGraph (or BulbOutlined, PlayCircleOutlined, ApartmentOutlined)
  UserOutlined,         // Admin Users
  TeamOutlined,         // Admin Roles (or SafetyCertificateOutlined)
  SettingOutlined,      // Settings
  LogoutOutlined,       // Logout
  PlusOutlined,         // Needed for sub-items like "Create Graph"
  SolutionOutlined,     // ServiceNow (SNOW) icon
  // UnorderedListOutlined, // Example for sub-item, if needed
} from '@ant-design/icons';
import { LeftSidebarItem } from '../components/Sidebar/LeftSidebar.interface';
import { SidebarItem as SidebarItemEnum } from '../enum/sidebar.enum';

export const SIDEBAR_NESTED_KEYS: Record<string, string> = {
  '/batch/jobs': SidebarItemEnum.BATCH,
  // If you have /view/:id, /create, etc., and want the main LangGraph item to stay highlighted:
  [SidebarItemEnum.LANGGRAPH_VIEW]: SidebarItemEnum.LANGGRAPH_LIST,
  [SidebarItemEnum.LANGGRAPH_CREATE]: SidebarItemEnum.LANGGRAPH_LIST,
  [SidebarItemEnum.LANGGRAPH_EDIT]: SidebarItemEnum.LANGGRAPH_LIST, // If you add edit
  // Add SNOW routes
  [SidebarItemEnum.SNOW_ANALYZE]: SidebarItemEnum.SNOW_BASE,
  [SidebarItemEnum.SNOW_HISTORY]: SidebarItemEnum.SNOW_BASE,
  // Add your existing nested keys for admin, history etc.
  '/admin/users/edit': SidebarItemEnum.ADMIN_USERS, // Assuming you might have edit sub-routes
  '/admin/roles/edit': SidebarItemEnum.ADMIN_ROLES,
  '/history/details': SidebarItemEnum.HISTORY, // Added from previous context
};

// Base items before dynamic insertions
export const SIDEBAR_ITEMS: LeftSidebarItem[] = [
  {
    key: SidebarItemEnum.TEST,
    title: 'Test',
    icon: HomeOutlined,
    dataTestId: 'test-sidebar-item', // Changed dataTestId for clarity
    redirect_url: SidebarItemEnum.TEST,
    requiredPermission: 'classify:item', // Example permission
  },
  {
    key: SidebarItemEnum.BATCH,
    title: 'Batch',
    icon: FileTextOutlined,
    dataTestId: 'batch-sidebar-item',
    redirect_url: SidebarItemEnum.BATCH,
    requiredPermission: 'classify:batch',
    // disableExpandIcon: true, // Remove if children are present and you want auto-expand icon
    children: [
      {
        key: SidebarItemEnum.BATCH_JOBS,
        title: 'Batch Jobs',
        icon: AppstoreOutlined,
        dataTestId: 'batch-jobs-sidebar-item',
        redirect_url: SidebarItemEnum.BATCH_JOBS,
        requiredPermission: 'classify:batch', // Same as parent or more specific
      },
    ],
  },
  {
    key: SidebarItemEnum.HISTORY,
    title: 'History',
    icon: HistoryOutlined,
    dataTestId: 'history-sidebar-item',
    redirect_url: SidebarItemEnum.HISTORY,
    requiredPermission: 'history:view',
  },
  // CHAT_SIDEBAR_ITEM, RAG_INFO_SIDEBAR_ITEM, LANGGRAPH_VIS_SIDEBAR_ITEM will be inserted dynamically
];

// Define items to be dynamically inserted
export const CHAT_SIDEBAR_ITEM: LeftSidebarItem = {
    key: SidebarItemEnum.CHAT,
    title: 'Chat',
    icon: MessageOutlined,
    dataTestId: 'chat-sidebar-item',
    redirect_url: SidebarItemEnum.CHAT,
    requiredPermission: 'chat:use', // Example permission
};

export const RAG_INFO_SIDEBAR_ITEM: LeftSidebarItem = {
    key: SidebarItemEnum.RAG_INFO,
    title: 'Information ', 
    icon: DatabaseOutlined,
    dataTestId: 'rag-info-sidebar-item',
    redirect_url: SidebarItemEnum.RAG_INFO,
    requiredPermission: 'rag:view',
};

export const LANGGRAPH_VIS_SIDEBAR_ITEM: LeftSidebarItem = {
    key: SidebarItemEnum.LANGGRAPH_LIST,
    title: 'Workflows', 
    icon: ShareAltOutlined, // Example icon, choose one you like
    dataTestId: 'langgraph-sidebar-item',
    redirect_url: SidebarItemEnum.LANGGRAPH_LIST,
    requiredPermission: 'langgraph:view', // Example permission
    // If you want sub-menu items like "Create New" or "View X":
    children: [
      // {
      //   key: SidebarItemEnum.LANGGRAPH_LIST, // Would be redundant if parent links here
      //   title: 'View Graphs',
      //   icon: UnorderedListOutlined, // Example
      //   dataTestId: 'view-graphs-item',
      //   redirect_url: SidebarItemEnum.LANGGRAPH_LIST,
      // },
      {
        key: SidebarItemEnum.LANGGRAPH_CREATE,
        title: 'Create Graph',
        icon: PlusOutlined,
        dataTestId: 'create-graph-item',
        redirect_url: SidebarItemEnum.LANGGRAPH_CREATE,
        requiredPermission: 'langgraph:create',
      },
    ]
};

// ServiceNow (SNOW) sidebar item
export const SNOW_SIDEBAR_ITEM: LeftSidebarItem = {
  key: SidebarItemEnum.SNOW_BASE,
  title: 'ServiceNow',
  icon: SolutionOutlined,
  dataTestId: 'snow-sidebar-item',
  redirect_url: SidebarItemEnum.SNOW_ANALYZE,
  requiredPermission: 'snow:analyze',
  children: [
    {
      key: SidebarItemEnum.SNOW_ANALYZE,
      title: 'Analyze',
      icon: SolutionOutlined,
      dataTestId: 'snow-analyze-sidebar-item',
      redirect_url: SidebarItemEnum.SNOW_ANALYZE,
      requiredPermission: 'snow:analyze',
    },
    {
      key: SidebarItemEnum.SNOW_HISTORY,
      title: 'History',
      icon: HistoryOutlined,
      dataTestId: 'snow-history-sidebar-item',
      redirect_url: SidebarItemEnum.SNOW_HISTORY,
      requiredPermission: 'snow:history:view',
    },
  ],
};


export const ADMIN_SIDEBAR_ITEMS: LeftSidebarItem[] = [
    {
        key: SidebarItemEnum.ADMIN_USERS,
        title: 'Users',
        icon: UserOutlined,
        dataTestId: 'admin-users-sidebar-item',
        redirect_url: SidebarItemEnum.ADMIN_USERS,
        requiredPermission: 'users:view', // Or users:manage if view is tied to manage
    },
    {
        key: SidebarItemEnum.ADMIN_ROLES,
        title: 'Roles',
        icon: TeamOutlined,
        dataTestId: 'admin-roles-sidebar-item',
        redirect_url: SidebarItemEnum.ADMIN_ROLES,
        requiredPermission: 'roles:view', // Or roles:manage
    },
];

// Bottom items remain the same
export const SETTING_ITEM: LeftSidebarItem = {
  key: SidebarItemEnum.SETTINGS,
  title: 'Settings',
  redirect_url: SidebarItemEnum.SETTINGS,
  icon: SettingOutlined,
  dataTestId: 'settings-sidebar-item',
  requiredPermission: 'config:view',
};

export const LOGOUT_ITEM: LeftSidebarItem = {
  key: SidebarItemEnum.LOGOUT,
  title: 'Logout',
  icon: LogoutOutlined,
  dataTestId: 'logout-sidebar-item',
  // No redirect_url, onClick is handled in LeftSidebar.component.tsx
};

export const BOTTOM_SIDEBAR_ITEMS: LeftSidebarItem[] = [SETTING_ITEM, LOGOUT_ITEM];

File: src/components/ConfigValue.tsx
/**
 * ConfigValue is a reusable component for rendering configuration values of different types.
 * It handles special cases like sensitive data masking, boolean styling, and complex object display.
 *
 * @component
 * @example
 * ```tsx
 * <ConfigValue configKey="apiKey" value="secret" />        // Renders: ********
 * <ConfigValue configKey="enabled" value={true} />         // Renders: True (with green styling)
 * <ConfigValue configKey="items" value={[1, 2, 3]} />     // Renders: Array[3]
 * ```
 */
import React from 'react';

// Helper function to generate user-friendly labels from keys
export const getConfigLabel = (key: string): string => {
  // Replace underscores/camelCase with spaces and capitalize words
  const result = key
    .replace(/_/g, ' ') // Replace underscores with spaces
    .replace(/([A-Z])/g, ' $1') // Add space before uppercase letters
    .replace(/^./, (str) => str.toUpperCase()) // Capitalize first letter
    .trim();

  // Specific replacements for acronyms or common terms
  return result
    .replace(/Llm/g, 'LLM')
    .replace(/Api/g, 'API')
    .replace(/Id/g, 'ID')
    .replace(/Url/g, 'URL')
    .replace(/Db/g, 'DB')
    .replace(/Jwt/g, 'JWT')
    .replace(/Rag /g, 'RAG ') // Keep RAG capitalized
    .replace(/Unspsc/g, 'UNSPSC');
};

interface ConfigValueProps {
  /** The configuration key, used to determine if value should be masked */
  configKey: string;
  /** The value to render */
  value: any;
  /** Optional className for styling override */
  className?: string;
}

const ConfigValue: React.FC<ConfigValueProps> = ({ value, configKey, className = '' }): JSX.Element => {
  // Function to check if a value should be masked (for sensitive data)
  const shouldMaskValueByKey = (key: string): boolean => {
    const lowerKey = key.toLowerCase();
    const sensitiveKeys = ['password', 'apikey', 'secret', 'token']; // Add 'token'
    return sensitiveKeys.some(sensitiveKey => lowerKey.includes(sensitiveKey));
  };

  const isRedactedValue = (val: any): boolean => {
    return typeof val === 'string' && val.toUpperCase().includes('[REDACTED]');
  };

  if (value === null || value === undefined) {
    return <span className={`text-secondary-400 italic ${className}`}>Not set</span>;
  }

  // Check if backend already redacted it OR if key indicates sensitivity
  if (isRedactedValue(value) || shouldMaskValueByKey(configKey)) {
    return <span className={`text-secondary-700 font-mono ${className}`}>â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢</span>; // Consistent masking
  }

  if (typeof value === 'boolean') {
    return (
      <span className={`px-2 py-0.5 text-xs rounded-full font-medium border ${className} ${
        value
          ? 'bg-green-100 text-green-800 border-green-200'
          : 'bg-red-100 text-red-800 border-red-200'
      }`}>
        {value ? 'Enabled' : 'Disabled'}
      </span>
    );
  }

   if (typeof value === 'object' && value !== null) {
     // Don't display complex objects directly, parent component will handle recursion
     return <span className={`text-secondary-500 italic ${className}`}>Object</span>;
   }

   // Render arrays as comma-separated list (or count)
   if (Array.isArray(value)) {
     if (value.length === 0) {
       return <span className={`text-secondary-400 italic ${className}`}>Empty List</span>;
     }
     const displayLimit = 5;
     const displayValue = value.slice(0, displayLimit).map(item => typeof item === 'object' ? '[Object]' : String(item)).join(', ');
     return (
       <span className={`text-secondary-700 ${className}`} title={value.join(', ')}>
         {displayValue}{value.length > displayLimit ? `... (${value.length} items)` : ''}
       </span>
     );
   }

  // Default: render as string
  return <span className={`text-secondary-700 ${className}`}>{String(value)}</span>;
};

export default ConfigValue;

File: src/langgraph/components/NodeInspectorPanel.tsx
// src/langgraph/components/NodeInspectorPanel.tsx
import React from 'react';
import { Node as ReactFlowNode, Edge as ReactFlowEdge } from 'reactflow';
import { ReactFlowNodeData, ReactFlowEdgeData } from '../types/langgraph';
import { Button, Descriptions, Empty, Tag, Card, Typography, Tooltip } from 'antd'; // Using Ant Design components
import { InfoCircleOutlined } from '@ant-design/icons';

const { Text, Paragraph } = Typography;

interface NodeInspectorPanelProps {
  selectedElement: ReactFlowNode<ReactFlowNodeData> | ReactFlowEdge<ReactFlowEdgeData> | null;
  onClose: () => void; // Callback to close the panel
  // You might also pass node-specific data from execution state if needed
  // For example: lastInput?: any; lastOutput?: any;
}

const JsonViewer: React.FC<{ data: any; title?: string }> = ({ data, title }) => {
  if (data === undefined || data === null || Object.keys(data).length === 0) {
    return <Text type="secondary" italic>{title ? `${title}: Not available` : 'Not available'}</Text>;
  }
  try {
    return (
      <div style={{ marginTop: '8px' }}>
        {title && <Text strong className="text-sm">{title}:</Text>}
        <pre
          style={{
            background: '#f0f2f5', // Ant Design background color
            border: '1px solid #d9d9d9', // Ant Design border color
            borderRadius: '4px',
            padding: '8px',
            fontSize: '12px',
            maxHeight: '200px',
            overflowY: 'auto',
            whiteSpace: 'pre-wrap', // Ensure wrapping
            wordBreak: 'break-all', // Break long words/strings
          }}
        >
          {JSON.stringify(data, null, 2)}
        </pre>
      </div>
    );
  } catch (e) {
    return <Text type="danger" italic>{title ? `${title}: Error displaying data` : 'Error displaying data'}</Text>;
  }
};

const NodeInspectorPanel: React.FC<NodeInspectorPanelProps> = ({
  selectedElement,
  onClose,
}) => {
  if (!selectedElement) {
    return (
      <div style={{ padding: '16px', borderLeft: '1px solid #e8e8e8', height: '100%' }}>
        <Empty description="Select a node or edge to see details" image={Empty.PRESENTED_IMAGE_SIMPLE} />
      </div>
    );
  }

  const isNode = 'data' in selectedElement && 'position' in selectedElement; // Basic check for Node type
  const data = selectedElement.data as ReactFlowNodeData | ReactFlowEdgeData; // Type assertion

  return (
    <Card
      title={
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          {isNode ? 'Node Details' : 'Edge Details'}
          <Button type="text" onClick={onClose} size="small">
            Close
          </Button>
        </div>
      }
      style={{ height: '100%', display: 'flex', flexDirection: 'column', borderLeft: '1px solid #f0f0f0' }}
      bodyStyle={{ flexGrow: 1, overflowY: 'auto', padding: '16px' }}
      size="small"
    >
      <Descriptions bordered column={1} size="small" layout="horizontal">
        <Descriptions.Item label="ID">
          <Text copyable style={{ fontFamily: 'monospace' }}>{selectedElement.id}</Text>
        </Descriptions.Item>

        {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.type && (
          <Descriptions.Item label="Type">
            <Tag color="blue">{(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.type}</Tag>
          </Descriptions.Item>
        )}

        {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status && (
          <Descriptions.Item label="Status">
            <Tag
              color={
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'running' ? 'gold' :
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'success' ? 'green' :
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'error' ? 'red' :
                (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status === 'active' ? 'processing' :
                'default'
              }
            >
              {(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.status?.toUpperCase()}
            </Tag>
          </Descriptions.Item>
        )}

        {!isNode && (data as ReactFlowEdgeData).label && (
          <Descriptions.Item label="Label">
            <Text>{(data as ReactFlowEdgeData).label}</Text>
          </Descriptions.Item>
        )}
         {!isNode && (data as ReactFlowEdgeData).status && (
          <Descriptions.Item label="Status">
             <Tag color={(data as ReactFlowEdgeData).status === 'traversed' ? 'green' : 'default'}>
                {(data as ReactFlowEdgeData).status?.toUpperCase()}
             </Tag>
          </Descriptions.Item>
        )}
      </Descriptions>

      {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.config && (
        <JsonViewer data={(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.config} title="Configuration" />
      )}

      {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.inputs && (
        <JsonViewer data={(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.inputs} title="Last Inputs" />
      )}

      {isNode && (selectedElement as ReactFlowNode<ReactFlowNodeData>).data.outputs && (
        <JsonViewer data={(selectedElement as ReactFlowNode<ReactFlowNodeData>).data.outputs} title="Last Outputs" />
      )}

      {/* Raw Data for Debugging - can be behind a toggle */}
      <details style={{ marginTop: '16px', cursor: 'pointer' }}>
        <summary style={{ fontSize: '12px', color: '#888' }}>
            <Tooltip title="View raw element data for debugging">
                <InfoCircleOutlined style={{marginRight: '4px'}} />
                Raw Data
            </Tooltip>
        </summary>
        <JsonViewer data={selectedElement} />
      </details>

    </Card>
  );
};

export default NodeInspectorPanel;

File: src/components/ManualClassificationModal.tsx
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import Select, { 
  SingleValue, 
  InputActionMeta,
  GroupBase 
} from 'react-select';
import debounce from 'lodash/debounce';
import {
  ApiClient,
  ClassificationLevel,
  Category,
  ManualClassificationRequest,
  ClassificationResult,
  SystemCategoriesRequest
} from '../api/types';

// Constants
const SEARCH_DEBOUNCE_MS = 300;
const MIN_SEARCH_CHARS = 2;
const SELECT_STYLES = {
  menuPortal: (base: any) => ({ ...base, zIndex: 9999 }),
  menu: (base: any) => ({ ...base, zIndex: 9999 })
};

// Types
interface CategoryOption {
  value: string;
  label: string;
  data: Category;
}

interface ManualClassificationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (result: ClassificationResult) => void;
  apiClient: ApiClient;
  description: string;
  systemCode: string;
  initialLevels?: { [levelCode: string]: string };
}

interface LevelState {
  loading: boolean;
  error: string | null;
  options: Category[];
}

// Initial state
const INITIAL_LEVEL_STATE: LevelState = {
  loading: false,
  error: null,
  options: []
};

// Utility functions
const transformCategoryToOption = (category: Category): CategoryOption => ({
  value: category.code,
  label: `${category.code} - ${category.name}`,
  data: category
});

const transformCategoriesToOptions = (categories: Category[]): CategoryOption[] => 
  categories.map(transformCategoryToOption);

export const ManualClassificationModal: React.FC<ManualClassificationModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  apiClient,
  description,
  systemCode,
  initialLevels,
}) => {
  const [selectedCategories, setSelectedCategories] = useState<{ [levelCode: string]: string }>(initialLevels || {});
  const [levels, setLevels] = useState<ClassificationLevel[]>([]);
  const [levelStates, setLevelStates] = useState<{ [levelCode: string]: LevelState }>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const levelSequence = useMemo(() => 
    levels.sort((a, b) => a.levelNumber - b.levelNumber).map(level => level.code), 
    [levels]
  );

  useEffect(() => {
    if (!isOpen) return;

    const initializeLevelStates = () => {
      setLevelStates(prev => {
        const newStates = { ...prev };
        levels.forEach(level => {
          if (!newStates[level.code]) {
            newStates[level.code] = { ...INITIAL_LEVEL_STATE };
          }
        });
        return newStates;
      });
    };

    // Reset selected categories when modal opens
    if (initialLevels) {
      setSelectedCategories(initialLevels);
    } else {
      setSelectedCategories({});
    }

    initializeLevelStates();
  }, [levels, isOpen, initialLevels]);

  useEffect(() => {
    let mounted = true;

    const loadInitialData = async () => {
      if (!isOpen) return;
      // Add guard clause to prevent API call with undefined systemCode
      if (!systemCode) {
        setError('System code is not provided.');
        console.error('Attempted to load initial data without a system code.');
        setLoading(false); // Ensure loading state is reset
        return;
      }
      
      try {
        setError(null);
        setLoading(true);
        
        const { levels: systemLevels } = await apiClient.getClassificationSystem(systemCode);
        if (!mounted) return;
        
        const sortedLevels = systemLevels.sort((a, b) => a.levelNumber - b.levelNumber);
        setLevels(sortedLevels);

        // Initialize all level states
        const initialStates: { [key: string]: LevelState } = {};
        sortedLevels.forEach(level => {
          initialStates[level.code] = { ...INITIAL_LEVEL_STATE };
        });
        setLevelStates(initialStates);

        // Load initial categories for levels with selected values
        if (initialLevels && mounted) {
          // Load levels sequentially to maintain parent-child relationships
          for (const level of sortedLevels) {
            const parentLevel = sortedLevels.find(l => l.levelNumber === level.levelNumber - 1);
            const parentCode = parentLevel ? selectedCategories[parentLevel.code] : undefined;
            
            // Load categories for this level
            await loadLevelCategories(level.code, parentCode);

            // Pre-select the category if it exists in initialLevels
            if (level.code in initialLevels) {
              setSelectedCategories(prev => ({
                ...prev,
                [level.code]: initialLevels[level.code]
              }));
            }
          }
        }
      } catch (error) {
        if (!mounted) return;
        setError(error instanceof Error ? error.message : 'Failed to load system levels');
        console.error('Failed to load system levels:', error);
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };

    loadInitialData();
    return () => { mounted = false; };
  }, [apiClient, systemCode, isOpen, initialLevels]);

  const loadLevelCategories = useCallback(async (
    levelCode: string,
    parentCode?: string,
    search?: string
  ) => {
    console.debug('Loading categories:', { levelCode, parentCode, search });
    
    setLevelStates(prev => ({
      ...prev,
      [levelCode]: {
        ...prev[levelCode],
        loading: true,
        error: null
      }
    }));
    
    try {
      const request: SystemCategoriesRequest = {
        systemCode,
        level: levelCode,
        parentCode,
        search: search?.trim()
      };

      const categories = await apiClient.getSystemCategories(request);
      
      console.debug('Categories loaded:', {
        levelCode,
        parentCode,
        count: categories.length,
        categories: categories.map(c => `${c.code} - ${c.name}`)
      });
      
      setLevelStates(prev => ({
        ...prev,
        [levelCode]: {
          loading: false,
          error: null,
          options: categories
        }
      }));
    } catch (error) {
      const message = error instanceof Error ? error.message : `Failed to load categories for ${levelCode}`;
      console.error('Category loading error:', { levelCode, parentCode, error });
      
      setLevelStates(prev => ({
        ...prev,
        [levelCode]: {
          ...prev[levelCode],
          loading: false,
          error: message
        }
      }));
    }
  }, [apiClient, systemCode]);

  const debouncedLoadCategories = useMemo(
    () => debounce(loadLevelCategories, SEARCH_DEBOUNCE_MS),
    [loadLevelCategories]
  );

  const getParentLevelCode = useCallback((currentLevelCode: string): string | undefined => {
    const currentLevel = levels.find(l => l.code === currentLevelCode);
    if (!currentLevel) return undefined;
    
    const parentLevel = levels.find(l => l.levelNumber === currentLevel.levelNumber - 1);
    return parentLevel?.code;
  }, [levels]);

  const handleCategoryChange = useCallback(async (
    levelCode: string, 
    option: SingleValue<CategoryOption>
  ) => {
    const level = levels.find(l => l.code === levelCode);
    if (!level) return;

    const levelIndex = levelSequence.indexOf(levelCode);
    if (levelIndex === -1) return;

    const categoryCode = option?.value || '';

    setSelectedCategories(prev => {
      const newSelected = { ...prev };
      // Clear subsequent levels
      levelSequence.slice(levelIndex + 1).forEach(nextLevel => {
        delete newSelected[nextLevel];
      });
      
      if (categoryCode) {
        newSelected[levelCode] = categoryCode;
      } else {
        delete newSelected[levelCode];
      }
      
      return newSelected;
    });

    // Clear states for subsequent levels
    setLevelStates(prev => {
      const newStates = { ...prev };
      levelSequence.slice(levelIndex + 1).forEach(nextLevel => {
        newStates[nextLevel] = { ...INITIAL_LEVEL_STATE };
      });
      return newStates;
    });

    // Load next level's categories if a category was selected
    if (categoryCode) {
      const nextLevelCode = levelSequence[levelIndex + 1];
      if (nextLevelCode) {
        await loadLevelCategories(nextLevelCode, categoryCode);
      }
    }
  }, [levels, levelSequence, loadLevelCategories]);

  const handleInputChange = useCallback((
    levelCode: string,
    newValue: string,
    actionMeta: InputActionMeta
  ) => {
    if (actionMeta.action !== 'input-change') return;

    const parentLevelCode = getParentLevelCode(levelCode);
    const parentCategoryCode = parentLevelCode ? selectedCategories[parentLevelCode] : undefined;

    if (newValue.length >= MIN_SEARCH_CHARS) {
      debouncedLoadCategories(levelCode, parentCategoryCode, newValue);
    } else if (newValue.length === 0) {
      loadLevelCategories(levelCode, parentCategoryCode);
    }
  }, [debouncedLoadCategories, loadLevelCategories, getParentLevelCode, selectedCategories]);

  const handleSubmit = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const request: ManualClassificationRequest = {
        description,
        systemCode,
        levels: selectedCategories,
      };
      
      const result = await apiClient.classifyManually(request);
      onSubmit(result);
      onClose();
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Classification failed';
      console.error('Classification error:', error);
      setError(message);
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="p-6 space-y-6">
          <div className="flex justify-between items-center">
            <h2 className="text-xl font-semibold text-secondary-900">
              Manual Classification
            </h2>
            <button
              onClick={onClose}
              className="text-secondary-500 hover:text-secondary-700"
            >
              <span className="sr-only">Close</span>
              <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          <div className="border rounded-lg p-4 bg-secondary-50 text-sm">
            <p className="font-medium">Description:</p>
            <p className="mt-1">{description}</p>
          </div>

          <div className="space-y-4">
            {levels.map((level, index) => {
              const levelState = levelStates[level.code] || { ...INITIAL_LEVEL_STATE };
              const isDisabled = index > 0 && !selectedCategories[levels[index - 1].code];
              const selectedValue = selectedCategories[level.code];
              const selectedOption = selectedValue 
                ? levelState.options.find(cat => cat.code === selectedValue)
                : null;
              
              return (
                <div key={level.code} className="space-y-2">
                  <label className="block text-sm font-medium text-secondary-700">
                    {level.name}:
                  </label>
                  <Select<CategoryOption, false, GroupBase<CategoryOption>>
                    value={selectedOption ? transformCategoryToOption(selectedOption) : null}
                    onChange={(option) => handleCategoryChange(level.code, option)}
                    options={transformCategoriesToOptions(levelState.options)}
                    onInputChange={(newValue, actionMeta) => 
                      handleInputChange(level.code, newValue, actionMeta)
                    }
                    isDisabled={isDisabled || levelState.loading}
                    isLoading={levelState.loading}
                    placeholder={`Search ${level.name}...`}
                    noOptionsMessage={({inputValue}) => 
                      inputValue.length < MIN_SEARCH_CHARS 
                        ? `Type ${MIN_SEARCH_CHARS} or more characters to search...` 
                        : "No options found"
                    }
                    isClearable
                    menuPortalTarget={document.body}
                    styles={SELECT_STYLES}
                    classNamePrefix="react-select"
                  />
                  {levelState.error && (
                    <div className="text-sm text-red-600">
                      {levelState.error}
                    </div>
                  )}
                </div>
              );
            })}
          </div>

          {error && (
            <div className="rounded-lg border border-red-200 bg-red-50/50 px-4 py-3 text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="flex justify-end space-x-4">
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm font-medium text-secondary-700 hover:text-secondary-800 focus:outline-none focus:ring-2 focus:ring-secondary-500 focus:ring-offset-2"
              disabled={loading}
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              disabled={loading || Object.keys(selectedCategories).length === 0}
              className={`px-4 py-2 text-sm font-medium text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 ${
                loading || Object.keys(selectedCategories).length === 0
                  ? 'bg-secondary-400 cursor-not-allowed'
                  : 'bg-primary-600 hover:bg-primary-700 focus:ring-primary-500'
              }`}
            >
              {loading ? (
                <div className="flex items-center space-x-2">
                  <svg className="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                  </svg>
                  <span>Saving...</span>
                </div>
              ) : (
                'Save Classification'
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};


File: src/components/ClassificationDetailsModal.tsx
// src/components/ClassificationDetailsModal.tsx
import React, { useState, useEffect, useMemo } from 'react';
import { ClassificationHistory, CategoryLevel } from '../api/types';
import { formatDate } from '../utils/dateFormat'; 
import ReactMarkdown from 'react-markdown';
// import { InformationCircleIcon } from '@heroicons/react/24/outline'; // Removed unused import

interface ClassificationDetailsModalProps {
  isOpen: boolean;
  onClose: () => void;
  item: ClassificationHistory | null;
}

// Define informationalErrorMessages locally or import if shared
const informationalErrorMessages = [
  "Classification failed to determine required levels",
  "Classification failed to determine required levels.",
  "No matching category found at this level",
  "Failed to classify at this level",
  "Classification is partial; some levels may be missing or invalid.",
  "Classification is partial.", // Added from strategy_standard
  "Classification failed.", // Added from strategy_standard
  "Level not classified.", // Common pattern for level-specific messages
  "No match found for level", // Common pattern for no-match messages
];

const isInformationalError = (errorMessage?: string): boolean => {
  if (!errorMessage) return false;
  const lowerMessage = errorMessage.toLowerCase();
  return informationalErrorMessages.some(msg => lowerMessage.includes(msg.toLowerCase()));
};


export const ClassificationDetailsModal: React.FC<ClassificationDetailsModalProps> = ({
  isOpen,
  onClose,
  item
}) => {
  const [activeTab, setActiveTab] = useState<'details' | 'rag' | 'llm' | 'prompt'>('details');
  const [activeLlmTab, setActiveLlmTab] = useState<string | null>(null);
  const [activePromptTab, setActivePromptTab] = useState<string | null>(null);
  const levelOrder: Record<string, number> = useMemo(() => ({ 
    'segment': 1, 'family': 2, 'class': 3, 'commodity': 4,
    'subcat1': 1, 'subcat2': 2, 'default': 99, 'first_level': 0, 
    'first_level_prompt_only': 0, 'error_prompt': 0
  }), []);

  const parsedPrompts = useMemo(() => {
    if (item?.allPromptsDetail) { // allPromptsDetail is now string | undefined
      try {
        const parsed = JSON.parse(item.allPromptsDetail);
        if (typeof parsed === 'object' && parsed !== null) {
          return parsed as Record<string, string>;
        }
        console.warn("Parsed allPromptsDetail is not an object:", parsed);
        // Fallback if JSON is valid but not an object
      } catch (e) {
        console.error("Failed to parse allPromptsDetail JSON:", e, "\nContent:", item.allPromptsDetail);
        // Fall through to firstLevelPrompt if parsing fails
      }
    }
    
    // Fallback to firstLevelPrompt if allPromptsDetail is missing, unparsable, or not an object
    if (item?.firstLevelPrompt) {
        // Try to determine a sensible key for the first level prompt
        let firstLevelKey = "first_level_prompt"; // Default key
        if (item.levels && Object.keys(item.levels).length > 0) {
            const sortedLevels = Object.keys(item.levels).sort((a,b) => (levelOrder[a.toLowerCase()] ?? 99) - (levelOrder[b.toLowerCase()] ?? 99));
            if (sortedLevels.length > 0) {
                firstLevelKey = sortedLevels[0];
            }
        } else if (item.allPromptsDetail && item.allPromptsDetail.includes("error_prompt")){ 
            // Special case for error prompt
            firstLevelKey = "error_prompt";
        }
        return { [firstLevelKey]: item.firstLevelPrompt };
    }
    return null;
  }, [item?.allPromptsDetail, item?.firstLevelPrompt, item?.levels, levelOrder]);

  const sortedLevelCodesForTabs = useMemo(() => {
    if (!item) return [];
    const levelCodes = new Set<string>();
    
    // From LLM Responses
    if (item.levelResponses) {
        Object.keys(item.levelResponses).forEach(lc => levelCodes.add(lc));
    }
    
    // From Parsed Prompts
    if (parsedPrompts) {
        Object.keys(parsedPrompts).forEach(lc => levelCodes.add(lc));
    }
    
    // From actual classification levels (if available and others are not)
    if (levelCodes.size === 0 && item.levels) {
        Object.keys(item.levels).forEach(lc => levelCodes.add(lc));
    }
    
    return Array.from(levelCodes).sort((a, b) => 
      (levelOrder[a.toLowerCase()] ?? levelOrder['default']) - (levelOrder[b.toLowerCase()] ?? levelOrder['default']) || a.localeCompare(b)
    );
  }, [item, parsedPrompts, levelOrder]);
  useEffect(() => {
    if (isOpen) {
      setActiveTab('details');
      if (sortedLevelCodesForTabs.length > 0) {
        const firstTabKey = sortedLevelCodesForTabs[0];
        setActiveLlmTab(firstTabKey);
        setActivePromptTab(firstTabKey);
      } else {
        // If no specific level tabs, but a firstLevelPrompt exists, set activePromptTab to a generic key
        if (item?.firstLevelPrompt && parsedPrompts && Object.keys(parsedPrompts).length > 0) {
            setActivePromptTab(Object.keys(parsedPrompts)[0]); // Use the key from parsedPrompts
        } else {
            setActivePromptTab(null);
        }
        setActiveLlmTab(null);
      }
    }
  }, [isOpen, sortedLevelCodesForTabs, item?.firstLevelPrompt, parsedPrompts]);

  if (!isOpen || !item) {
    return null;
  }

  const getLevelResponse = (levelCode: string): string => {
    return item?.levelResponses?.[levelCode] || 'No LLM response available for this level.';
  };

  const getLevelPrompt = (levelCode: string): string => {
    return parsedPrompts?.[levelCode] || item?.firstLevelPrompt || 'No prompt available for this level.';
  }

  const formatRagContext = (ragContext: string) => { 
    return ragContext.split('\n\n').map((section, index) => (
      <div key={index} className="mb-4">
        {section.split('\n').map((line, lineIndex) => (
          <div key={lineIndex} className={lineIndex === 0 && !line.startsWith('- ') ? 'font-medium text-secondary-700' : line.startsWith('- ') ? 'ml-2 text-secondary-600' : 'ml-4 text-secondary-600'}>
            {line}
          </div>
        ))}
      </div>
    ));
  };

  const renderMarkdown = (content: string) => { 
    return (
      <div className="text-sm text-secondary-900 whitespace-pre-wrap prose prose-sm max-w-none">
        <ReactMarkdown>{content}</ReactMarkdown>
      </div>
    );
  };

  const getLevelName = (levelCode: string): string => { 
    const levelNames: Record<string, string> = {
      'segment': 'Segment', 'family': 'Family', 'class': 'Class', 'commodity': 'Commodity',
      'subcat1': 'Subcategory 1', 'subcat2': 'Subcategory 2'
    };
    return levelNames[levelCode.toLowerCase()] || levelCode;
  };

  const getSourceTypeLabel = (sourceType: string): string => { 
    if (!sourceType) return 'Unknown';
    const stLower = sourceType.toLowerCase();
    if (stLower.includes('user') || stLower.includes('manual')) return 'Manual Input';
    if (stLower.includes('batch')) return 'Batch';
    if (stLower.includes('api')) return 'API Input';
    return sourceType;
  };

  return (
    <div className="fixed inset-0 flex items-center justify-center z-50 p-4">
      <div className="fixed inset-0 bg-black opacity-30" onClick={onClose}></div>
      <div className="relative bg-white rounded-lg shadow-xl w-full max-w-5xl mx-auto max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="border-b border-secondary-200 px-6 py-4 flex justify-between items-center sticky top-0 bg-white z-10">
          <h3 className="text-xl font-semibold text-secondary-900 flex items-center">
            Classification Details
            <span className={`ml-3 inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${
              item.status === 'success' ? 'bg-green-100 text-green-800 border-green-200' : 
              item.status === 'partial' ? 'bg-yellow-100 text-yellow-800 border-yellow-200' : 
              'bg-red-100 text-red-800 border-red-200'
            }`}>
              {item.status === 'success' ? 'Success' : item.status === 'partial' ? 'Partial' : 'Failed'}
            </span>
          </h3>
          <button onClick={onClose} className="text-secondary-500 hover:text-secondary-700 transition-colors">
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Tabs */}
        <div className="border-b border-secondary-200 px-6 sticky top-[65px] bg-white z-10"> {/* Adjust top based on header height */}
          <div className="flex space-x-6 overflow-x-auto">
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'details' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('details')}
            > Classification Details </button>
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'rag' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('rag')} disabled={!item.ragContextUsed}
            > RAG Context {item.ragContextUsed && (<span className="ml-2 inline-flex items-center px-1.5 py-0.5 rounded-full text-xs font-medium bg-primary-100 text-primary-700">Used</span>)}</button>
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'llm' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('llm')} disabled={!item.levelResponses || sortedLevelCodesForTabs.length === 0}
            > LLM Responses {item.levelResponses && sortedLevelCodesForTabs.length > 0 && (<span className="ml-2 inline-flex items-center px-1.5 py-0.5 rounded-full text-xs font-medium bg-primary-100 text-primary-700">{sortedLevelCodesForTabs.length}</span>)}</button>
            <button
              className={`py-3 text-sm font-medium border-b-2 whitespace-nowrap ${ activeTab === 'prompt' ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
              onClick={() => setActiveTab('prompt')} disabled={!parsedPrompts && !item.firstLevelPrompt}
            > Prompts </button>
          </div>
        </div>
        
        {/* Content */}
        <div className="px-6 py-4 overflow-y-auto flex-grow">
          {activeTab === 'details' && ( 
            <div className="space-y-6">
              <div>
                <h4 className="text-lg font-medium text-secondary-900 mb-3">Basic Information</h4>
                <div className="bg-secondary-50 rounded-lg p-4 grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                  <div><p className="text-sm font-medium text-secondary-500">Description</p><p className="text-sm text-secondary-900 mt-1 break-words">{item.description}</p></div>
                  <div><p className="text-sm font-medium text-secondary-500">System</p><p className="text-sm text-secondary-900 mt-1">{item.systemCode}</p></div>
                  <div><p className="text-sm font-medium text-secondary-500">Created At</p>
                    <p className="text-sm text-secondary-900 mt-1" title={formatDate(item.createdAt, {includeTimezone: true}).fullText}>
                        {formatDate(item.createdAt).displayText}
                    </p>
                  </div>
                  <div><p className="text-sm font-medium text-secondary-500">Source</p><p className="text-sm text-secondary-900 mt-1">{getSourceTypeLabel(item.sourceType)}</p></div>
                  {item.modelUsed && (
                    <div>
                      <p className="text-sm font-medium text-secondary-500">Model Used</p>
                      <p className="text-sm text-secondary-900 mt-1">{item.modelUsed}</p>
                    </div>
                  )}
                  {item.key && (<div className="md:col-span-1"><p className="text-sm font-medium text-secondary-500">Item Key</p><p className="text-sm text-secondary-900 mt-1 break-words">{item.key}</p></div>)}
                  {item.additionalContext && (<div className="md:col-span-2"><p className="text-sm font-medium text-secondary-500">Additional Context</p><p className="text-sm text-secondary-900 mt-1 whitespace-pre-wrap">{item.additionalContext}</p></div>)}
                  {item.error && (
                    <div className="md:col-span-2">
                      <p className={`text-sm font-medium ${isInformationalError(item.error) ? 'text-yellow-600' : 'text-red-600'}`}>Error/Note</p>
                      <p className={`text-sm mt-1 ${isInformationalError(item.error) ? 'text-yellow-700' : 'text-red-700'}`}>{item.error}</p>
                    </div>
                  )}
                </div>
              </div>
              <div>
                <h4 className="text-lg font-medium text-secondary-900 mb-3">Classification Result</h4>
                <div className="bg-secondary-50 rounded-lg p-4">
                  <div className="space-y-3">
                    {Object.entries(item.levels || {}).sort(([aCode], [bCode]) => {
                        const orderA = levelOrder[aCode.toLowerCase()] ?? levelOrder['default'];
                        const orderB = levelOrder[bCode.toLowerCase()] ?? levelOrder['default'];
                        return orderA - orderB || aCode.localeCompare(bCode);
                      }).map(([levelCode, category]) => {
                        const typedCategory = category as CategoryLevel; 
                        return (
                          <div key={levelCode} className="pb-3 border-b border-secondary-200 last:border-b-0 last:pb-0">
                            <div className="flex justify-between items-start">
                              <div>
                                <p className="text-sm font-medium text-secondary-700">{getLevelName(levelCode)}</p>
                                <p className="text-base font-medium text-secondary-900 mt-1">{typedCategory.code} - {typedCategory.name}</p>
                                {typedCategory.description && typedCategory.description !== typedCategory.name && (<p className="text-sm text-secondary-600 mt-1">{typedCategory.description}</p>)}
                              </div>
                              {typedCategory.error && (<span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800 border border-red-200">Error</span>)}
                            </div>
                            {typedCategory.error && (<p className="text-sm text-red-600 mt-2">{typedCategory.error}</p>)}
                            {item.levelResponses?.[levelCode] && (
                              <div className="mt-2 pl-4 border-l-2 border-secondary-200">
                                <div className="flex items-center"><p className="text-xs font-medium text-secondary-500 mb-1 mr-2">LLM Rationale:</p>
                                  <button className="text-xs text-primary-600 hover:text-primary-800 underline" onClick={() => { setActiveTab('llm'); setActiveLlmTab(levelCode);}}>View Full Response</button>
                                </div>
                                <div className="text-sm text-secondary-700 line-clamp-3">{renderMarkdown(item.levelResponses[levelCode])}</div>
                              </div>
                            )}
                          </div>);})}
                    {(!item.levels || Object.keys(item.levels).length === 0) && (<p className="text-sm text-secondary-500 italic">No classification levels available.</p>)}
                  </div></div></div></div>
          )}
          
          {activeTab === 'rag' && ( 
            <div>
              <div className="flex items-center justify-between mb-4">
                <h4 className="text-lg font-medium text-secondary-900">RAG Context</h4>
                {item.ragContextUsed ? (<span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 border border-green-200">Used</span>)
                : (<span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800 border border-gray-200">Not Used</span>)}
              </div>
              <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-96"> {/* Added max-h-96 */}
                {item.ragContext ? (<div className="text-sm text-secondary-900 font-mono whitespace-pre-wrap">{formatRagContext(item.ragContext)}</div>)
                : (<p className="text-sm text-secondary-500 italic">No RAG context available</p>)}
              </div></div>
          )}
          
          {activeTab === 'llm' && ( 
             <div>
              <h4 className="text-lg font-medium text-secondary-900 mb-3">LLM Responses by Level</h4>
              {sortedLevelCodesForTabs.length > 0 && item.levelResponses ? (
                <div>
                  <div className="border-b border-secondary-200 mb-4">
                    <nav className="flex -mb-px space-x-4 overflow-x-auto">
                      {sortedLevelCodesForTabs.map((levelCode) => (
                        item.levelResponses?.[levelCode] && // Only show tab if response exists
                        <button key={`llm-tab-${levelCode}`} onClick={() => setActiveLlmTab(levelCode)}
                          className={`py-2 px-1 font-medium text-sm border-b-2 whitespace-nowrap ${activeLlmTab === levelCode ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
                        >{getLevelName(levelCode)}</button>
                      ))}
                    </nav>
                  </div>
                  <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-80">
                    {sortedLevelCodesForTabs.map((levelCode) => (
                      item.levelResponses?.[levelCode] &&
                      <div key={`llm-panel-${levelCode}`} className={`${activeLlmTab === levelCode ? 'block' : 'hidden'}`}>
                        <div className="text-sm text-secondary-900">{renderMarkdown(getLevelResponse(levelCode))}</div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : (<div className="bg-secondary-50 rounded-lg p-6 text-center"><p className="text-sm text-secondary-500">No LLM responses available.</p></div>)}
            </div>
          )}

          {activeTab === 'prompt' && ( 
            <div>
              <h4 className="text-lg font-medium text-secondary-900 mb-3">Prompts by Level</h4>
              {parsedPrompts && sortedLevelCodesForTabs.length > 0 ? (
                <div>
                  <div className="border-b border-secondary-200 mb-4">
                    <nav className="flex -mb-px space-x-4 overflow-x-auto">
                      {sortedLevelCodesForTabs.map((levelCode) => (
                         parsedPrompts[levelCode] && 
                        <button key={`prompt-tab-${levelCode}`} onClick={() => setActivePromptTab(levelCode)}
                          className={`py-2 px-1 font-medium text-sm border-b-2 whitespace-nowrap ${activePromptTab === levelCode ? 'border-primary-500 text-primary-600' : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'} transition-colors`}
                        >{getLevelName(levelCode)}</button>
                      ))}
                    </nav>
                  </div>
                  <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-80">
                    {sortedLevelCodesForTabs.map((levelCode) => (
                      parsedPrompts[levelCode] && 
                      <div key={`prompt-panel-${levelCode}`} className={`${activePromptTab === levelCode ? 'block' : 'hidden'}`}>
                        <div className="text-sm text-secondary-900 font-mono whitespace-pre-wrap">
                          {getLevelPrompt(levelCode)}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : item?.firstLevelPrompt ? (
                <div className="bg-secondary-50 rounded-lg p-4 overflow-x-auto max-h-96">
                  <p className="text-sm font-medium text-secondary-700 mb-1">First Level Prompt:</p>
                  <div className="text-sm text-secondary-900 font-mono whitespace-pre-wrap">
                    {item.firstLevelPrompt}
                  </div>
                </div>
              ) : (
                <div className="bg-secondary-50 rounded-lg p-6 text-center">
                  <p className="text-sm text-secondary-500">No prompt details available.</p>
                </div>
              )}
            </div>
          )}
        </div>
        
        {/* Footer */}
        <div className="border-t border-secondary-200 px-6 py-4 flex justify-end sticky bottom-0 bg-white z-10">
          <button onClick={onClose} className="btn btn-secondary">Close</button>
        </div>
      </div>
    </div>
  );
};

export default ClassificationDetailsModal;

File: src/context/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { ApiClient, User } from '../api/types';

// Define the context shape
interface AuthContextType {
  isAuthenticated: boolean;
  user: User | null;
  loading: boolean;
  authEnabled: boolean | null;
  apiClient: ApiClient;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  checkPermission: (permissionCode: string) => boolean;
  handleLoginSuccess: () => void;
}

// Create the context with default values
const AuthContext = createContext<AuthContextType>({
  isAuthenticated: false,
  user: null,
  loading: true,
  authEnabled: null,
  apiClient: {} as ApiClient, // Will be provided in the provider
  login: async () => {},
  logout: () => {},
  checkPermission: () => false,
  handleLoginSuccess: () => {},
});

// Props interface for the provider component
interface AuthProviderProps {
  children: ReactNode;
  apiClientInstance: ApiClient;
}

// Provider component
export const AuthProvider: React.FC<AuthProviderProps> = ({ children, apiClientInstance }) => {
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(apiClientInstance.isLoggedIn());
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [authEnabled, setAuthEnabled] = useState<boolean | null>(null);

  // Function to check if a user has a specific permission
  const checkPermission = (permissionCode: string): boolean => {
    if (!authEnabled) return true; // If auth is disabled, all permissions are allowed
    if (!isAuthenticated || !user) return false; // Not logged in, no permissions
    
    // Check if the user has this specific permission
    return user.permissions?.includes(permissionCode) || false;
  };

  // Login function
  const login = async (username: string, password: string): Promise<void> => {
    try {
      const response = await apiClientInstance.login(username, password);
      setIsAuthenticated(true);
      setUser(response.user);
    } catch (error) {
      console.error("Login failed:", error);
      throw error; // Re-throw to handle in the UI
    }
  };

  // Logout function
  const logout = (): void => {
    apiClientInstance.clearToken();
    setIsAuthenticated(false);
    setUser(null);
  };

  // Handler for successful login (for use with LoginPage)
  const handleLoginSuccess = async (): Promise<void> => {
    setIsAuthenticated(true);
    // Fetch current user details
    try {
      const currentUser = await apiClientInstance.getCurrentUser();
      setUser(currentUser);
    } catch (error) {
      console.error("Failed to fetch user details after login:", error);
    }
  };

  // Effect to check auth configuration on initial load
  useEffect(() => {
    const fetchAuthConfig = async () => {
      setLoading(true);
      try {
        await apiClientInstance.fetchAuthConfig();
        const isAuth = apiClientInstance.isAuthEnabled();
        setAuthEnabled(isAuth);
        
        // If auth is enabled and we're logged in, fetch user data
        if (isAuth && apiClientInstance.isLoggedIn()) {
          try {
            const currentUser = await apiClientInstance.getCurrentUser();
            setUser(currentUser);
            setIsAuthenticated(true);
          } catch (error) {
            console.error("Failed to fetch user details:", error);
            apiClientInstance.clearToken(); // Clear invalid session
            setIsAuthenticated(false);
            setUser(null);
          }
        }
      } catch (error) {
        console.error("Failed to fetch auth config:", error);
        setAuthEnabled(false); // Default to false on error
      } finally {
        setLoading(false);
      }
    };

    fetchAuthConfig();
  }, [apiClientInstance]);

  // The context value
  const contextValue: AuthContextType = {
    isAuthenticated,
    user,
    loading,
    authEnabled,
    apiClient: apiClientInstance,
    login,
    logout,
    checkPermission,
    handleLoginSuccess,
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

// Custom hook to use the auth context
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

File: src/enum/sidebar.enum.ts
// Define the sidebar items enum
export enum SidebarItem {
  HOME = '/', // Often a redirect
  TEST = '/test',
  BATCH = '/batch',
  BATCH_CREATE = '/batch/create', // If you have a separate create page for batch
  BATCH_JOBS = '/batch/jobs',
  HISTORY = '/history',
  CHAT = '/chat', // From your App.tsx
  RAG_INFO = '/rag-info',

  // LangGraph Visualization ---
  LANGGRAPH_LIST = '/langgraph',
  LANGGRAPH_VIEW = '/langgraph/view', // Base path, actual view will be /view/:graphId
  LANGGRAPH_CREATE = '/langgraph/create',
  LANGGRAPH_EDIT = '/langgraph/edit', // If you create an edit page

  // --- ServiceNow (SNOW) ---
  SNOW_BASE = '/snow', // A base key if the parent item is not directly navigable
  SNOW_ANALYZE = '/snow/analyze',
  SNOW_HISTORY = '/snow/history',

  // Admin ---
  ADMIN_USERS = '/admin/users',
  ADMIN_ROLES = '/admin/roles',

  // Bottom Items ---
  SETTINGS = '/settings',
  LOGOUT = 'logout', // Special key, not a URL path
}

File: src/components/MainTabs.tsx
import React, { useState } from 'react';
import { Tab } from '@headlessui/react';
import Settings from './Settings';
import { ApiClient } from '../api/types';
import { ClassificationForm } from './ClassificationForm';
import { HistoryTab } from './HistoryTab';
import BatchTab from './BatchTab/BatchTab';
import { BeakerIcon, DocumentTextIcon, ClockIcon, Cog6ToothIcon } from '@heroicons/react/24/outline';

function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(' ');
}

export interface MainTabsProps {
  apiClient: ApiClient;
}

export const MainTabs: React.FC<MainTabsProps> = ({ apiClient }) => {
  const [selectedIndex, setSelectedIndex] = useState(0);

  const tabs = [
    {
      name: 'Test',
      content: <ClassificationForm apiClient={apiClient} />,
      icon: BeakerIcon
    },
    {
      name: 'Batch',
      content: <BatchTab apiClient={apiClient} />,
      icon: DocumentTextIcon
    },
    {
      name: 'History',
      content: <HistoryTab apiClient={apiClient} />,
      icon: ClockIcon
    },
    {
      name: 'Settings',
      content: <Settings apiClient={apiClient} />,
      icon: Cog6ToothIcon
    },
  ];

  return (
    <div className="flex h-full bg-gray-50/50">
      <Tab.Group as="div" className="flex h-full w-full" vertical selectedIndex={selectedIndex} onChange={setSelectedIndex}>
        <Tab.List className="flex flex-col items-center gap-2 w-48 bg-white/80 backdrop-blur-sm shadow-sm py-6 px-3 m-4 rounded-xl">
          {tabs.map((tab) => {
            const Icon = tab.icon;
            return (
              <Tab
                key={tab.name}
                className={({ selected }) =>
                  classNames(
                    'group flex items-center w-40 gap-3 px-3 py-2 text-sm font-medium rounded-lg outline-none transition-all duration-200',
                    'focus:ring-1 focus:ring-offset-1 focus:ring-primary-200/30',
                    selected
                      ? 'text-primary-600 bg-primary-50/50 shadow-sm ring-1 ring-primary-100/50'
                      : 'text-secondary-400 hover:text-secondary-700 hover:bg-secondary-50/50 hover:shadow-sm'
                  )
                }
              >
                <Icon className={classNames(
                  'w-4 h-4 transition-all duration-200',
                  'group-hover:scale-105 group-hover:rotate-2'
                )} />
                {tab.name}
              </Tab>
            );
          })}
        </Tab.List>
        <Tab.Panels className="flex-1">
          {tabs.map((tab, idx) => (
            <Tab.Panel key={idx} className="h-full">
              <div className="h-full">
                {tab.content}
              </div>
            </Tab.Panel>
          ))}
        </Tab.Panels>
      </Tab.Group>
    </div>
  );
};

export default MainTabs;

File: src/components/LoginForm.tsx
import React, { useState, FormEvent } from 'react';
import { ApiClient, LoginResponse, User } from '../api/types'; // Updated import to include LoginResponse and User types

interface LoginFormProps {
    apiClient: ApiClient;
    onLoginSuccess: () => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ apiClient, onLoginSuccess }) => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        setError(null);
        setLoading(true);

        try {
            const response: LoginResponse = await apiClient.login(username, password); // Assuming login method exists
            console.log('Login successful:', response.user);

            // Store the token (e.g., in localStorage)
            if (response.token) {
                localStorage.setItem('authToken', response.token); // Store the token
                localStorage.setItem('userInfo', JSON.stringify(response.user)); // Store user info
                onLoginSuccess(); // Callback to notify App.tsx
            } else {
                setError('Login failed: No token received.');
            }
        } catch (err) {
            console.error('Login error:', err);
            setError(err instanceof Error ? err.message : 'Login failed. Please check your credentials.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-6">
            {error && (
                <div className="rounded-md border border-red-200 bg-red-50 p-3 text-sm text-red-700">
                    {error}
                </div>
            )}
            <div>
                <label htmlFor="username" className="label">
                    Username
                </label>
                <input
                    id="username"
                    type="text"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    required
                    className="input" // Use global style
                    disabled={loading}
                    autoComplete="username"
                />
            </div>
            <div>
                <label htmlFor="password" className="label">
                    Password
                </label>
                <input
                    id="password"
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    required
                    className="input" // Use global style
                    disabled={loading}
                    autoComplete="current-password"
                />
            </div>
            <div>
                <button
                    type="submit"
                    className="w-full btn btn-primary" // Use global styles
                    disabled={loading}
                >
                    {loading ? 'Logging in...' : 'Login'}
                </button>
            </div>
        </form>
    );
};

export default LoginForm;

File: src/components/RerunStatusModal.tsx
import React from 'react';

interface RerunStatusModalProps {
  isOpen: boolean;
  description: string;
}

export const RerunStatusModal: React.FC<RerunStatusModalProps> = ({ isOpen, description }) => {
  if (!isOpen) {
    return null;
  }

  return (
    <div className="fixed inset-0 flex items-center justify-center z-50">
      <div className="fixed inset-0 bg-black opacity-30"></div>
      <div className="relative bg-white rounded-lg p-6 max-w-md w-full mx-4">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600 mx-auto mb-4"></div>
          <h3 className="text-lg font-medium text-secondary-900 mb-2">
            Rerunning Classification
          </h3>
          <p className="text-sm text-secondary-600 mb-4">
            {description}
          </p>
          <p className="text-xs text-secondary-500">
            This may take a few moments...
          </p>
        </div>
      </div>
    </div>
  );
};

export default RerunStatusModal;

File: src/components/ClassificationForm.tsx
import React, { useState, useEffect, ChangeEvent, FormEvent } from 'react';
import { InformationCircleIcon } from '@heroicons/react/24/outline'; // Import icon
import ReactMarkdown from 'react-markdown';
import {
  ApiClient,
  ClassificationResult,
  ClassificationSystem,
  ClassificationLevel,
  ManualClassificationRequest,
} from '../api/types';
import { ManualClassificationModal } from './ManualClassificationModal';
import { useAuth } from '../context/AuthContext'; // Import useAuth hook

interface ClassificationFormProps {
  apiClient: ApiClient;
  onResult?: (result: ClassificationResult) => void;
  onError?: (error: Error) => void;
}

export const ClassificationForm: React.FC<ClassificationFormProps> = ({
  apiClient,
  onResult,
  onError,
}) => {
  const { checkPermission } = useAuth(); // Get permission checker from auth context
  const [description, setDescription] = useState('');
  const [additionalContext, setAdditionalContext] = useState('');
  const [selectedSystem, setSelectedSystem] = useState<string>('UNSPSC');
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<ClassificationResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [systems, setSystems] = useState<ClassificationSystem[]>([]);
  const [systemLevels, setSystemLevels] = useState<ClassificationLevel[]>([]);
  
  // State for model selection
  const [availableModels, setAvailableModels] = useState<string[]>([]);
  const [selectedModel, setSelectedModel] = useState<string>('');
  
  // Modal state
  const [showModal, setShowModal] = useState(false);
  
  // Active tab for LLM responses
  const [activeLlmTab, setActiveLlmTab] = useState<string | null>(null);
  
  // Level-specific LLM responses
  const [levelResponses, setLevelResponses] = useState<{[key: string]: string}>({});

  useEffect(() => {
    const loadSystems = async () => {
      try {
        const availableSystems = await apiClient.getClassificationSystems();
        setSystems(availableSystems);
        if (availableSystems.length > 0 && !selectedSystem) {
          setSelectedSystem(availableSystems[0].code);
        }
      } catch (error) {
        console.error('Failed to load classification systems:', error);
        setError('Failed to load classification systems');
      }
    };
    loadSystems();
  }, [apiClient]);

  useEffect(() => {
    const loadSystemLevels = async () => {
      if (!selectedSystem) return;
      try {
        const response = await apiClient.getClassificationSystem(selectedSystem);
        setSystemLevels(response.levels || []);
      } catch (error) {
        console.error('Failed to load system levels:', error);
        setError('Failed to load system levels');
      }
    };
    loadSystemLevels();
  }, [apiClient, selectedSystem]);

  // Load available LLM models from config
  useEffect(() => {
    const loadModels = async () => {
      try {
        const config = await apiClient.getConfig();
        const models = [];
        
        // Add the main model
        if (config.service?.llmModel) {
          models.push(config.service.llmModel);
        }
        
        // Add retry models if available
        if (config.service?.llmRetryModels && Array.isArray(config.service.llmRetryModels)) {
          models.push(...config.service.llmRetryModels);
        }
        
        setAvailableModels(models);
        // Set the default model to the main one
        if (models.length > 0) {
          setSelectedModel(models[0]);
        }
      } catch (error) {
        console.error('Failed to load LLM models:', error);
      }
    };
    loadModels();
  }, [apiClient]);

  // Set the active LLM tab when results are received
  useEffect(() => {
    if (result && systemLevels.length > 0) {
      // Find the first level with results
      const firstLevelCode = Object.keys(result.levels)[0] || systemLevels[0].code;
      setActiveLlmTab(firstLevelCode);
      
      // Check if the backend provided level-specific responses
      if (result.levelResponses && Object.keys(result.levelResponses).length > 0) {
        setLevelResponses(result.levelResponses);
      }
    }
  }, [result, systemLevels]);
  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    
    // Clear previous results when starting a new classification
    setResult(null);
    setLevelResponses({});
    
    try {
      const classificationResult = await apiClient.classify(description, selectedSystem, additionalContext, selectedModel);
      setResult(classificationResult);
      
      // Check if the backend already provided level-specific responses
      if (classificationResult.levelResponses && Object.keys(classificationResult.levelResponses).length > 0) {
        setLevelResponses(classificationResult.levelResponses);
      }
      
      onResult?.(classificationResult);
    } catch (error) {
      let errorMessage = 'Classification failed';
      if (error instanceof Error) {
        if (error.message.includes('OpenRouter API request failed')) {
          errorMessage = 'LLM Service Authentication Error - Please check API configuration';
        } else {
          errorMessage = error.message;
        }
      }
      setError(errorMessage);
      onError?.(error instanceof Error ? error : new Error(errorMessage));
    } finally {
      setLoading(false);
    }
  };

  const handleDescriptionChange = (e: ChangeEvent<HTMLTextAreaElement>) => {
    setDescription(e.target.value);
    setError(null);
  };

  const handleSystemChange = (e: ChangeEvent<HTMLSelectElement>) => {
    setSelectedSystem(e.target.value);
    setError(null);
    setResult(null);
    setLevelResponses({});
  };
  const handleManualClassification = async (manualResult: ClassificationResult) => {
    try {
      // Prepare the request payload according to ManualClassificationRequest interface
      const requestPayload: ManualClassificationRequest = {
        description: description,
        systemCode: selectedSystem,
        selectedSystem: selectedSystem, // As per interface, using selectedSystem state
        additionalContext: additionalContext,
        modelOverride: selectedModel, // Pass the selected model to the manual classification
        levels: Object.fromEntries(
          Object.entries(manualResult.levels).map(([levelCode, categoryLevel]) => [
            levelCode,
            categoryLevel.code, // Extract the code string
          ])
        ),
      };

      const updatedResult = await apiClient.classifyManually(requestPayload);
      console.log("Manual classification result:", updatedResult);
      setResult(updatedResult);

      // Use level-specific responses from the result if available
      if (updatedResult.levelResponses && Object.keys(updatedResult.levelResponses).length > 0) {
        setLevelResponses(updatedResult.levelResponses);
      }

      onResult?.(updatedResult);
    } catch (error) {
      console.error("Failed to save manual classification:", error);
      setError("Failed to save manual classification. Please try again.");
      onError?.(error instanceof Error ? error : new Error("Failed to save manual classification."));
    }
  };

  const getLevelClasses = (index: number): {bg: string, text: string} => {
    const colorClasses = [
      { bg: 'bg-blue-50', text: 'text-blue-600' },
      { bg: 'bg-indigo-50', text: 'text-indigo-600' },
      { bg: 'bg-purple-50', text: 'text-purple-600' },
      { bg: 'bg-pink-50', text: 'text-pink-600' },
      { bg: 'bg-rose-50', text: 'text-rose-600' },
      { bg: 'bg-orange-50', text: 'text-orange-600' },
      { bg: 'bg-amber-50', text: 'text-amber-600' },
      { bg: 'bg-emerald-50', text: 'text-emerald-600' }
    ];
    return colorClasses[index % colorClasses.length];
  };

  // Render markdown content
  const renderMarkdown = (content: string) => {
    return (
      <div className="text-xs text-secondary-600 whitespace-pre-wrap prose prose-sm max-w-none">
        <ReactMarkdown>
          {content}
        </ReactMarkdown>
      </div>
    );
  };

  const getStatusBadge = (status: 'success' | 'partial' | 'failed' | 'all') => {
    const classes = {
      success: 'bg-green-100 text-green-800 border-green-200',
      partial: 'bg-yellow-100 text-yellow-800 border-yellow-200',
      failed: 'bg-red-100 text-red-800 border-red-200',
      all: 'bg-blue-100 text-blue-800 border-blue-200'
    };
    
    const labels = {
      success: 'Success',
      partial: 'Partial',
      failed: 'Failed',
      all: 'Complete'
    };

    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${classes[status]}`}>
        {labels[status]}
      </span>
    );
  };

  return (
    <div className="max-w-8xl mx-auto space-y-10" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
      <div className="bg-white shadow-card rounded-card p-8 w-full" style={{ paddingRight: '5rem', paddingLeft: '3rem'}}>
        <form onSubmit={handleSubmit} className="space-y-6">          <div className="flex flex-col md:flex-row md:space-x-6 md:space-y-0 space-y-6">
            <div className="space-y-2 flex-1">
              <label htmlFor="system" className="block text-sm font-medium text-secondary-700">
                Classification System:
              </label>
              <select
                id="system"
                value={selectedSystem}
                onChange={handleSystemChange}
                className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                style={{ paddingRight: '1rem', paddingLeft: '1rem'}}
              >
                {systems.map(system => (
                  <option key={system.code} value={system.code}>
                    {system.name}
                  </option>
                ))}
              </select>
            </div>

            <div className="space-y-2 flex-1">
              <label htmlFor="model" className="block text-sm font-medium text-secondary-700">
                LLM Model:
              </label>
              <select
                id="model"
                value={selectedModel}
                onChange={(e) => setSelectedModel(e.target.value)}
                className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                style={{ paddingRight: '1rem', paddingLeft: '1rem'}}
                disabled={loading || availableModels.length <= 1}
              >
                {availableModels.map(model => (
                  <option key={model} value={model}>
                    {model}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="space-y-2">
            <label htmlFor="description" className="block text-sm font-medium text-secondary-700">
              Product Description:
            </label>
            <textarea
              id="description"
              value={description}
              onChange={handleDescriptionChange}
              required
              rows={4}
              className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
              placeholder="Enter product description..."
            />
          </div>

          <div className="space-y-2">
            <label htmlFor="additionalContext" className="block text-sm font-medium text-secondary-700">
              Additional Context (Optional):
            </label>
            <textarea
              id="additionalContext"
              value={additionalContext}
              onChange={(e) => setAdditionalContext(e.target.value)}
              rows={3}
              className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
              placeholder="Enter any additional context that might help with classification..."
            />
          </div>

          {error && (
            <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3 text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="flex justify-end">
            <button
              className={`px-6 py-3 rounded-lg font-medium text-white ${
                loading || description.trim() === '' || !checkPermission('classify:item')
                  ? 'bg-gray-400 cursor-not-allowed'
                  : 'bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2'
              }`}
              type="submit"
              disabled={loading || description.trim() === '' || !checkPermission('classify:item')}
              data-testid="classify-button"
              title={!checkPermission('classify:item') ? "You don't have permission to classify items" : ""}
            >
              {loading ? 'Classifying...' : 'Classify'}
            </button>
          </div>

          {!checkPermission('classify:item') && (
            <div className="p-4 border border-yellow-200 bg-yellow-50 rounded-md mt-4">
              <p className="text-yellow-800 text-sm">
                You don't have permission to perform classifications. Please contact your administrator.
              </p>
            </div>
          )}
        </form>
      </div>

      {result && (
        <div className="bg-white shadow-card rounded-card p-8 w-full">
          <div className="flex justify-between items-center mb-8">
            <div className="flex items-center gap-3">
              <h3 className="text-xl font-semibold text-secondary-900">
                Classification Results - {result.system_code}
              </h3>
              {getStatusBadge(result.status)}
            </div>
            <button
              onClick={() => setShowModal(true)}
              className="group relative inline-flex items-center gap-1.5 px-4 py-2.5 bg-white text-sm font-medium text-secondary-700 border border-secondary-200 rounded-lg hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm"
            >
              <svg 
                className="w-4 h-4 text-secondary-500 group-hover:text-secondary-700 transition-colors" 
                fill="none" 
                viewBox="0 0 24 24" 
                stroke="currentColor"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth={2} 
                  d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" 
                />
              </svg>
              <span>Edit Classification</span>
              <div className="absolute inset-0 rounded-lg overflow-hidden">
                <div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div>
              </div>
            </button>
          </div>

          {result.error && (
            <div className="mb-6 rounded-lg border border-yellow-200 bg-yellow-50/50 px-4 py-3 text-yellow-800 text-sm">
              <p className="font-medium">Classification completed with issues:</p>
              <p className="mt-1">{result.error}</p>
            </div>
          )}
          
          {/* Display the model used for classification */}
          {result.modelUsed && (
            <div className="mb-6 rounded-lg border border-blue-200 bg-blue-50/50 px-4 py-3 text-blue-800 text-sm">
              <p className="font-medium">Model Used:</p>
              <p className="mt-1">{result.modelUsed}</p>
            </div>
          )}
          
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            {/* Only show UNSPSC Type for UNSPSC system with valid segment classification */}
            {result.system_code === 'UNSPSC' && result.levels?.segment?.code && (
              <div className="lg:col-span-2 bg-white rounded-lg border border-secondary-200 p-6 shadow-sm">
                <div className="flex items-start space-x-4">
                  <div className="bg-primary-50 w-14 h-14 flex items-center justify-center rounded-xl shadow-sm">
                    <svg className="w-7 h-7 text-primary-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                    </svg>
                  </div>
                  <div className="flex-1 min-w-0">
                    <label className="block text-sm font-medium text-secondary-900 mb-1">UNSPSC Type</label>
                    <div className="flex items-center gap-2">
                      {/* UNSPSC Type based on segment code */}
                      {['1', '2', '3', '4'].some(prefix => result.levels.segment?.code?.startsWith(prefix)) ? (
                        <span className="bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded-full">GOOD</span>
                      ) : ['7', '8', '9'].some(prefix => result.levels.segment?.code?.startsWith(prefix)) ? (
                        <span className="bg-purple-100 text-purple-800 text-xs font-medium px-2.5 py-0.5 rounded-full">SERVICE</span>
                      ) : ['5', '6'].some(prefix => result.levels.segment?.code?.startsWith(prefix)) ? (
                        <span className="bg-amber-100 text-amber-800 text-xs font-medium px-2.5 py-0.5 rounded-full">OTHER</span>
                      ) : (
                        <span className="bg-gray-100 text-gray-800 text-xs font-medium px-2.5 py-0.5 rounded-full">UNCLASSIFIED</span>
                      )}
                      <span className="text-sm text-secondary-600">
                        {result.levels.segment ? `Based on segment code ${result.levels.segment.code}` : 'Segment not classified'}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            )}
            {systemLevels.map((level, index) => {
              const categoryLevel = result.levels[level.code];
              const colors = getLevelClasses(index);

              // If no categoryLevel exists for this level
              if (!categoryLevel) {
                return (
                  <div key={level.code} className="bg-white rounded-lg border border-red-200 p-6 shadow-sm hover:shadow-md transition-shadow">
                    <div className="flex items-start space-x-4">
                      <div className="bg-red-50 w-14 h-14 flex items-center justify-center rounded-xl shadow-sm shrink-0">
                        <span className="text-red-600 font-bold text-lg">
                          {String(index + 1).padStart(2, '0')}
                        </span>
                      </div>
                      <div className="flex-1 min-w-0">
                        <label className="block text-sm font-medium text-secondary-900 mb-1">{level.name}</label>
                        <div className="text-red-600 text-sm">
                          Failed to classify at this level
                        </div>
                      </div>
                    </div>
                  </div>
                );
              }
              
              return (
                <div key={level.code} className="bg-white rounded-lg border border-secondary-200 p-6 shadow-sm hover:shadow-md transition-shadow">
                  <div className="flex items-start space-x-4">
                    <div className={`${colors.bg} w-14 h-14 flex items-center justify-center rounded-xl shadow-sm shrink-0`}>
                      <span className={`${colors.text} font-bold text-lg`}>
                        {String(index + 1).padStart(2, '0')}
                      </span>
                    </div>
                    <div className="flex-1 min-w-0">
                      <label className="block text-sm font-medium text-secondary-900 mb-1">{level.name}</label>
                      <div className="space-y-1">
                        {categoryLevel.code === "NO_MATCH" ? (
                          <div className="text-red-600 font-medium text-sm">
                            No matching category found at this level
                          </div>
                        ) : (
                          <>
                            <div className="text-sm font-semibold text-secondary-800">{categoryLevel.code}</div>
                            <div className="text-sm text-secondary-600">{categoryLevel.name}</div>
                            {categoryLevel.description && categoryLevel.description !== categoryLevel.name && (
                              <div className="text-xs text-secondary-500 mt-1.5">{categoryLevel.description}</div>
                            )}
                            {categoryLevel.error && (
                              <div className="text-amber-600 text-xs mt-1.5">
                                {categoryLevel.error}
                              </div>
                            )}
                          </>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>

          {/* RAG Context Display Section */}
          {result.ragContextUsed && (
            <div className="mt-6 pt-4 border-t border-secondary-200">
              <div className="flex items-center space-x-2 mb-2">
                <InformationCircleIcon className="h-5 w-5 text-blue-500" />
                <h4 className="text-sm font-medium text-secondary-700">
                  Context Used for Classification (from RAG)
                </h4>
              </div>
              <div className="text-xs bg-secondary-50 border border-secondary-200 rounded p-3 max-h-40 overflow-y-auto">
                <pre className="whitespace-pre-wrap font-mono text-secondary-600">
                  {result.ragContext || 'No specific context text available.'}
                </pre>
              </div>
            </div>
          )}

          {/* LLM Response Tabs */}
          {((result.levelResponses && Object.keys(result.levelResponses).length > 0) || Object.keys(levelResponses).length > 0) && (
            <div className="mt-6 pt-4 border-t border-secondary-200">
              <div className="flex items-center space-x-2 mb-2">
                <h4 className="text-sm font-medium text-secondary-700">
                  LLM Response by Level
                </h4>
              </div>
              
              {/* Tab Navigation */}
              <div className="border-b border-secondary-200">
                <nav className="flex -mb-px space-x-6 overflow-x-auto">
                  {systemLevels.filter(level => result.levels[level.code]).map((level) => (
                    <button
                      key={level.code}
                      onClick={() => setActiveLlmTab(level.code)}
                      className={`py-2 px-1 font-medium text-sm border-b-2 whitespace-nowrap ${
                        activeLlmTab === level.code
                          ? 'border-primary-500 text-primary-600'
                          : 'border-transparent text-secondary-500 hover:text-secondary-700 hover:border-secondary-300'
                      } transition-colors duration-200`}
                    >
                      {level.name} Classification
                    </button>
                  ))}
                </nav>
              </div>
              
              {/* Tab Panels */}
              <div className="mt-3">
                {systemLevels.filter(level => result.levels[level.code]).map((level) => (
                  <div 
                    key={level.code}
                    className={`${activeLlmTab === level.code ? 'block' : 'hidden'} text-xs bg-secondary-50 border border-secondary-200 rounded p-3 max-h-60 overflow-y-auto`}
                  >
                    {renderMarkdown(levelResponses[level.code] || 'No LLM response available for this level.')}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}

      <ManualClassificationModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        onSubmit={handleManualClassification}
        apiClient={apiClient}
        description={description}
        systemCode={selectedSystem}
        initialLevels={result?.levels ? Object.fromEntries(
          Object.entries(result.levels).map(([code, category]) => [code, category.code])
        ) : undefined}
      />
    </div>
  );
};


File: src/components/StatusTypesDemo.tsx
// src/components/StatusTypesDemo.tsx
import React, { useState } from 'react';
import { Card, Tabs, Tag, Typography, Alert, Space, Button } from 'antd';
import { 
  CheckCircleOutlined, 
  CloseCircleOutlined, 
  WarningOutlined
} from '@ant-design/icons';
import StatusTypeGuide from './StatusTypeGuide';
import StatusTypeTooltip from './StatusTypeTooltip';
import { ClassificationStatus } from '../api/types';
import { SnowValidationStatus } from '../snow/types/snow.types';
import { 
  getClassificationStatusColor,
  getSnowValidationStatusColor,
  getClassificationStatusDescription,
  getSnowValidationStatusDescription
} from '../utils/statusUtils';

const { Title, Paragraph, Text } = Typography;
const { TabPane } = Tabs;

/**
 * Status Types Demo Component
 * 
 * This is a demonstration component showing how to properly use the different status types,
 * tooltip helpers, and utilities throughout the application.
 * 
 * It demonstrates:
 * 1. How to use both status types in UI elements
 * 2. How to use the StatusTypeTooltip for inline help
 * 3. How to integrate the StatusTypeGuide as a reference
 */
const StatusTypesDemo: React.FC = () => {
  const [activeTab, setActiveTab] = useState<string>('usage');
  const [showFullGuide, setShowFullGuide] = useState<boolean>(false);

  // Example Categorization statuses
  const categorizationStatuses: ClassificationStatus[] = ['success', 'partial', 'failed', 'all'];
  // Example SNOW statuses
  const snowStatuses: SnowValidationStatus[] = ['pass', 'fail'];

  const renderStatusTag = (status: ClassificationStatus) => {
    const icons = {
      success: <CheckCircleOutlined />,
      partial: <WarningOutlined />,
      failed: <CloseCircleOutlined />,
      all: null
    };
    
    return (
      <Tag 
        icon={icons[status]} 
        color={getClassificationStatusColor(status)}
      >
        {status}
      </Tag>
    );
  };

  const renderSnowStatusTag = (status: SnowValidationStatus) => {
    const icons = {
      pass: <CheckCircleOutlined />,
      fail: <CloseCircleOutlined />
    };
    
    return (
      <Tag 
        icon={icons[status]} 
        color={getSnowValidationStatusColor(status)}
      >
        {status}
      </Tag>
    );
  };

  return (
    <Card className="status-types-demo">
      <Title level={3}>
        Status Types Demo
        <StatusTypeTooltip type="classification" />
      </Title>
      
      <Tabs activeKey={activeTab} onChange={setActiveTab}>
        <TabPane tab="Usage Examples" key="usage">
          <Card title={<Space>Categorization Status Types <StatusTypeTooltip type="classification" /></Space>} size="small" className="mb-4">
            <Space direction="vertical" className="w-full">
              <Paragraph>
                The Categorization system uses the following status types to indicate the result of classification:
              </Paragraph>
              
              <Space wrap>
                {categorizationStatuses.map(status => (
                  <div key={status} className="border rounded p-2">
                    {renderStatusTag(status)}
                    <Text className="ml-2">{getClassificationStatusDescription(status)}</Text>
                  </div>
                ))}
              </Space>
              
              <Alert 
                type="info" 
                message="Example Usage" 
                description={
                  <Text code>
                    {`import { ClassificationStatus } from '../api/types';`}<br />
                    {`const [selectedStatus, setSelectedStatus] = useState<ClassificationStatus>('all');`}
                  </Text>
                } 
              />
            </Space>
          </Card>
          
          <Card title={<Space>ServiceNow Status Types <StatusTypeTooltip type="snow" /></Space>} size="small">
            <Space direction="vertical" className="w-full">
              <Paragraph>
                The ServiceNow system uses the following validation result statuses:
              </Paragraph>
              
              <Space wrap>
                {snowStatuses.map(status => (
                  <div key={status} className="border rounded p-2">
                    {renderSnowStatusTag(status)}
                    <Text className="ml-2">{getSnowValidationStatusDescription(status)}</Text>
                  </div>
                ))}
              </Space>
              
              <Alert 
                type="info" 
                message="Example Usage" 
                description={
                  <Text code>
                    {`import { SnowValidationStatus } from '../snow/types/snow.types';`}<br />
                    {`const validationResult: SnowValidationStatus = result.validation_result;`}
                  </Text>
                } 
              />
            </Space>
          </Card>
          
          <div className="mt-4">
            <Button type="primary" onClick={() => setShowFullGuide(!showFullGuide)}>
              {showFullGuide ? 'Hide' : 'Show'} Complete Reference Guide
            </Button>
          </div>
          
          {showFullGuide && (
            <div className="mt-4">
              <StatusTypeGuide />
            </div>
          )}
        </TabPane>
        
        <TabPane tab="Tooltip Integration" key="tooltip">
          <Card title="How to Use Status Type Tooltips" size="small">
            <Paragraph>
              Add helpful tooltips to your UI to explain status types to users:
            </Paragraph>
            
            <Alert
              message="Import and Use in Components"
              description={
                <Text code>
                  {`import StatusTypeTooltip from '../components/StatusTypeTooltip';`}<br /><br />
                  {`// In classification-related UI:`}<br />
                  {`<Title>Classification Status <StatusTypeTooltip type="classification" /></Title>`}<br /><br />
                  {`// In SNOW-related UI:`}<br />
                  {`<Title>Validation Status <StatusTypeTooltip type="snow" /></Title>`}
                </Text>
              }
              type="info"
            />
            
            <div className="mt-4">
              <Paragraph strong>Live examples:</Paragraph>
              <div className="border rounded p-3 mb-2">
                <Text>Categorization Status</Text> <StatusTypeTooltip type="classification" /> <Text> - Hover to see details</Text>
              </div>
              <div className="border rounded p-3">
                <Text>ServiceNow Validation Status</Text> <StatusTypeTooltip type="snow" /> <Text> - Hover to see details</Text>
              </div>
            </div>
          </Card>
        </TabPane>
        
        <TabPane tab="Utility Functions" key="utils">
          <Card title="Status Utility Functions" size="small">
            <Paragraph>
              The <Text code>src/utils/statusUtils.ts</Text> file provides utility functions for working with status types:
            </Paragraph>
            
            <Alert
              message="Available Functions"
              description={
                <ul>
                  <li><Text code>isInformationalError(message: string): boolean</Text> - Checks if an error message is an "informational" status message</li>
                  <li><Text code>getClassificationStatusColor(status: ClassificationStatus): string</Text> - Gets a color for a categorization status</li>
                  <li><Text code>getSnowValidationStatusColor(status: SnowValidationStatus): string</Text> - Gets a color for a SNOW validation status</li>
                  <li><Text code>getClassificationStatusDescription(status: ClassificationStatus): string</Text> - Gets human-readable text for a categorization status</li>
                  <li><Text code>getSnowValidationStatusDescription(status: SnowValidationStatus): string</Text> - Gets human-readable text for a SNOW validation status</li>
                </ul>
              }
              type="info"
            />
            
            <Alert
              className="mt-4"
              message="Usage Example"
              description={
                <Text code>
                  {`import { getClassificationStatusColor } from '../utils/statusUtils';`}<br />
                  {`<Tag color={getClassificationStatusColor(item.status)}>{item.status}</Tag>`}
                </Text>
              }
              type="success"
            />
          </Card>
        </TabPane>
      </Tabs>
    </Card>
  );
};

export default StatusTypesDemo;


File: src/components/Sidebar/LeftSidebarItem.component.tsx
// src/components/Sidebar/LeftSidebarItem.component.tsx
import React from 'react';
import { NavLink } from 'react-router-dom';
import { Badge } from 'antd';
import { LeftSidebarItem as LeftSidebarItemType } from './LeftSidebar.interface';

interface LeftSidebarItemProps {
  data: LeftSidebarItemType;
}

const LeftSidebarItem: React.FC<LeftSidebarItemProps> = ({
  data: { title, redirect_url, dataTestId, icon: Icon, isBeta, onClick },
}) => {

  // Label and optional badge content
  const labelContent = (
    <>
      {/* This span's visibility/opacity is controlled by CSS */}
      <span className="left-panel-label">{title}</span>
      {isBeta && (
        <Badge
          className="service-beta-tag ml-1" // Add small margin if needed
          count="Beta"
          size="small"
        />
      )}
    </>
  );

  // The icon is now rendered by the parent Antd Menu.
  // This component only provides the content for the 'label' prop.
  // We render either a NavLink or a button *containing* the label content.

  return redirect_url ? (
    <NavLink
      className={({ isActive }) =>
        // Link itself shouldn't need complex flex styles now
        `left-panel-item-link block w-full ${isActive ? 'active' : ''}`
      }
      data-testid={dataTestId}
      to={redirect_url}
      title={title} // Add title attribute for accessibility on hover
    >
      {labelContent}
    </NavLink>
  ) : (
    <button
      className="left-panel-item-button block w-full text-left bg-transparent border-none cursor-pointer p-0"
      data-testid={dataTestId}
      type="button"
      onClick={onClick}
      title={title} // Add title attribute for accessibility on hover
    >
      {labelContent}
    </button>
  );
};

export default LeftSidebarItem;

File: src/components/StatusTypeTooltip.tsx
// src/components/StatusTypeTooltip.tsx
import React from 'react';
import { Tooltip, Typography } from 'antd';
import { InfoCircleOutlined } from '@ant-design/icons';

const { Text } = Typography;

interface StatusTypeTooltipProps {
  type: 'classification' | 'snow';
  className?: string;
}

/**
 * A simple tooltip component to explain the different status types
 * used in the application for both Categorization and ServiceNow systems.
 * This can be easily added to forms, tables, or other UI elements where
 * status types are displayed.
 */
const StatusTypeTooltip: React.FC<StatusTypeTooltipProps> = ({ type, className }) => {
  const tooltipContent = type === 'classification' ? (
    <div>
      <Text strong>Categorization Status Types:</Text>
      <ul style={{ paddingLeft: '20px', margin: '5px 0' }}>
        <li><Text type="success">success</Text> - Classification fully completed with all required levels</li>
        <li><Text type="warning">partial</Text> - Classification is partial with some levels missing or invalid</li>
        <li><Text type="danger">failed</Text> - Classification failed to determine required levels</li>
      </ul>
      <Text>See docs/STATUS_TYPES.md for more details</Text>
    </div>
  ) : (
    <div>
      <Text strong>ServiceNow Validation Status:</Text>
      <ul style={{ paddingLeft: '20px', margin: '5px 0' }}>
        <li><Text type="success">pass</Text> - Ticket meets all quality standards</li>
        <li><Text type="danger">fail</Text> - Ticket fails quality standards and needs improvement</li>
      </ul>
      <Text>See docs/STATUS_TYPES.md for more details</Text>
    </div>
  );

  return (
    <Tooltip 
      title={tooltipContent} 
      overlayClassName="status-type-tooltip" 
      placement="top"
      color="#fff"
      overlayInnerStyle={{ color: 'rgba(0,0,0,0.85)' }}
    >
      <InfoCircleOutlined className={className} style={{ marginLeft: '4px', color: '#1890ff', cursor: 'help' }} />
    </Tooltip>
  );
};

export default StatusTypeTooltip;


File: src/components/UserManagement/components/UserTable.tsx
// src/components/UserManagement/components/UserTable.tsx
import React from 'react';
import { Table, Space, Button, Tag, Popconfirm, Tooltip } from 'antd';
import { EditOutlined, DeleteOutlined } from '@ant-design/icons';
import { User } from '../../../api/types';
import { formatDate } from '../../../utils/dateFormat'; // Assuming you have this

const DEFAULT_PAGE_SIZE = 10;

interface UserTableProps {
  users: User[];
  rolesMap: Map<string, string>; // Map role name to description for tooltips
  loading: boolean;
  pagination: { current: number; pageSize: number; total: number };
  onEdit: (user: User) => void;
  onDelete: (id: number) => void;
  onPageChange: (page: number, pageSize: number) => void;
}

export const UserTable: React.FC<UserTableProps> = ({
  users,
  rolesMap,
  loading,
  pagination,
  onEdit,
  onDelete,
  onPageChange,
}) => {

  const columns = [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
      width: 80,
      sorter: (a: User, b: User) => a.id - b.id,
    },
    {
      title: 'Username',
      dataIndex: 'username',
      key: 'username',
      sorter: (a: User, b: User) => a.username.localeCompare(b.username),
    },
    {
      title: 'Roles',
      dataIndex: 'roles',
      key: 'roles',
      render: (roles: string[]) => (
        <Space wrap size={[0, 8]}>
          {roles?.map(roleName => (
             <Tooltip key={roleName} title={rolesMap.get(roleName) || 'Role description not found'}>
                <Tag color="blue">{roleName}</Tag>
             </Tooltip>
          ))}
          {(!roles || roles.length === 0) && <Tag>No Roles</Tag>}
        </Space>
      ),
    },
    {
      title: 'Created At',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (date: string) => {
        const { displayText, fullText } = formatDate(date);
        return <span title={fullText}>{displayText}</span>;
      },
       sorter: (a: User, b: User) => new Date(a.createdAt || 0).getTime() - new Date(b.createdAt || 0).getTime(),
    },
     {
      title: 'Updated At',
      dataIndex: 'updatedAt',
      key: 'updatedAt',
      render: (date: string) => {
        const { displayText, fullText } = formatDate(date);
        return <span title={fullText}>{displayText}</span>;
      },
       sorter: (a: User, b: User) => new Date(a.updatedAt || 0).getTime() - new Date(b.updatedAt || 0).getTime(),
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 120,
      render: (_: any, record: User) => (
        <Space size="small">
          <Tooltip title="Edit User">
            <Button
              type="text"
              icon={<EditOutlined />}
              onClick={() => onEdit(record)}
              aria-label={`Edit user ${record.username}`}
            />
          </Tooltip>
          <Popconfirm
            title={`Delete user "${record.username}"?`}
            description="This action cannot be undone."
            onConfirm={() => onDelete(record.id)}
            okText="Delete"
            okType="danger"
            cancelText="Cancel"
          >
            <Tooltip title="Delete User">
              <Button
                type="text"
                danger
                icon={<DeleteOutlined />}
                aria-label={`Delete user ${record.username}`}
              />
            </Tooltip>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <Table
      rowKey="id"
      columns={columns}
      dataSource={users}
      loading={loading}
      pagination={{
        current: pagination.current,
        pageSize: pagination.pageSize,
        total: pagination.total,
        showSizeChanger: true,
        pageSizeOptions: ['10', '20', '50', '100'],
        showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} users`,
      }}
      onChange={(p) => onPageChange(p.current ?? 1, p.pageSize ?? DEFAULT_PAGE_SIZE)}
      scroll={{ x: 'max-content' }} // Enable horizontal scroll if needed
      size="small"
    />
  );
};

File: src/components/UserManagement/UserManagementTab.tsx
// src/components/UserManagement/UserManagementTab.tsx
import React, { useState, useCallback, useMemo } from 'react';
import { Button, Input, Space, message } from 'antd';
import { PlusOutlined, SearchOutlined } from '@ant-design/icons';
import { ApiClient, User, CreateUserRequest, UpdateUserRequest } from '../../api/types';
import { useUsers } from './hooks/useUsers'; // Import the hook
import { UserTable } from './components/UserTable';
import { UserFormModal } from './components/UserFormModal'; // Correct import path
import debounce from 'lodash/debounce'; // Import debounce

interface UserManagementTabProps {
  apiClient: ApiClient;
}

const UserManagementTab: React.FC<UserManagementTabProps> = ({ apiClient }) => {
  const {
    users,
    roles, // Get available roles
    loading,
    loadingRoles,
    error,
    pagination,
    fetchUsers,
    createUser,
    updateUser,
    deleteUser,
  } = useUsers(apiClient); // Use the hook

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingUser, setEditingUser] = useState<User | undefined>(undefined);
  const [searchTerm, setSearchTerm] = useState('');

  // Debounced search handler
   const debouncedSearch = useCallback(
       debounce((value: string) => {
           fetchUsers(1, pagination.pageSize, value); // Reset to page 1 on search
       }, 500), // 500ms debounce delay
       [fetchUsers, pagination.pageSize]
   );

   const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
       const value = e.target.value;
       setSearchTerm(value);
       debouncedSearch(value);
   };


  const handleAddUser = () => {
    setEditingUser(undefined); // Clear editing state
    setIsModalOpen(true);
  };

  const handleEditUser = (user: User) => {
    setEditingUser(user);
    setIsModalOpen(true);
  };

  const handleDeleteUser = async (id: number) => {
    await deleteUser(id);
    // The hook handles refresh
  };

  const handleModalSubmit = async (data: CreateUserRequest | UpdateUserRequest): Promise<boolean> => {
    let success = false;
    if (editingUser) {
      const result = await updateUser(editingUser.id, data as UpdateUserRequest);
      success = !!result;
    } else {
      const result = await createUser(data as CreateUserRequest);
      success = !!result;
    }
    if (success) {
        setIsModalOpen(false); // Close modal on success
        setEditingUser(undefined);
    }
    return success; // Return success status to modal
  };

   const handleTableChange = (page: number, pageSize: number) => {
       fetchUsers(page, pageSize, searchTerm); // Fetch data for the new page/size
   };

   // Create a map of role names to descriptions for tooltips
   const rolesMap = useMemo(() => {
       const map = new Map<string, string>();
       roles.forEach(role => map.set(role.name, role.description || role.name));
       return map;
   }, [roles]);


  return (
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
        <div className="flex justify-between items-center">
           <Input
               placeholder="Search users..."
               prefix={<SearchOutlined />}
               value={searchTerm}
               onChange={handleSearchChange}
               style={{ width: 300 }}
               allowClear
           />
          <Button
            type="primary"
            icon={<PlusOutlined />}
            onClick={handleAddUser}
            disabled={loading || loadingRoles} // Disable if roles haven't loaded
          >
            Add User
          </Button>
        </div>

      <UserTable
        users={users}
        rolesMap={rolesMap} // Pass the roles map
        loading={loading}
        pagination={pagination}
        onEdit={handleEditUser}
        onDelete={handleDeleteUser}
        onPageChange={handleTableChange}
      />

      <UserFormModal
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false);
          setEditingUser(undefined); // Clear editing state on close
        }}
        onSubmit={handleModalSubmit}
        initialData={editingUser}
        availableRoles={roles} // Pass roles to modal
        loading={loading}
        loadingRoles={loadingRoles}
      />
    </Space>
  );
};

export default UserManagementTab;

File: src/components/UserManagement/UserManagementComponent.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Modal, Form, Input, message, Space, Select, Tag, Tooltip } from 'antd';
import { useAuth } from '../../context/AuthContext';
import { EditOutlined, DeleteOutlined, EyeOutlined, PlusOutlined } from '@ant-design/icons';
import { 
  ApiClient, 
  CreateUserRequest,
  UpdateUserRequest,
  User,
  Role
} from '../../api/types';

// Define the types needed for User Management functionality
export interface UserManagementComponentProps {
  apiClient: ApiClient;
}

export const UserManagementComponent: React.FC<UserManagementComponentProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  // Component state
  const [users, setUsers] = useState<User[]>([]);
  const [roles, setRoles] = useState<Role[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showViewModal, setShowViewModal] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [pagination, setPagination] = useState({ current: 1, pageSize: 10, total: 0 });
  const [form] = Form.useForm();
  
  // Load users and roles when component mounts
  useEffect(() => {
    loadUsers();
    loadRoles();
  }, []);
  
  const loadUsers = async (page = 1, pageSize = 10) => {
    setLoading(true);
    setError(null);
    
    try {
      const offset = (page - 1) * pageSize;
      const response = await apiClient.getUsers({ limit: pageSize, offset });
      
      setUsers(response.items || []);
      setPagination({
        current: page,
        pageSize: pageSize,
        total: response.totalCount || 0
      });
    } catch (err) {
      console.error('Failed to load users:', err);
      setError('Failed to load user accounts');
    } finally {
      setLoading(false);
    }
  };
  
  const loadRoles = async () => {
    try {
      const response = await apiClient.getRoles({ limit: 100 });
      setRoles(response.items || []);
    } catch (err) {
      console.error('Failed to load roles:', err);
      // We don't set the main error state here to avoid disrupting the UI
      message.error('Failed to load roles. Role selection may be incomplete.');
    }
  };
  
  const handleCreateUser = async (data: any) => {
    // Check if user has permission to create users
    if (!checkPermission('users:create')) {
      setError('You do not have permission to create users');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: CreateUserRequest = {
        username: data.username,
        password: data.password,
        roles: data.roles || []
      };
      
      await apiClient.createUser(request);
      message.success('User created successfully');
      setShowCreateModal(false);
      form.resetFields();
      loadUsers(pagination.current, pagination.pageSize); // Refresh the list
    } catch (err) {
      console.error('Failed to create user:', err);
      setError('Failed to create user account');
    } finally {
      setLoading(false);
    }
  };
  
  const handleUpdateUser = async (data: any) => {
    // Check if user has permission to update users
    if (!checkPermission('users:update')) {
      setError('You do not have permission to update users');
      return;
    }
    
    if (!selectedUser) {
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: UpdateUserRequest = {
        username: data.username !== selectedUser.username ? data.username : undefined,
        password: data.password || undefined, // Only include password if provided
        roles: data.roles // Always send roles to potentially update
      };
      
      // Filter out undefined fields for cleaner request
      const filteredRequest = Object.fromEntries(
        Object.entries(request).filter(([_, v]) => v !== undefined)
      ) as UpdateUserRequest;
      
      await apiClient.updateUser(selectedUser.id, filteredRequest);
      message.success('User updated successfully');
      setShowEditModal(false);
      form.resetFields();
      loadUsers(pagination.current, pagination.pageSize); // Refresh the list
    } catch (err) {
      console.error('Failed to update user:', err);
      setError('Failed to update user account');
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeleteUser = async (id: number) => {
    // Check if user has permission to delete users
    if (!checkPermission('users:delete')) {
      setError('You do not have permission to delete users');
      return;
    }
    
    setLoading(true);
    
    try {
      await apiClient.deleteUser(id);
      message.success('User deleted successfully');
      
      // If we're on a page that might now be empty, go back one page
      const newTotal = pagination.total - 1;
      const newTotalPages = Math.ceil(newTotal / pagination.pageSize);
      const pageToLoad = pagination.current > newTotalPages && newTotalPages > 0 
        ? newTotalPages 
        : pagination.current;
        
      loadUsers(pageToLoad, pagination.pageSize); // Refresh the list
    } catch (err) {
      console.error('Failed to delete user:', err);
      setError('Failed to delete user account');
    } finally {
      setLoading(false);
    }
  };
  
  const showDeleteConfirm = (id: number, username: string) => {
    Modal.confirm({
      title: `Are you sure you want to delete ${username}?`,
      content: 'This action cannot be undone.',
      okText: 'Yes',
      okType: 'danger',
      cancelText: 'No',
      onOk() {
        handleDeleteUser(id);
      },
    });
  };
  
  const openCreateModal = () => {
    form.resetFields();
    setShowCreateModal(true);
  };
  
  const openEditModal = (user: User) => {
    setSelectedUser(user);
    form.setFieldsValue({
      username: user.username,
      // Don't set password field for editing
      roles: user.roles || []
    });
    setShowEditModal(true);
  };
  
  const openViewModal = (user: User) => {
    setSelectedUser(user);
    setShowViewModal(true);
  };
  
  const handlePageChange = (page: number, pageSize?: number) => {
    loadUsers(page, pageSize || pagination.pageSize);
  };
  
  const formatRoles = (roleNames: string[]) => {
    if (!roleNames || roleNames.length === 0) {
      return <Tag>No Roles</Tag>;
    }
    
    return (
      <Space size={[0, 4]} wrap>
        {roleNames.map(role => (
          <Tag color="blue" key={role}>{role}</Tag>
        ))}
      </Space>
    );
  };
  
  const columns = [
    {
      title: 'Username',
      dataIndex: 'username',
      key: 'username',
      sorter: (a: User, b: User) => a.username.localeCompare(b.username),
    },
    {
      title: 'Roles',
      dataIndex: 'roles',
      key: 'roles',
      render: (roles: string[]) => formatRoles(roles),
    },
    {
      title: 'Created At',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (text: string) => text ? new Date(text).toLocaleString() : '-',
    },
    {
      title: 'Updated At',
      dataIndex: 'updatedAt',
      key: 'updatedAt',
      render: (text: string) => text ? new Date(text).toLocaleString() : '-',
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: User) => (
        <Space size="small">
          <Button 
            type="text" 
            icon={<EyeOutlined />} 
            onClick={() => openViewModal(record)}
          />
          {checkPermission('users:update') && (
            <Button 
              type="text" 
              icon={<EditOutlined />} 
              onClick={() => openEditModal(record)}
            />
          )}
          {checkPermission('users:delete') && (
            <Button 
              type="text" 
              danger 
              icon={<DeleteOutlined />} 
              onClick={() => showDeleteConfirm(record.id, record.username)}
            />
          )}
        </Space>
      ),
    },
  ];
  
  return (
    <div className="user-management-container">
      {error && <div className="error-message mb-4 p-3 text-red-700 bg-red-50 border border-red-200 rounded">{error}</div>}
      
      <div className="actions-container" style={{ marginBottom: '16px' }}>
        {checkPermission('users:create') && (
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={openCreateModal}
          >
            Add New User
          </Button>
        )}
      </div>
      
      <Table
        dataSource={users}
        columns={columns}
        rowKey="id"
        loading={loading}
        pagination={{
          current: pagination.current,
          pageSize: pagination.pageSize,
          total: pagination.total,
          onChange: handlePageChange,
          showSizeChanger: true,
          pageSizeOptions: ['10', '20', '50'],
          showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} items`
        }}
      />
      
      {/* Create Modal */}
      <Modal
        title="Add New User"
        open={showCreateModal}
        onCancel={() => setShowCreateModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleCreateUser}
        >
          <Form.Item
            name="username"
            label="Username"
            rules={[{ required: true, message: 'Please enter a username' }]}
          >
            <Input />
          </Form.Item>
          
          <Form.Item
            name="password"
            label="Password"
            rules={[{ required: true, message: 'Please enter a password' }]}
            hasFeedback
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="confirmPassword"
            label="Confirm Password"
            dependencies={['password']}
            hasFeedback
            rules={[
              { required: true, message: 'Please confirm the password' },
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!value || getFieldValue('password') === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(new Error('The two passwords do not match'));
                },
              }),
            ]}
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="roles"
            label="Roles"
          >
            <Select
              mode="multiple"
              placeholder="Select roles"
              optionFilterProp="label"
            >
              {roles.map(role => (
                <Select.Option key={role.id} value={role.name} label={role.name}>
                  <div>
                    <div>{role.name}</div>
                    {role.description && (
                      <div className="text-xs text-gray-500">{role.description}</div>
                    )}
                  </div>
                </Select.Option>
              ))}
            </Select>
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Create
            </Button>
            <Button onClick={() => setShowCreateModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* Edit Modal */}
      <Modal
        title="Edit User"
        open={showEditModal}
        onCancel={() => setShowEditModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleUpdateUser}
        >
          <Form.Item
            name="username"
            label="Username"
            rules={[{ required: true, message: 'Please enter a username' }]}
          >
            <Input disabled />
          </Form.Item>
          
          <Form.Item
            name="password"
            label="New Password (leave blank to keep current)"
            hasFeedback
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="confirmPassword"
            label="Confirm New Password"
            dependencies={['password']}
            hasFeedback
            rules={[
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!getFieldValue('password') || !value || getFieldValue('password') === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(new Error('The two passwords do not match'));
                },
              }),
            ]}
          >
            <Input.Password />
          </Form.Item>
          
          <Form.Item
            name="roles"
            label="Roles"
          >
            <Select
              mode="multiple"
              placeholder="Select roles"
              optionFilterProp="label"
            >
              {roles.map(role => (
                <Select.Option key={role.id} value={role.name} label={role.name}>
                  <div>
                    <div>{role.name}</div>
                    {role.description && (
                      <div className="text-xs text-gray-500">{role.description}</div>
                    )}
                  </div>
                </Select.Option>
              ))}
            </Select>
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Update
            </Button>
            <Button onClick={() => setShowEditModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* View Modal */}
      <Modal
        title="User Details"
        open={showViewModal}
        onCancel={() => setShowViewModal(false)}
        footer={[
          <Button key="close" onClick={() => setShowViewModal(false)}>
            Close
          </Button>
        ]}
      >
        {selectedUser && (
          <>
            <p><strong>Username:</strong> {selectedUser.username}</p>
            <p><strong>Roles:</strong></p>
            <div className="mb-3">{formatRoles(selectedUser.roles)}</div>
            <p><strong>Created:</strong> {selectedUser.createdAt ? new Date(selectedUser.createdAt).toLocaleString() : 'N/A'}</p>
            <p><strong>Last Updated:</strong> {selectedUser.updatedAt ? new Date(selectedUser.updatedAt).toLocaleString() : 'N/A'}</p>
          </>
        )}
      </Modal>
    </div>
  );
};

export default UserManagementComponent;

File: src/config/api.ts
// Base configuration for API endpoints
export const API_CONFIG = {
  baseUrl: '/api', // Use relative URL in all environments to leverage Vite's proxy
  version: 'v1',
  getFullBaseUrl: () => {
    return `${API_CONFIG.baseUrl}/${API_CONFIG.version}`; // Corrected to include baseUrl and version
  }
};

export const API_HEADERS = {
  'Content-Type': 'application/json',
  'Accept': 'application/json',
};

export const API_ENDPOINTS = {
  systems: {
    list: '/systems',
    get: '/systems/{code}',
  },
  classify: {
    auto: '/classify',
    manual: '/classify/manual',
    batch: '/classify/batch'
  },
  history: '/history',
  batch: {
    create: '/classify/batch',
    jobs: '/batch/jobs',
    status: '/batch/jobs/{id}'
  },
  // --- User Management Endpoints ---
  users: {
    list: '/users',
    create: '/users',
    get: '/users/{id}',
    update: '/users/{id}',
    delete: '/users/{id}',
    roles: '/users/{id}/roles'
  },
  roles: {
    list: '/roles',
    create: '/roles',
    update: '/roles/{id}',
    delete: '/roles/{id}'
  },
  permissions: {
    list: '/permissions'
  },
  auth: {
    config: '/auth/config',
    login: '/auth/login',
    currentUser: '/auth/me'
  },
  // --- RAG Endpoints ---
  ragInfo: {
    list: '/rag-info',      // GET (with pagination/filter params)
    create: '/rag-info',    // POST
    get: '/rag-info/{id}', // GET
    update: '/rag-info/{id}', // PUT or PATCH
    delete: '/rag-info/{id}'  // DELETE
  },
  // Add endpoint for frontend config if needed
  frontendConfig: '/settings/config',
  chat: { 
    completions: '/chat/completions', 
  },
  // --- ServiceNow (SNOW) Endpoints ---
  snow: {
    analyze: '/snow/analyze',         // POST
    history: '/snow/history',         // GET (list), DELETE (with /:id)
    historyItem: '/snow/history/{id}' // DELETE (specific item)
  },
};

export const formatEndpoint = (endpoint: string, params?: Record<string, string>): string => {
  let formattedEndpoint = endpoint;
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      formattedEndpoint = formattedEndpoint.replace(`{${key}}`, value);
    });
  }
  
  return `${API_CONFIG.getFullBaseUrl()}${formattedEndpoint}`;
};


File: src/components/Settings.tsx
import React, { useState, useEffect, ReactNode, useMemo } from 'react';
import { LlmConfig } from '../api/types';
import ConfigValue from './ConfigValue';

interface SettingsProps {
  apiClient: {
    getConfig(): Promise<LlmConfig>;
    updateConfig(config: LlmConfig): Promise<void>;
  };
}

interface SectionGroups {
  rag: Record<string, any>;
  basic: Record<string, any>;
}

const Settings: React.FC<SettingsProps> = ({ apiClient }): JSX.Element => {
  const [config, setConfig] = useState<LlmConfig | null>(null);
  const [notification, setNotification] = useState<{ type: 'success' | 'error', message: string } | null>(null);
  const [expandedSections, setExpandedSections] = useState<{[key: string]: boolean}>({
    server: true,
    service: true,
    database: true,
    validation: true,
    alert: true
  });

  // Memoized labels for config keys
  const configLabels = useMemo<Record<string, string>>(() => ({
    ragEnabled: 'RAG Enabled',
    ragServiceUrl: 'RAG Service URL',
    ragManualInfoCollection: 'RAG Manual Info Collection',
    ragUnspscCollection: 'RAG UNSPSC Collection',
    ragCommonCollection: 'RAG Common Collection'
  }), []);

  // Function to get a user-friendly label for a config key
  const getConfigLabel = (key: string): string => configLabels[key] || key;

  // Function to toggle section expansion
  const toggleSection = (section: string): void => {
    setExpandedSections(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  useEffect(() => {
    const loadConfig = async () => {
      try {
        const data = await apiClient.getConfig();
        setConfig(data);
      } catch (error) {
        console.error('Error loading config:', error);
        setNotification({
          type: 'error',
          message: 'Failed to load settings'
        });
      }
    };
    
    loadConfig();
  }, [apiClient]);

  // Group related settings
  const groupSettings = (obj: any): SectionGroups => {
    const groups: SectionGroups = {
      rag: {},
      basic: {},
    };

    if (!obj) return groups;

    Object.entries(obj).forEach(([key, value]) => {
      if (key.toLowerCase().startsWith('rag')) {
        groups.rag[key] = value;
      } else {
        groups.basic[key] = value;
      }
    });

    return groups;
  };

  // Recursive function to render nested config entries
  const renderEntries = (obj: any, indent: number = 0): JSX.Element[] => {
    if (obj === null || obj === undefined) return [];

    // For database section, use special grouping
    if (indent === 0 && config?.database && obj === config.database) {
      const groups = groupSettings(obj);
      const hasRagSettings = Object.keys(groups.rag).length > 0;
      const result: JSX.Element[] = [];

      if (hasRagSettings) {
        result.push(
          <div key="rag-header" className="mt-2 mb-3">
            <h4 className="text-sm font-semibold text-primary-600 mb-2">RAG Configuration</h4>
            {Object.entries(groups.rag).map(([key, value]) => (
              <div key={key} className="grid grid-cols-2 gap-x-2 py-1">
                <div className="text-sm font-medium text-secondary-700">{getConfigLabel(key)}:</div>
                <div className="text-sm">
                  <ConfigValue configKey={key} value={value} />
                </div>
              </div>
            ))}
          </div>
        );
      }

      if (Object.keys(groups.basic).length > 0) {
        result.push(
          <div key="basic-header" className={`mt-4 ${!hasRagSettings ? 'mt-2' : ''}`}>
            <h4 className="text-sm font-semibold text-secondary-600 mb-2">Database Settings</h4>
            {Object.entries(groups.basic).map(([key, value]) => {
              const isObj = typeof value === 'object' && value !== null;
              return (
                <div key={key} className="grid grid-cols-2 gap-x-2 py-1">
                  <div className="text-sm font-medium text-secondary-700">{getConfigLabel(key)}:</div>
                  <div className="text-sm">
                    {!isObj ? <ConfigValue configKey={key} value={value} /> : ''}
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      return result;
    }

    // For other sections, render nested entries
    const entries: JSX.Element[] = [];
    Object.entries(obj).forEach(([key, value]) => {
      const isObj = typeof value === 'object' && value !== null;
      const marginStyle = { marginLeft: `${indent * 1}rem` };

      entries.push(
        <div key={`${key}-${indent}`} className="grid grid-cols-2 gap-x-2 py-1" style={marginStyle}>
          <div className="text-sm font-medium text-secondary-700">{getConfigLabel(key)}:</div>
          <div className="text-sm">
            {!isObj ? <ConfigValue configKey={key} value={value} /> : ''}
          </div>
        </div>
      );

      if (Array.isArray(value)) {
        value.forEach((item, idx) => {
          entries.push(
            <div key={`${key}-${idx}`} style={{ marginLeft: `${(indent + 1) * 1}rem` }}>
              <div className="text-sm font-medium text-secondary-700">[{idx}]</div>
              {typeof item === 'object' && item !== null ?
                renderEntries(item, indent + 2) :
                <div className="text-sm">
                  <ConfigValue configKey={key} value={item} />
                </div>}
            </div>
          );
        });
      } else if (isObj) {
        entries.push(...renderEntries(value, indent + 1));
      }
    });

    return entries;
  };

  // Function to render a configuration section
  const renderConfigSection = (title: string, configSection: any, sectionKey: string): JSX.Element => {
    if (!configSection) return <></>;
    
    return (
      <div className="mb-6 bg-white shadow-card rounded-card">
        <div 
          className="flex items-center justify-between p-4 border-b cursor-pointer"
          onClick={() => toggleSection(sectionKey)}
        >
          <h3 className="text-lg font-medium text-secondary-900">{title}</h3>
          <button className="text-gray-500">
            {expandedSections[sectionKey] ? 'â–¼' : 'â–¶'}
          </button>
        </div>
        
        {expandedSections[sectionKey] && (
          <div className="p-4">
            {renderEntries(configSection)}
          </div>
        )}
      </div>
    );
  };

  if (!config) {
    return (
      <div className="max-w-8xl mx-auto space-y-10 p-4">
        <div className="bg-white shadow-card rounded-card p-8">
          <p className="text-secondary-700">Loading configuration...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-8xl mx-auto space-y-6" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
      <div className="bg-white shadow-card rounded-card p-6 w-full">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-semibold text-secondary-900">System Configuration</h2>
        </div>

        {notification && (
          <div className={`mb-6 rounded-card px-4 py-3 ${
            notification.type === 'success'
              ? 'bg-green-50/50 border border-green-200 text-green-700'
              : 'bg-red-50/50 border border-red-200 text-red-700'
          }`}>
            <p className="text-sm">{notification.message}</p>
          </div>
        )}

        <div className="text-sm text-gray-600 mb-6">
          <p>This is a read-only view of the current system configuration. Sensitive information is masked with asterisks.</p>
        </div>

        {renderConfigSection('Server Configuration', config.server, 'server')}
        {renderConfigSection('Service Configuration', config.service, 'service')}
        {renderConfigSection('Database Configuration', config.database, 'database')}
        {renderConfigSection('Validation Configuration', config.validation, 'validation')}
        {renderConfigSection('Alert Configuration', config.alert, 'alert')}
      </div>
    </div>
  );
};

export default Settings;

File: src/components/Sidebar/LeftSidebar.component.tsx
// src/components/Sidebar/LeftSidebar.component.tsx
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import { Button, Col, Menu, MenuProps, Modal, Row, Typography } from 'antd';
import classNames from 'classnames';
import { noop } from 'lodash';
import { useLocation } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext'; // Import useAuth hook

// Import constants and types
import {
  SIDEBAR_ITEMS as BASE_SIDEBAR_ITEMS,
  BOTTOM_SIDEBAR_ITEMS,
  SIDEBAR_NESTED_KEYS,
  RAG_INFO_SIDEBAR_ITEM,
  CHAT_SIDEBAR_ITEM,
  ADMIN_SIDEBAR_ITEMS,
  LANGGRAPH_VIS_SIDEBAR_ITEM, // Import LangGraph item
  SNOW_SIDEBAR_ITEM, // Import SNOW sidebar item
} from '../../constants/LeftSidebar.constants';
import { SidebarItem as SidebarItemEnum } from '../../enum/sidebar.enum';
import { LeftSidebarItem as LeftSidebarItemType, LeftSidebarProps } from './LeftSidebar.interface';
import LeftSidebarItem from './LeftSidebarItem.component';
import './left-sidebar.css';

const LeftSidebar: React.FC<LeftSidebarProps> = ({
  isSidebarCollapsed = true,
  onLogout = () => {},
  ragEnabled = false // Default to false and let the prop override it
}) => {
  const location = useLocation();
  const { authEnabled, checkPermission } = useAuth(); // Get auth state and check function
  const [showConfirmLogoutModal, setShowConfirmLogoutModal] = useState(false);
  
  // Add debug useEffect
  useEffect(() => {
    console.log('LeftSidebar - ragEnabled:', ragEnabled);
  }, [ragEnabled]);

  const selectedKeys = useMemo(() => {
    const pathname = location.pathname;
    const matchedParent = Object.keys(SIDEBAR_NESTED_KEYS).find(key => pathname.startsWith(key));
    const parentKey = matchedParent ? SIDEBAR_NESTED_KEYS[matchedParent] : null;
    if (parentKey) return [parentKey];
    const directMatch = pathname.split('/').slice(0, 2).join('/');
    return [directMatch];
  }, [location.pathname]);

  const handleLogoutClick = useCallback(() => { setShowConfirmLogoutModal(true); }, []);
  const hideConfirmationModal = () => { setShowConfirmLogoutModal(false); };
  const handleLogout = useCallback(() => { onLogout(); setShowConfirmLogoutModal(false); }, [onLogout]);

  // Filter menu items based on permissions
  const filterItemsByPermission = useCallback((items: LeftSidebarItemType[]): MenuProps['items'] => {
    return items
      .filter(item => !authEnabled || !item.requiredPermission || checkPermission(item.requiredPermission)) // Filter top-level
      .map(item => ({
        key: item.key,
        label: <LeftSidebarItem data={item} />,
        icon: item.icon ? React.createElement(item.icon) : undefined,
        // Recursively filter children if needed
        children: item.children
          ?.filter(child => !authEnabled || !child.requiredPermission || checkPermission(child.requiredPermission))
          .map((childItem: LeftSidebarItemType) => ({
            key: childItem.key,
            label: <LeftSidebarItem data={childItem} />,
            icon: childItem.icon ? React.createElement(childItem.icon) : undefined,
          })),
      }));
  }, [authEnabled, checkPermission]);

  // Map menu items with conditional RAG and Admin items
  const topMenuItems: MenuProps['items'] = useMemo(() => {
    let items: LeftSidebarItemType[] = [...BASE_SIDEBAR_ITEMS]; // Start with base items from constants

    // Determine the insertion index for Chat and RAG
    const historyIndex = items.findIndex(item => item?.key === SidebarItemEnum.HISTORY);
    let insertionPoint = historyIndex !== -1 ? historyIndex + 1 : items.length;

    // Insert Chat Item
    items.splice(insertionPoint, 0, CHAT_SIDEBAR_ITEM);
    insertionPoint++; // Move insertion point for next item

    // Insert RAG item if enabled
    if (ragEnabled === true) {
      console.log("RAG is enabled, adding RAG menu item");
      items.splice(insertionPoint, 0, RAG_INFO_SIDEBAR_ITEM);
      insertionPoint++; // Move insertion point for next item
    } else {
      console.log("RAG is not enabled, not adding RAG menu item");
    }

    // Insert LangGraph item
    items.splice(insertionPoint, 0, LANGGRAPH_VIS_SIDEBAR_ITEM);
    insertionPoint++; // Move insertion point for next item
    
    // Insert ServiceNow (SNOW) item
    items.splice(insertionPoint, 0, SNOW_SIDEBAR_ITEM);
    // insertionPoint++; // Not needed if SNOW is the last dynamic item before admin items

    // Add Admin items (conditionally displayed based on permissions in the filter below)
    items = [...items, ...ADMIN_SIDEBAR_ITEMS];

    // Filter based on permissions
    return filterItemsByPermission(items);
  }, [ragEnabled, filterItemsByPermission]);

  const bottomMenuItems: MenuProps['items'] = useMemo(
    () => filterItemsByPermission(BOTTOM_SIDEBAR_ITEMS.map(item => ({
      ...item,
      onClick: item.key === SidebarItemEnum.LOGOUT ? handleLogoutClick : item.onClick || noop,
    }))),
    [handleLogoutClick, filterItemsByPermission]
  );

  return (
    <div
      className={classNames(
        'flex flex-col justify-between h-full left-sidebar-container',
        { 'sidebar-open': !isSidebarCollapsed }
      )}
      data-testid="left-sidebar"
    >
      <Row>
        <Col className="w-full">
          <Menu
            items={topMenuItems}
            mode="inline"
            theme="light"
            inlineCollapsed={isSidebarCollapsed}
            className="left-sidebar-menu"
            selectedKeys={selectedKeys}
            style={{ border: 'none' }}
          />
        </Col>
      </Row>

      <Row className="py-2">
        <Col span={24}>
          <Menu
            items={bottomMenuItems}
            mode="inline"
            theme="light"
            inlineCollapsed={isSidebarCollapsed}
            className="left-sidebar-menu"
            selectable={false}
            style={{ border: 'none' }}
          />
        </Col>
      </Row>

      {showConfirmLogoutModal && (
        <Modal
          centered
          title="Logout Confirmation"
          open={showConfirmLogoutModal}
          onCancel={hideConfirmationModal}
          footer={[
            <Button key="cancel" onClick={hideConfirmationModal}>
              Cancel
            </Button>,
            <Button key="logout" type="primary" danger onClick={handleLogout} data-testid="confirm-logout">
              Logout
            </Button>,
          ]}
        >
          <Typography.Text>Are you sure you want to log out?</Typography.Text>
        </Modal>
      )}
    </div>
  );
};

export default LeftSidebar;

File: src/components/StatusTypeGuide.tsx
// src/components/StatusTypeGuide.tsx
import React from 'react';
import { Card, Divider, Typography, Table } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined, WarningOutlined, InfoCircleOutlined } from '@ant-design/icons';

const { Title, Paragraph, Text } = Typography;

/**
 * StatusTypeGuide - A documentation component that explains the different status types
 * used in the application for both Categorization and ServiceNow systems.
 */
const StatusTypeGuide: React.FC = () => {
  // Classification system status columns
  const classificationColumns = [
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (text: string) => {
        switch (text) {
          case 'success':
            return <><CheckCircleOutlined style={{ color: '#52c41a' }} /> success</>;
          case 'partial':
            return <><WarningOutlined style={{ color: '#faad14' }} /> partial</>;
          case 'failed':
            return <><CloseCircleOutlined style={{ color: '#f5222d' }} /> failed</>;
          default:
            return <>{text}</>;
        }
      },
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
    },
    {
      title: 'Used In',
      dataIndex: 'usedIn',
      key: 'usedIn',
    },
  ];

  // SNOW system status columns
  const snowColumns = [
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (text: string) => {
        switch (text) {
          case 'pass':
            return <><CheckCircleOutlined style={{ color: '#52c41a' }} /> pass</>;
          case 'fail':
            return <><CloseCircleOutlined style={{ color: '#f5222d' }} /> fail</>;
          default:
            return <>{text}</>;
        }
      },
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
    },
    {
      title: 'Used In',
      dataIndex: 'usedIn',
      key: 'usedIn',
    },
  ];

  // Data for classification statuses
  const classificationData = [
    {
      key: '1',
      status: 'success',
      description: 'Classification was fully completed with all required levels',
      usedIn: 'Categorization system for product/service classification',
    },
    {
      key: '2',
      status: 'partial',
      description: 'Classification is partially complete; some levels may be missing or invalid',
      usedIn: 'Categorization system for product/service classification',
    },
    {
      key: '3',
      status: 'failed',
      description: 'Classification failed to determine required levels',
      usedIn: 'Categorization system for product/service classification',
    },
    {
      key: '4',
      status: 'all',
      description: 'Filter option that shows classifications with any status',
      usedIn: 'UI filtering in the History tab for categorization',
    },
  ];

  // Data for SNOW validation statuses
  const snowData = [
    {
      key: '1',
      status: 'pass',
      description: 'Ticket meets all validation criteria and quality standards',
      usedIn: 'ServiceNow ticket analysis system',
    },
    {
      key: '2',
      status: 'fail',
      description: 'Ticket fails to meet quality standards and requires improvement',
      usedIn: 'ServiceNow ticket analysis system',
    },
  ];

  return (
    <Card className="status-type-guide">
      <Title level={3}>Status Types Guide</Title>
      <Paragraph>
        <InfoCircleOutlined /> This guide explains the different status types used in the application.
      </Paragraph>

      <Divider orientation="left">Categorization System Status Types</Divider>
      <Paragraph>
        In the categorization system, the following status types are used to indicate the result of classifying products or services:
      </Paragraph>
      <Table 
        columns={classificationColumns} 
        dataSource={classificationData} 
        pagination={false} 
        bordered 
      />

      <Divider orientation="left" style={{ marginTop: '2rem' }}>ServiceNow System Validation Status</Divider>
      <Paragraph>
        The ServiceNow ticket analysis system uses a different set of status indicators for ticket validation:
      </Paragraph>
      <Table 
        columns={snowColumns} 
        dataSource={snowData} 
        pagination={false} 
        bordered 
      />

      <Divider />
      <Paragraph>
        <Text strong>Note:</Text> These are completely different status types used in different parts of the application.
      </Paragraph>
    </Card>
  );
};

export default StatusTypeGuide;


File: src/components/HistoryTab.tsx
// src/components/HistoryTab.tsx
import React, { useEffect, useState, useCallback } from 'react'; // Added useCallback
import { Tooltip } from 'antd'; // Import Tooltip
import { ApiClient, ClassificationHistory, ClassificationSourceType, ClassificationStatus, ClassificationSystem } from '../api/types';
import { ManualClassificationModal } from './ManualClassificationModal';
import { RerunStatusModal } from './RerunStatusModal';
import { ClassificationDetailsModal } from './ClassificationDetailsModal';
import { formatDate } from '../utils/dateFormat';
import { isInformationalError } from '../utils/statusUtils';
import { useAuth } from '../context/AuthContext'; // Import useAuth hook

interface HistoryTabProps {
  apiClient: ApiClient;
}

export const HistoryTab: React.FC<HistoryTabProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  const [history, setHistory] = useState<ClassificationHistory[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize] = useState(10); // Keep pageSize constant
  const [totalPages, setTotalPages] = useState(1);
  const [pageCursors, setPageCursors] = useState<string[]>([]); // Store cursors for next pages
  const [loading, setLoading] = useState(false);
  const [systems, setSystems] = useState<ClassificationSystem[]>([]);
  const [selectedSystem, setSelectedSystem] = useState<string>();
  const [error, setError] = useState<string>();
  const [showManualModal, setShowManualModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState<ClassificationHistory | null>(null);
  const [showRerunModal, setShowRerunModal] = useState(false);
  const [rerunningItem, setRerunningItem] = useState<ClassificationHistory | null>(null);
  
  // State for the classification details modal
  const [showDetailsModal, setShowDetailsModal] = useState(false);
  const [detailsItem, setDetailsItem] = useState<ClassificationHistory | null>(null);

  // Filter states
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedStatus, setSelectedStatus] = useState<ClassificationStatus>('all');
  const [selectedSource, setSelectedSource] = useState<ClassificationSourceType>();
  const [selectedClassifier, setSelectedClassifier] = useState('');
  const [classifierOptions, setClassifierOptions] = useState<string[]>([]);
  const [startDate, setStartDate] = useState<string>(() => {
    const date = new Date();
    date.setDate(date.getDate() - 7);
    return date.toISOString().split('T')[0];
  });
  const [endDate, setEndDate] = useState<string>(() => {
    return new Date().toISOString().split('T')[0];
  });
  // Using isInformationalError function from statusUtils.ts
  // This replaced the local informationalErrorMessages array and isInformationalError function

  useEffect(() => {
    const loadSystems = async () => {
      try {
        const systemList = await apiClient.getClassificationSystems();
        console.log('Loaded systems:', systemList);
        setSystems(systemList);
      } catch (err) {
        console.error('Failed to load systems:', err);
        setError('Failed to load classification systems');
      }
    };
    loadSystems();
  }, [apiClient]);

  const loadHistory = useCallback(async (targetPage: number = currentPage, cursorToUse?: string) => {
    setLoading(true);
    setError(undefined);
    try {
      const pageToLoad = targetPage;
      let effectiveCursor = cursorToUse;      // If we have a cursor to use (passed in), use it
      // For page 1, we always use undefined (no cursor)
      if (pageToLoad === 1) {
        effectiveCursor = undefined; // Always no cursor for page 1
      }
      // Otherwise use the provided cursor
      // The cursorToUse should be provided by the effect that tracks currentPage changes
      
      console.debug('[History] Loading data:', {
        page: pageToLoad,
        cursor: effectiveCursor,
        filters: {
          system: selectedSystem,
          status: selectedStatus === 'all' ? undefined : selectedStatus,
          search: searchTerm.trim() || undefined,
          sourceType: selectedSource || undefined,
          createdBy: selectedClassifier || undefined,
          startDate,
          endDate: endDate ? new Date(endDate + 'T23:59:59').toISOString() : undefined,
        }
      });

      const result = await apiClient.getClassificationHistory({
        systemCode: selectedSystem,
        cursor: effectiveCursor,
        limit: pageSize,
        status: selectedStatus === 'all' ? undefined : selectedStatus,
        startDate,
        endDate: endDate ? new Date(endDate + 'T23:59:59').toISOString() : undefined,
        search: searchTerm.trim() || undefined,
        sourceType: selectedSource || undefined,
        createdBy: selectedClassifier || undefined
      });
        console.debug('[History] Raw API Response:', result);
      console.debug('[History] First item from API:', result.items?.[0]);
        const firstItem = result.items?.[0];
      if (firstItem) {
        console.debug('[History] First item firstLevelPrompt:', firstItem.firstLevelPrompt);
        console.debug('[History] First item allPromptsDetail:', firstItem.allPromptsDetail);        
        console.debug('[History] First item properties:', 
          Object.keys(firstItem).map(key => {
            const value = firstItem[key as keyof typeof firstItem];
            return `${key}: ${typeof value}`;
          }).join(', '));
      }


      if (!result.items) {
        console.warn('No items array in history response');
        setHistory([]);
        setTotalCount(0);
        setTotalPages(1);
        if (pageToLoad > 1) setCurrentPage(1); // Reset to page 1 if current page had no items
        setPageCursors([]); // Reset cursors
        return;
      }

      setHistory(result.items);
      setTotalCount(result.totalCount);
      setTotalPages(Math.ceil(result.totalCount / pageSize) || 1);      if (result.nextCursor) {
        setPageCursors(prev => {
          const newCursors = [...prev];
          // Cursor returned when fetching page N is the cursor *for* page N+1
          // Store at index N-1 (0-indexed array where index corresponds to page-1)
          if (pageToLoad - 1 < newCursors.length) {
            newCursors[pageToLoad - 1] = result.nextCursor!;
          } else {
            // Ensure array is long enough, filling gaps with undefined if necessary
            for (let i = newCursors.length; i < pageToLoad - 1; i++) {
              newCursors.push(undefined as unknown as string);
            }
            newCursors.push(result.nextCursor!);
          }
          console.debug('[History] Updated pageCursors:', newCursors);
          return newCursors;
        });
      }


    } catch (err) {
      console.error('Failed to load history:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to load classification history';
      setError(`Error loading history: ${errorMessage}`);
      setHistory([]);
      setTotalCount(0);
      setTotalPages(1);
      setCurrentPage(1);
      setPageCursors([]);    } finally {
      setLoading(false);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [apiClient, selectedSystem, selectedStatus, startDate, endDate, searchTerm, selectedSource, selectedClassifier, pageSize]); // pageCursors and currentPage removed from deps of loadHistory
  const handlePageChange = (page: number) => {
      if (page === currentPage || loading) return; // Prevent re-fetch if same page or already loading
      setCurrentPage(page);
      // loadHistory will be called by the effect watching currentPage
  };

  useEffect(() => {
    const loadClassifiers = async () => {
      try {
        // Consider if limiting this initial fetch for classifiers is needed if it's slow
        const result = await apiClient.getClassificationHistory({ limit: 1000 }); 
        const uniqueClassifiers = [...new Set(result.items
          .map(item => item.createdBy))]
          .filter(Boolean) // Remove undefined/empty strings
          .sort();
        setClassifierOptions(uniqueClassifiers);
      } catch (err) {
        console.error('Failed to load classifiers:', err);
      }
    };
    loadClassifiers();
  }, [apiClient]);
  useEffect(() => {
    // This effect resets to page 1 and clears cursors when filters change
    console.debug('[History] Filter change detected, resetting page and cursors.');
    setCurrentPage(1);
    setPageCursors([]); // Clear cursors on filter change
    // The change in currentPage will trigger the next useEffect to load data for page 1
  }, [selectedSystem, selectedStatus, startDate, endDate, searchTerm, selectedSource, selectedClassifier]);
  useEffect(() => {
    // This effect handles loading data whenever currentPage changes OR when filters have reset currentPage to 1
    // Determine the cursor: For page 1, it's always undefined.
    // For page N > 1, it's pageCursors[N-2] (the cursor that led to page N-1 gives us the cursor for page N)
    const cursorForPageToFetch = currentPage === 1 ? undefined : pageCursors[currentPage - 2];
    console.debug(`[History] CurrentPage effect: loading page ${currentPage} with cursor "${cursorForPageToFetch}"`, {pageCursors});
    loadHistory(currentPage, cursorForPageToFetch);
  }, [currentPage, loadHistory]); // pageCursors is intentionally NOT a dependency to break the loop

  const handleReclassify = async (item: ClassificationHistory) => {
    if (!item.systemCode) {
      console.error('Cannot reclassify: systemCode is missing from history item.', item);
      setError('Cannot reclassify this item because its classification system is unknown.');
      return;
    }
    setSelectedItem(item);
    setShowManualModal(true);
  };

  const handleRerun = async (item: ClassificationHistory) => {
    if (!window.confirm('Are you sure you want to rerun this classification?')) { // Changed to window.confirm
      return;
    }

    setRerunningItem(item);
    setShowRerunModal(true);
    setError(undefined);

    try {
      const result = await apiClient.rerunClassification(String(item.id));
      
      if (result.error) {
        setError(`Rerun failed: ${result.error}`);
      }
      setCurrentPage(1);
      setPageCursors([]);
      await loadHistory(1);
    } catch (err) {
      console.error('Failed to rerun classification:', err);
      setError('Failed to start rerun');
    } finally {
      setShowRerunModal(false);
      setRerunningItem(null);
    }
  };

  const handleDelete = async (item: ClassificationHistory) => {
    if (!window.confirm('Are you sure you want to delete this classification? This action cannot be undone.')) { // Changed to window.confirm
      return;
    }

    setLoading(true);
    setError(undefined);
    try {
      await apiClient.deleteClassification(String(item.id));
      setCurrentPage(1);
      setPageCursors([]);
      await loadHistory(1);
    } catch (err) {
      console.error('Failed to delete classification:', err);
      setError('Failed to delete classification');
    } finally {
      setLoading(false);
    }
  };

  const handleManualClassification = async (result: any) => {
    console.debug('[Classification] Manual result:', {
      success: !result.error,
      error: result.error,
      description: result.description
    });

    if (result.error && !isInformationalError(result.error)) {
      setError(`Classification failed: ${result.error}`);
    } else if (result.error && isInformationalError(result.error)) {
      setError(undefined);
      console.info(`Informational message from manual classification: ${result.error}`);
    }

    setCurrentPage(1);
    setPageCursors([]);
    await loadHistory(1);

    setShowManualModal(false);
    setSelectedItem(null);
  };

  const handleView = (item: ClassificationHistory) => {
    console.debug('Viewing details for history item:', item);
    setDetailsItem(item);
    setShowDetailsModal(true);
  };

  const getClassifierBadge = (createdBy: string) => {
    // ... (existing code for getClassifierBadge)
    if (!createdBy || createdBy === 'direct') { // Consider 'direct' or make it consistent from backend
        return (
          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-gray-100 text-gray-800 border-gray-200">
            Direct Input
          </span>
        );
      }
      // Check if createdBy looks like a user ID (number) or a batch ID (string, potentially non-numeric)
      if (/^\d+$/.test(createdBy)) { // If it's purely numeric, assume user ID
        return (
            <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-sky-100 text-sky-800 border-sky-200">
              User ID: {createdBy}
            </span>
          );
      }
      return (
        <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-purple-100 text-purple-800 border-purple-200">
          Batch: {createdBy}
        </span>
      );
  };

  const getSourceBadge = (sourceType?: ClassificationSourceType, createdBy?: string) => { // made params optional for safety
    const classes: Record<string, string> = {
      user: 'bg-blue-100 text-blue-800 border-blue-200',       
      manual: 'bg-blue-100 text-blue-800 border-blue-200',     
      batch: 'bg-purple-100 text-purple-800 border-purple-200',
      api: 'bg-gray-100 text-gray-800 border-gray-200',         
      ui: 'bg-teal-100 text-teal-800 border-teal-200',
      unknown: 'bg-gray-100 text-gray-800 border-gray-200'      
    };

    if (!sourceType) {
      return (
        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${classes.unknown}`}>
          Unknown
        </span>
      );
    }
    const sourceTypeLower = sourceType.toLowerCase();
    let label = 'Unknown';
    if (sourceTypeLower.includes('user') || sourceTypeLower.includes('manual')) label = 'Manual Input';
    else if (sourceTypeLower.includes('batch')) label = 'Batch';
    else if (sourceTypeLower === 'ui') label = 'UI (Web)';
    else if (sourceTypeLower.includes('api')) label = 'API Input';
    
    const detail = sourceTypeLower.includes('batch') && createdBy ? ` (${createdBy})` : '';
    let badgeClass = classes.unknown;
    for (const [key, value] of Object.entries(classes)) {
      if (sourceTypeLower.includes(key)) {
        badgeClass = value;
        break;
      }
    }
    return (
      <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${badgeClass}`}>
        {label}{detail}
      </span>
    );
  };

  const getStatusBadge = (status: ClassificationStatus) => {
    // ... (existing code for getStatusBadge)
    if (status === 'all') {
        console.warn('Unexpected status "all" for individual item');
        return (
          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border bg-gray-100 text-gray-800 border-gray-200">
            Unknown
          </span>
        );
      }
      
      const classes = {
        success: 'bg-green-100 text-green-800 border-green-200',
        partial: 'bg-yellow-100 text-yellow-800 border-yellow-200',
        failed: 'bg-red-100 text-red-800 border-red-200'
      };
      
      const labels = {
        success: 'Success',
        partial: 'Partial',
        failed: 'Failed'
      };
  
      return (
        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${classes[status]}`}>
          {labels[status]}
        </span>
      );
  };

  return (
    <React.Fragment>
      <div className="max-w-8xl mx-auto space-y-10" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
        <div className="bg-white shadow-card rounded-card p-8 w-full" style={{ paddingRight: '5rem', paddingLeft: '3rem'}}>
          <div className="mb-2">

            {/* Filters */}
            <div className="grid grid-cols-1 md:grid-cols-7 gap-4">
              {/* System filter */}
              <div>
                <label htmlFor="system" className="block text-sm font-medium text-secondary-700 mb-2">
                  System
                </label>
                <select
                  id="system"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedSystem || ''}
                  onChange={(e) => setSelectedSystem(e.target.value || undefined)}
                >
                  <option value="">All Systems</option>
                  {systems.map((system) => (
                    <option key={system.code} value={system.code}>
                      {system.name || system.code}
                    </option>
                  ))}
                </select>
              </div>

              {/* Search Description */}
              <div>
                <label htmlFor="search" className="block text-sm font-medium text-secondary-700 mb-2">
                  Search Description
                </label>
                <input
                  type="text"
                  id="search"
                  placeholder="Search..."
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>

              {/* Status filter */}
              <div>
                <label htmlFor="status" className="block text-sm font-medium text-secondary-700 mb-2">
                  Status
                </label>
                <select
                  id="status"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedStatus}
                  onChange={(e) => setSelectedStatus(e.target.value as ClassificationStatus)}
                >
                  <option value="all">All Status</option>
                  <option value="success">Success</option>
                  <option value="partial">Partial</option>
                  <option value="failed">Failed</option>
                </select>
              </div>

              {/* Source Type filter */}
              <div>
                <label htmlFor="sourceType" className="block text-sm font-medium text-secondary-700 mb-2">
                  Source Type
                </label>
                <select
                  id="sourceType"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedSource || ''} 
                  onChange={(e) => setSelectedSource(e.target.value as '' | 'user' | 'batch' | 'api' | 'manual')}
                >
                  <option value="">All Sources</option>
                  <option value="manual">Manual</option> 
                  <option value="api">API</option> 
                  <option value="batch">Batch</option>
                  <option value="user">User (Legacy)</option>
                </select>
              </div>

              {/* Classifier filter */}
              <div>
                <label htmlFor="classifier" className="block text-sm font-medium text-secondary-700 mb-2">
                  Classified By
                </label>
                <select
                  id="classifier"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={selectedClassifier}
                  onChange={(e) => setSelectedClassifier(e.target.value)}
                >
                  <option value="">All</option>
                  {/* <option value="direct">Direct Input</option> -- consider how to filter user ID vs batch ID */}
                  {classifierOptions.map(opt => (
                    <option key={opt} value={opt}>
                        {/^\d+$/.test(opt) ? `User ID: ${opt}` : `Batch: ${opt}`}
                    </option>
                  ))}
                </select>
              </div>

              {/* Start Date filter */}
              <div>
                <label htmlFor="startDate" className="block text-sm font-medium text-secondary-700 mb-2">
                  Start Date
                </label>
                <input
                  type="date"
                  id="startDate"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={startDate}
                  onChange={(e) => setStartDate(e.target.value)}
                  max={endDate}
                />
              </div>

              {/* End Date filter */}
              <div>
                <label htmlFor="endDate" className="block text-sm font-medium text-secondary-700 mb-2">
                  End Date
                </label>
                <input
                  type="date"
                  id="endDate"
                  className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  value={endDate}
                  onChange={(e) => setEndDate(e.target.value)}
                  min={startDate}
                />
              </div>
            </div>
          </div>

          {error && (
            <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3 mb-6" role="alert">
              <p className="text-sm text-red-700">{error}</p>
            </div>
          )}

          {loading && (
            <div className="rounded-card border border-primary-200 bg-primary-50/50 px-4 py-3 mb-6" role="status">
              <p className="text-sm text-primary-700">Loading...</p>
            </div>
          )}

          <div className="overflow-x-auto rounded-card border border-secondary-200">
            <table className="min-w-full divide-y divide-secondary-200">
              <thead className="bg-secondary-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider max-w-72 truncate">
                    Description
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-24">
                    System
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-64">
                    Categories
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Source
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Date
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-40">
                    Classified By
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-secondary-200">
                {history.map((item) => (
                  <tr key={item.id} className={`hover:bg-secondary-50 ${
                    item.status === 'failed' && !isInformationalError(item.error) ? 'bg-red-50/30' : 
                    item.status === 'partial' || (item.status === 'failed' && isInformationalError(item.error)) ? 'bg-yellow-50/30' : ''
                  }`}>
                    <td className="px-6 py-4 text-sm text-secondary-900 max-w-72">
                      {item.ragContextUsed && item.ragContext ? (
                        <Tooltip
                          title={
                            <pre className="text-xs whitespace-pre-wrap max-w-md">
                              {item.ragContext}
                            </pre>
                          }
                          placement="topLeft"
                          overlayInnerStyle={{ backgroundColor: '#fff', color: '#333', border: '1px solid #ccc', padding: '8px', whiteSpace: 'pre-wrap' }}
                        >
                          <span className="truncate block cursor-help underline decoration-dotted decoration-primary-500">
                            {item.description}
                          </span>
                        </Tooltip>
                      ) : (
                        <span className="truncate block">{item.description}</span>
                      )}
                      {item.error && (
                        <div className={`mt-1 text-xs ${
                          isInformationalError(item.error) ? 'text-yellow-600' : 'text-red-600'
                        }`}>
                          {isInformationalError(item.error) ? `Note: ${item.error}` : `Error: ${item.error}`}
                        </div>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600 w-24">
                      {item.systemCode}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                      {getStatusBadge(item.status)}
                    </td>
                    <td className="px-6 py-4 text-sm w-64">
                      <div className="space-y-1">
                        {Object.entries(item.levels || {})
                          .sort(([a], [b]) => {
                            const levelOrder: Record<string, number> = {
                              'segment': 1, 'family': 2, 'class': 3, 'commodity': 4,
                              'SUBCAT1': 1, 'SUBCAT2': 2, 'default': 99 
                            };
                            const getOrder = (levelCode: string) => levelOrder[levelCode.toLowerCase()] ?? levelOrder['default'];
                            return getOrder(a) - getOrder(b);
                          })
                          .map(([levelCode, category]) => (
                          <div key={levelCode}>
                            <span className="font-medium text-secondary-700">{levelCode}:</span>{' '}
                            <span className="text-secondary-600">{category.code} - {category.name}</span>
                            {category.error && (
                              <div className="text-xs text-red-600 mt-0.5">
                                {category.error}
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600">
                      {getSourceBadge(item.sourceType as ClassificationSourceType, item.createdBy)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600">
                      <span title={formatDate(item.createdAt).fullText}>
                        {formatDate(item.createdAt).displayText}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-600 w-40">
                      {getClassifierBadge(item.createdBy)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                    <button
                        onClick={() => handleView(item)}
                        className="group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium text-secondary-700 border border-secondary-200 rounded-lg hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm mr-1"
                        disabled={!checkPermission('history:view')}
                        title={!checkPermission('history:view') ? "Permission denied" : "View details"}
                      >
                        <svg 
                          className={`w-4 h-4 ${!checkPermission('history:view') ? 'text-secondary-300' : 'text-secondary-500 group-hover:text-secondary-700'} transition-colors`}
                          fill="none" 
                          viewBox="0 0 24 24" 
                          stroke="currentColor"
                        >
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden">
                          <div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div>
                        </div>
                      </button>
                      <button
                        onClick={() => handleReclassify(item)}
                        className={`group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium border border-secondary-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm ${
                          !checkPermission('classify:manual') 
                          ? 'text-secondary-400 border-secondary-200 cursor-not-allowed opacity-50' 
                          : 'text-secondary-700 hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900'
                        }`}
                        disabled={!checkPermission('classify:manual')}
                        title={!checkPermission('classify:manual') ? "Permission denied" : "Manually reclassify"}
                      >
                        <svg className={`w-4 h-4 ${!checkPermission('classify:manual') ? 'text-secondary-300' : 'text-secondary-500 group-hover:text-secondary-700'} transition-colors`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden"><div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div></div>
                      </button>
                      <button
                        onClick={() => handleRerun(item)}
                        className={`group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium border border-secondary-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-all duration-200 shadow-sm ${
                           !checkPermission('history:rerun') 
                           ? 'text-secondary-400 border-secondary-200 cursor-not-allowed opacity-50' 
                           : 'text-secondary-700 hover:bg-secondary-50 hover:border-secondary-300 hover:text-secondary-900'
                        }`}
                        disabled={!checkPermission('history:rerun')}
                        title={!checkPermission('history:rerun') ? "Permission denied" : "Rerun classification"}
                      >
                        <svg className={`w-4 h-4 ${!checkPermission('history:rerun') ? 'text-secondary-300' : 'text-secondary-500 group-hover:text-secondary-700'} transition-colors`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden"><div className="absolute inset-0 bg-gradient-to-r from-primary-100 to-secondary-100 opacity-0 group-hover:opacity-10 transition-opacity"></div></div>
                      </button>
                      <button
                        onClick={() => handleDelete(item)}
                        className={`group relative inline-flex items-center gap-1.5 px-3 py-2 bg-white text-sm font-medium border rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-all duration-200 shadow-sm ${
                            !checkPermission('history:delete') 
                            ? 'text-red-300 border-red-100 cursor-not-allowed opacity-50' 
                            : 'text-red-600 border-red-200 hover:bg-red-50 hover:border-red-300 hover:text-red-700'
                         }`}
                        disabled={!checkPermission('history:delete')}
                        title={!checkPermission('history:delete') ? "Permission denied" : "Delete classification"}
                      >
                        <svg className={`w-4 h-4 ${!checkPermission('history:delete') ? 'text-red-300' : 'text-red-500 group-hover:text-red-700'} transition-colors`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                        <div className="absolute inset-0 rounded-lg overflow-hidden"><div className="absolute inset-0 bg-gradient-to-r from-red-100 to-red-50 opacity-0 group-hover:opacity-10 transition-opacity"></div></div>
                      </button>
                    </td>
                  </tr>
                ))}
                {history.length === 0 && (
                  <tr>
                    <td colSpan={8} className="px-6 py-8 text-center text-sm text-secondary-500">
                      No classifications found matching the current filters.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>

          {/* Pagination controls */}
          <div className="mt-6 flex items-center justify-between">
            <div className="flex-1 flex justify-between items-center">
                <p className="text-sm text-secondary-600">
                {history.length > 0
                    ? `Showing ${Math.min((currentPage - 1) * pageSize + 1, totalCount)} - ${Math.min(currentPage * pageSize, totalCount)} of ${totalCount} results`
                    : 'No results found'}
                </p>
                
                <div className="flex items-center gap-2">
                <button
                    onClick={() => handlePageChange(1)}
                    disabled={currentPage === 1 || loading}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >First</button>
                <button
                    onClick={() => handlePageChange(currentPage - 1)}
                    disabled={currentPage === 1 || loading}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >Previous</button>

                {(() => {
                    const pages = [];
                    const maxButtons = 5;
                    let start = Math.max(1, currentPage - Math.floor(maxButtons / 2));
                    let end = Math.min(start + maxButtons - 1, totalPages);
                    if (end === totalPages) start = Math.max(1, end - maxButtons + 1);
                    if (start > 1) pages.push(<span key="start-dots" className="px-2 py-2 text-secondary-500">...</span>);
                    for (let i = start; i <= end; i++) {
                    pages.push(
                        <button
                        key={i}
                        onClick={() => handlePageChange(i)}
                        disabled={loading || (i > currentPage && !pageCursors[currentPage - 1])}
                        className={`px-3 py-2 rounded-lg border text-sm font-medium ${
                            i === currentPage ? 'bg-primary-600 text-white border-primary-600' : 'border-secondary-200 text-secondary-700 hover:bg-secondary-50'
                        }`}
                        >{i}</button>
                    );
                    }
                    if (end < totalPages) pages.push(<span key="end-dots" className="px-2 py-2 text-secondary-500">...</span>);
                    return pages;
                })()}

                <button
                    onClick={() => handlePageChange(currentPage + 1)}
                    disabled={currentPage === totalPages || loading || (currentPage < totalPages && !pageCursors[currentPage - 1])}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >Next</button>
                <button
                    onClick={() => handlePageChange(totalPages)}
                    disabled={currentPage === totalPages || loading || totalPages <= 1}
                    className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                >Last</button>
                </div>
            </div>
           </div>
        </div>
      </div>

      {selectedItem && (
        <ManualClassificationModal
          isOpen={showManualModal}
          onClose={() => {
            setShowManualModal(false);
            setSelectedItem(null);
          }}
          onSubmit={handleManualClassification}
          apiClient={apiClient}
          description={selectedItem.description}
          systemCode={selectedItem.systemCode} 
          initialLevels={Object.fromEntries(
            Object.entries(selectedItem.levels).map(([code, category]) => [code, category.code])
          )}
        />
      )}
      <RerunStatusModal
        isOpen={showRerunModal}
        description={rerunningItem?.description || ''}
      />
      {detailsItem && (
        <ClassificationDetailsModal
          isOpen={showDetailsModal}
          onClose={() => {
            setShowDetailsModal(false);
            setDetailsItem(null);
          }}
          item={detailsItem}
        />
      )}
    </React.Fragment>
  );
};

export default HistoryTab;

File: src/components/UserManagement/components/UserFormModal.tsx
// src/components/UserManagement/components/UserFormModal.tsx
import React, { useEffect, useState } from 'react'; // Add useState import
import { Modal, Form, Input, Select, Button, Spin, Alert, message } from 'antd';
import { User, Role, CreateUserRequest, UpdateUserRequest } from '../../../api/types';

interface UserFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: CreateUserRequest | UpdateUserRequest) => Promise<boolean>; // Returns success status
  initialData?: User;
  availableRoles: Role[]; // Pass available roles for selection
  loading: boolean; // Loading state for submission
  loadingRoles: boolean; // Loading state for roles dropdown
}

const { Option } = Select;

export const UserFormModal: React.FC<UserFormModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  initialData,
  availableRoles,
  loading,
  loadingRoles,
}) => {
  const [form] = Form.useForm();
  const [formError, setFormError] = useState<string | null>(null);

  const isEditMode = !!initialData;

  useEffect(() => {
    if (isOpen) {
      setFormError(null); // Clear errors when opening
      if (isEditMode && initialData) {
        form.setFieldsValue({
          username: initialData.username,
          roles: initialData.roles || [],
          // Don't set password field for edit mode unless changing password
        });
      } else {
        form.resetFields();
      }
    }
  }, [isOpen, initialData, form, isEditMode]);

  const handleFinish = async (values: any) => {
    setFormError(null);
    const roles = values.roles || []; // Ensure roles is an array

    let success = false;
    if (isEditMode && initialData) {
      const updateData: UpdateUserRequest = {
        username: values.username !== initialData.username ? values.username : undefined,
        password: values.password || undefined, // Only include password if provided
        roles: roles, // Always send roles to potentially update
      };
      // Filter out undefined fields before sending
      const filteredUpdateData = Object.fromEntries(
          Object.entries(updateData).filter(([_, v]) => v !== undefined)
      ) as UpdateUserRequest;

      // Check if anything actually changed
      if (Object.keys(filteredUpdateData).length === 0 && JSON.stringify(roles) === JSON.stringify(initialData.roles || [])) {
         message.info("No changes detected.");
         onClose(); // Close if no changes
         return;
      }

      success = await onSubmit(filteredUpdateData);
    } else {
      const createData: CreateUserRequest = {
        username: values.username,
        password: values.password,
        roles: roles,
      };
      success = await onSubmit(createData);
    }

    if (success) {
      onClose(); // Close modal on successful submission
    } else {
      // Error message is usually shown via Ant message in the hook
      setFormError("Failed to save user. Please try again.");
    }
  };

  const filterOption = (input: string, option: any) => {
    const childText = option?.children;
    return childText && typeof childText === 'string' 
      ? childText.toLowerCase().includes(input.toLowerCase()) 
      : false;
  };

  return (
    <Modal
      title={isEditMode ? `Edit User: ${initialData?.username}` : 'Create New User'}
      open={isOpen}
      visible={isOpen} /* Added for backward compatibility with Ant Design v4 */
      onCancel={onClose}
      confirmLoading={loading}
      destroyOnClose // Reset form state when closed
      footer={[
        <Button key="back" onClick={onClose} disabled={loading}>
          Cancel
        </Button>,
        <Button key="submit" type="primary" loading={loading} onClick={() => form.submit()}>
          {isEditMode ? 'Save Changes' : 'Create User'}
        </Button>,
      ]}
      width={600}
    >
      <Spin spinning={loading || loadingRoles}>
        {formError && <Alert message={formError} type="error" showIcon closable onClose={() => setFormError(null)} className="mb-4" />}
        <Form
          form={form}
          layout="vertical"
          onFinish={handleFinish}
          name="userForm"
          initialValues={{ roles: isEditMode ? initialData?.roles : [] }} // Set initial roles
        >
          <Form.Item
            name="username"
            label="Username"
            rules={[{ required: true, message: 'Please input the username!' }]}
          >
            <Input placeholder="Enter username" disabled={isEditMode} />
            {/* Username usually not editable */}
          </Form.Item>

          <Form.Item
            name="password"
            label={isEditMode ? 'New Password (leave blank to keep current)' : 'Password'}
            rules={[{ required: !isEditMode, message: 'Password is required for new users!' }]}
            hasFeedback
          >
            <Input.Password placeholder={isEditMode ? 'Enter new password' : 'Enter password'} />
          </Form.Item>

          {isEditMode && (
            <Form.Item
              name="confirmPassword"
              label="Confirm New Password"
              dependencies={['password']}
              hasFeedback
              rules={[
                ({ getFieldValue }) => ({
                  validator(_, value) {
                    if (!getFieldValue('password') || !value || getFieldValue('password') === value) {
                      return Promise.resolve();
                    }
                    return Promise.reject(new Error('The two passwords that you entered do not match!'));
                  },
                }),
              ]}
            >
              <Input.Password placeholder="Confirm new password" />
            </Form.Item>
          )}

          <Form.Item
            name="roles"
            label="Roles"
             rules={[{ type: 'array' }]} // Antd rule for array type
          >
             <Select
               mode="multiple"
               allowClear
               style={{ width: '100%' }}
               placeholder="Select roles"
               loading={loadingRoles}
               disabled={loadingRoles}
               filterOption={filterOption}
             >
               {availableRoles.map(role => (
                 <Option key={role.id} value={role.name} label={role.name}>
                   <div className="flex flex-col">
                      <span>{role.name}</span>
                      {role.description && <span className="text-xs text-gray-500">{role.description}</span>}
                   </div>
                 </Option>
               ))}
             </Select>
          </Form.Item>

        </Form>
      </Spin>
    </Modal>
  );
};

File: src/components/UserManagement/hooks/useUsers.ts
// src/components/UserManagement/hooks/useUsers.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { message } from 'antd';
import {
  ApiClient, User, Role, CreateUserRequest, UpdateUserRequest,
  UserListResponse, RoleListResponse
} from '../../../api/types';

export interface UseUsersResult {
  users: User[];
  roles: Role[]; // Available roles for assignment
  loading: boolean;
  loadingRoles: boolean;
  error: string | null;
  totalUsers: number;
  pagination: { current: number; pageSize: number; total: number };
  fetchUsers: (page?: number, pageSize?: number, search?: string) => Promise<void>;
  createUser: (data: CreateUserRequest) => Promise<User | null>;
  updateUser: (id: number, data: UpdateUserRequest) => Promise<User | null>;
  deleteUser: (id: number) => Promise<boolean>;
}

const DEFAULT_PAGE_SIZE = 10;

export function useUsers(apiClient: ApiClient): UseUsersResult {
  const mountedRef = useRef(true);
  const [users, setUsers] = useState<User[]>([]);
  const [roles, setRoles] = useState<Role[]>([]); // Store available roles
  const [totalUsers, setTotalUsers] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(DEFAULT_PAGE_SIZE);
  const [loading, setLoading] = useState(true);
  const [loadingRoles, setLoadingRoles] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const currentSearchRef = useRef<string | undefined>(undefined); // Keep track of search term

  // Safe state setters
  const safeSetState = <T>(setter: React.Dispatch<React.SetStateAction<T>>) =>
    (value: T | ((prevState: T) => T)) => {
      if (mountedRef.current) {
        setter(value);
      }
    };

  const safeSetUsers = safeSetState(setUsers);
  const safeSetRoles = safeSetState(setRoles);
  const safeSetTotalUsers = safeSetState(setTotalUsers);
  const safeSetCurrentPage = safeSetState(setCurrentPage);
  const safeSetPageSize = safeSetState(setPageSize);
  const safeSetLoading = safeSetState(setLoading);
  const safeSetLoadingRoles = safeSetState(setLoadingRoles);
  const safeSetError = safeSetState(setError);

  // Fetch Users Function
  const fetchUsers = useCallback(async (
    page = currentPage,
    limit = pageSize,
    search?: string
  ) => {
    if (!mountedRef.current) return;
    safeSetLoading(true);
    safeSetError(null);
    currentSearchRef.current = search; // Store current search

    try {
      const offset = (page - 1) * limit;
      const response = await apiClient.getUsers({ limit, offset, search });
      // Check if the request is still the latest one (based on search term)
      if (mountedRef.current && currentSearchRef.current === search) {
        safeSetUsers(response.items || []);
        safeSetTotalUsers(response.totalCount || 0);
        safeSetCurrentPage(page);
        safeSetPageSize(limit);
      }
    } catch (err) {
       if (mountedRef.current && currentSearchRef.current === search) {
           console.error('Failed to fetch users:', err);
           const errorMsg = err instanceof Error ? err.message : 'Failed to load users';
           safeSetError(errorMsg);
           message.error(errorMsg); // Show Ant Design message
           safeSetUsers([]);
           safeSetTotalUsers(0);
       }
    } finally {
      if (mountedRef.current && currentSearchRef.current === search) {
          safeSetLoading(false);
      }
    }
  }, [apiClient, currentPage, pageSize, safeSetLoading, safeSetError, safeSetUsers, safeSetTotalUsers, safeSetCurrentPage, safeSetPageSize]);

  // Fetch Available Roles Function
  const fetchRoles = useCallback(async () => {
    if (!mountedRef.current) return;
    safeSetLoadingRoles(true);
    try {
        // Fetch all roles (assuming pagination isn't strictly needed for dropdown)
        // Adjust if your backend needs specific parameters or handles large role lists
      const response: RoleListResponse = await apiClient.getRoles({ limit: 500 }); // Fetch a large number
      if (mountedRef.current) {
        safeSetRoles(response.items || []);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('Failed to fetch roles:', err);
        message.error('Failed to load available roles for assignment.');
        safeSetRoles([]); // Set empty on error
      }
    } finally {
       if (mountedRef.current) {
           safeSetLoadingRoles(false);
       }
    }
  }, [apiClient, safeSetLoadingRoles, safeSetRoles]);


  // Initial Fetch & Fetch on Param Change
  useEffect(() => {
    fetchUsers(1, pageSize); // Fetch first page on mount/filter change
  }, [fetchUsers, pageSize]); // Rerun only when fetchUsers changes (due to apiClient) or pageSize

   // Fetch roles on mount
   useEffect(() => {
       fetchRoles();
   }, [fetchRoles]);


  // CRUD Operations
  const createUser = useCallback(async (data: CreateUserRequest): Promise<User | null> => {
    safeSetLoading(true); // Indicate loading during create
    safeSetError(null);
    try {
      const newUser = await apiClient.createUser(data);
      message.success(`User "${newUser.username}" created successfully.`);
      await fetchUsers(1, pageSize); // Refresh list from page 1
      return newUser;
    } catch (err) {
      console.error('Failed to create user:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to create user';
      safeSetError(errorMsg);
      message.error(errorMsg);
      return null;
    } finally {
       safeSetLoading(false);
    }
  }, [apiClient, fetchUsers, pageSize, safeSetLoading, safeSetError]);

  const updateUser = useCallback(async (id: number, data: UpdateUserRequest): Promise<User | null> => {
     safeSetLoading(true);
     safeSetError(null);
    try {
      const updatedUser = await apiClient.updateUser(id, data);
      message.success(`User "${updatedUser.username}" updated successfully.`);
      // Refresh only the current page for a potentially smoother experience
      await fetchUsers(currentPage, pageSize, currentSearchRef.current);
      return updatedUser;
    } catch (err) {
      console.error('Failed to update user:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to update user';
      safeSetError(errorMsg);
      message.error(errorMsg);
      return null;
    } finally {
       safeSetLoading(false);
    }
  }, [apiClient, fetchUsers, currentPage, pageSize, safeSetLoading, safeSetError]);

  const deleteUser = useCallback(async (id: number): Promise<boolean> => {
     safeSetLoading(true);
     safeSetError(null);
    try {
      await apiClient.deleteUser(id);
      message.success(`User deleted successfully.`);
       // Check if the deleted item was the last on the current page
       const newTotal = totalUsers - 1;
       const newTotalPages = Math.ceil(newTotal / pageSize);
       const pageToFetch = (currentPage > newTotalPages && newTotalPages > 0) ? newTotalPages : currentPage;
       // Refresh potentially adjusted page
       await fetchUsers(pageToFetch, pageSize, currentSearchRef.current);
       if (pageToFetch !== currentPage) safeSetCurrentPage(pageToFetch); // Update page state if changed
      return true;
    } catch (err) {
      console.error('Failed to delete user:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to delete user';
      safeSetError(errorMsg);
      message.error(errorMsg);
      return false;
    } finally {
       safeSetLoading(false);
    }
  }, [apiClient, fetchUsers, currentPage, pageSize, totalUsers, safeSetLoading, safeSetError, safeSetCurrentPage]);

  // Unmount cleanup
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  return {
    users,
    roles, // Provide roles
    loading,
    loadingRoles, // Provide roles loading state
    error,
    totalUsers,
    pagination: {
      current: currentPage,
      pageSize: pageSize,
      total: totalUsers,
    },
    fetchUsers,
    createUser,
    updateUser,
    deleteUser,
  };
}

File: src/components/__tests__/ConfigValue.test.tsx
import React from 'react';
import { render } from '@testing-library/react';
import '@testing-library/jest-dom';
import { RenderResult } from '@testing-library/react';
import ConfigValue from '../ConfigValue';

describe('ConfigValue', () => {
  let renderResult: RenderResult;

  const renderComponent = (props: { configKey: string; value: any; className?: string }) => {
    renderResult = render(<ConfigValue {...props} />);
    return renderResult;
  };

  it('renders "Not set" for null or undefined values', () => {
    const { getByText } = renderComponent({ configKey: 'test', value: null });
    expect(getByText('Not set')).toBeInTheDocument();

    renderResult.rerender(<ConfigValue configKey="test" value={undefined} />);
    expect(getByText('Not set')).toBeInTheDocument();
  });

  it('masks sensitive values', () => {
    const { getByText } = renderComponent({ configKey: 'password', value: 'secret' });
    expect(getByText('********')).toBeInTheDocument();

    renderResult.rerender(<ConfigValue configKey="apiKey" value="secret" />);
    expect(getByText('********')).toBeInTheDocument();
  });

  it('renders boolean values with correct styling', () => {
    const { container: trueContainer } = renderComponent({ configKey: 'enabled', value: true });
    const { container: falseContainer } = render(<ConfigValue configKey="enabled" value={false} />);

    const trueElement = trueContainer.firstElementChild;
    const falseElement = falseContainer.firstElementChild;

    expect(trueElement).toHaveClass('bg-green-100', 'text-green-800');
    expect(falseElement).toHaveClass('bg-red-100', 'text-red-800');
  });

  it('handles complex objects', () => {
    const { getByText } = renderComponent({ configKey: 'config', value: { test: true } });
    expect(getByText('Complex object')).toBeInTheDocument();
  });

  it('displays array length', () => {
    const { getByText } = renderComponent({ configKey: 'items', value: [1, 2, 3] });
    expect(getByText('Array[3]')).toBeInTheDocument();
  });

  it('renders string values', () => {
    const { getByText } = renderComponent({ configKey: 'name', value: 'test-value' });
    expect(getByText('test-value')).toBeInTheDocument();
  });

  it('applies custom className prop', () => {
    const { container } = renderComponent({
      configKey: 'test',
      value: 'value',
      className: 'custom-class'
    });
    expect(container.firstElementChild).toHaveClass('custom-class');
  });
});

File: src/components/RagInfoTab/index.ts
// src/components/RagInfoTab/index.ts
export { RagInfoTab } from './RagInfoTab';

File: src/components/RagInfoTab/hooks/useRagInfo.ts
// src/components/RagInfoTab/hooks/useRagInfo.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  ApiClient,
  RagInfoItem,
  RagInfoPage,
  RagInfoRequestParams,
  CreateRagInfoRequest,
  UpdateRagInfoRequest,
} from '../../../api/types'; // Adjust path as needed

const PAGE_SIZE = 10; // Or your preferred page size

export interface UseRagInfoResult {
  items: RagInfoItem[];
  loading: boolean;
  error: string | undefined;
  totalCount: number;
  totalPages: number;
  currentPage: number;
  searchTerm: string;
  setCurrentPage: (page: number) => void;
  setSearchTerm: (term: string) => void;
  refreshList: () => Promise<void>;
  createItem: (data: CreateRagInfoRequest) => Promise<RagInfoItem | null>;
  updateItem: (id: string, data: UpdateRagInfoRequest) => Promise<RagInfoItem | null>;
  deleteItem: (id: string) => Promise<boolean>;
  fetchAllForExport: (search?: string) => Promise<RagInfoItem[]>; // New method for export
}

export function useRagInfo(apiClient: ApiClient): UseRagInfoResult {
  const mountedRef = useRef(true);
  const [items, setItems] = useState<RagInfoItem[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [currentPage, setCurrentPage] = useState(1);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | undefined>(undefined);
  const [searchTerm, setSearchTerm] = useState('');

  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Safe state setters
  const safeSetItems = useCallback((data: RagInfoItem[]) => { if (mountedRef.current) setItems(data); }, []);
  const safeSetTotalCount = useCallback((count: number) => { if (mountedRef.current) setTotalCount(count); }, []);
  const safeSetTotalPages = useCallback((pages: number) => { if (mountedRef.current) setTotalPages(pages); }, []);
  const safeSetCurrentPage = useCallback((page: number) => { if (mountedRef.current) setCurrentPage(page); }, []);
  const safeSetLoading = useCallback((isLoading: boolean) => { if (mountedRef.current) setLoading(isLoading); }, []);
  const safeSetError = useCallback((err: string | undefined) => { if (mountedRef.current) setError(err); }, []);

  const fetchList = useCallback(async (page: number, search: string) => {
    safeSetLoading(true);
    safeSetError(undefined);
    console.log(`Fetching RAG Info - Page: ${page}, Search: "${search}"`);
    try {
      const params: RagInfoRequestParams = {
        page,
        limit: PAGE_SIZE,
        search: search.trim() || undefined,
      };
      const result = await apiClient.getRagInfoList(params);
      safeSetItems(result.items);
      safeSetTotalCount(result.totalCount);
      safeSetTotalPages(result.totalPages);
      // Ensure current page from response is reflected, though usually driven by request
      if (result.currentPage !== page) {
        console.warn(`API response page ${result.currentPage} differs from requested page ${page}`);
        // Optionally force set page based on response: safeSetCurrentPage(result.currentPage);
      }
    } catch (err) {
      console.error('Failed to fetch RAG info list:', err);
      safeSetError(err instanceof Error ? err.message : 'Failed to load data');
      safeSetItems([]);
      safeSetTotalCount(0);
      safeSetTotalPages(1);
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, safeSetItems, safeSetTotalCount, safeSetTotalPages, safeSetLoading, safeSetError]);

  // New function to fetch all items for export
  const fetchAllForExport = useCallback(async (search?: string): Promise<RagInfoItem[]> => {
    console.log(`Fetching all RAG info items for export. Search filter: "${search || ''}"`);
    
    try {
      // First, try to get a count of all items with the optional search filter
      const countParams: RagInfoRequestParams = {
        page: 1,
        limit: 1, // Just need count, not actual items
        search: search?.trim(),
      };
      
      const countResult = await apiClient.getRagInfoList(countParams);
      const totalItems = countResult.totalCount;
      
      if (totalItems === 0) {
        return []; // No items to export
      }
      
      // Calculate how many pages we need to fetch with a larger page size for efficiency
      const exportPageSize = 100; // Use a larger page size for export
      const pagesToFetch = Math.ceil(totalItems / exportPageSize);
      
      // Fetch all pages in parallel
      const requests: Promise<RagInfoPage>[] = [];
      for (let i = 1; i <= pagesToFetch; i++) {
        const params: RagInfoRequestParams = {
          page: i,
          limit: exportPageSize,
          search: search?.trim(),
        };
        requests.push(apiClient.getRagInfoList(params));
      }
      
      const results = await Promise.all(requests);
      
      // Combine all items from all pages
      const allItems: RagInfoItem[] = [];
      results.forEach(result => {
        allItems.push(...result.items);
      });
      
      console.log(`Successfully fetched ${allItems.length} items for export`);
      return allItems;
    } catch (err) {
      console.error('Failed to fetch all items for export:', err);
      throw new Error(err instanceof Error ? err.message : 'Failed to export data');
    }
  }, [apiClient]);

  // Effect to fetch data when page or search term changes (debounced)
  useEffect(() => {
    if (debounceTimeoutRef.current) {
      clearTimeout(debounceTimeoutRef.current);
    }
    debounceTimeoutRef.current = setTimeout(() => {
        // Reset to page 1 when search term changes
        const pageToFetch = searchTerm !== (debounceTimeoutRef.current as any)?.lastSearchTerm ? 1 : currentPage;
        if (pageToFetch === 1 && currentPage !== 1) {
            safeSetCurrentPage(1); // Reset page state visually
        }
        fetchList(pageToFetch, searchTerm);
        (debounceTimeoutRef.current as any).lastSearchTerm = searchTerm; // Store last search term
    }, 300); // 300ms debounce

    return () => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
    };
  }, [currentPage, searchTerm, fetchList, safeSetCurrentPage]);

   // Cleanup on unmount
   useEffect(() => {
       mountedRef.current = true;
       return () => {
           mountedRef.current = false;
           if (debounceTimeoutRef.current) {
               clearTimeout(debounceTimeoutRef.current);
           }
       };
   }, []);

  const refreshList = useCallback(async () => {
    await fetchList(currentPage, searchTerm);
  }, [fetchList, currentPage, searchTerm]);

  const createItem = useCallback(async (data: CreateRagInfoRequest): Promise<RagInfoItem | null> => {
    safeSetLoading(true);
    safeSetError(undefined);
    try {
      const newItem = await apiClient.createRagInfo(data);
      await refreshList(); // Refresh list after creation
      return newItem;
    } catch (err) {
      safeSetError(err instanceof Error ? err.message : 'Failed to create item');
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, refreshList, safeSetLoading, safeSetError]);

  const updateItem = useCallback(async (id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem | null> => {
    safeSetLoading(true);
    safeSetError(undefined);
    try {
      const updatedItem = await apiClient.updateRagInfo(id, data);
      // Update item in the local list optimistically or refresh
       setItems(prevItems => prevItems.map(item => item.id === id ? updatedItem : item));
      // await refreshList(); // Or refresh for simplicity
      return updatedItem;
    } catch (err) {
      safeSetError(err instanceof Error ? err.message : 'Failed to update item');
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, /* refreshList */ safeSetLoading, safeSetError]);

  const deleteItem = useCallback(async (id: string): Promise<boolean> => {
    safeSetLoading(true);
    safeSetError(undefined);
    try {
      await apiClient.deleteRagInfo(id);
      // Remove item locally or refresh
      setItems(prevItems => prevItems.filter(item => item.id !== id));
      // Decrement total count (be careful with pagination edge cases)
      setTotalCount(prev => Math.max(0, prev - 1));
      // Optional: Check if current page becomes empty and go back one page
      // await refreshList(); // Or refresh for simplicity
      return true;
    } catch (err) {
      safeSetError(err instanceof Error ? err.message : 'Failed to delete item');
      return false;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, /* refreshList */ safeSetLoading, safeSetError]);


  return {
    items,
    loading,
    error,
    totalCount,
    totalPages,
    currentPage,
    searchTerm,
    setCurrentPage: safeSetCurrentPage, // Expose safe setter
    setSearchTerm, // Direct setter is fine for input state
    refreshList,
    createItem,
    updateItem,
    deleteItem,
    fetchAllForExport, // Expose the new method for export
  };
}

File: src/components/RagInfoTab/components/RagInfoFormModal.tsx
// src/components/RagInfoTab/components/RagInfoFormModal.tsx
import React, { useState, useEffect } from 'react';
import { RagInfoItem, CreateRagInfoRequest, UpdateRagInfoRequest } from '../../../api/types'; // Adjust path

interface RagInfoFormModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: CreateRagInfoRequest | UpdateRagInfoRequest) => Promise<boolean>; // Returns true on success
    initialData?: RagInfoItem; // For editing
    loading: boolean;
}

export const RagInfoFormModal: React.FC<RagInfoFormModalProps> = ({
    isOpen,
    onClose,
    onSubmit,
    initialData,
    loading
}) => {
    const [key, setKey] = useState('');
    const [description, setDescription] = useState('');
    const [error, setError] = useState<string | null>(null);

    const isEditMode = !!initialData;

    useEffect(() => {
        if (isOpen) {
            if (isEditMode) {
                setKey(initialData.key);
                setDescription(initialData.description);
            } else {
                setKey('');
                setDescription('');
            }
            setError(null); // Reset error when modal opens
        }
    }, [isOpen, initialData, isEditMode]);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        if (!key.trim() || !description.trim()) {
            setError('Key and Description cannot be empty.');
            return;
        }

        const data: CreateRagInfoRequest | UpdateRagInfoRequest = isEditMode
            ? { description: description.trim() } // Only allow updating description for now
            : { key: key.trim(), description: description.trim() };

        const success = await onSubmit(data);
        if (success) {
            onClose();
        } else {
             // Assuming the hook sets the error state visible in the main tab
             // If you want modal-specific errors, onSubmit should return error message
            setError("Operation failed. Please check the main page for errors.");
        }
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg shadow-xl max-w-lg w-full max-h-[90vh] overflow-y-auto">
                <form onSubmit={handleSubmit}>
                    <div className="p-6">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-semibold text-secondary-900">
                                {isEditMode ? 'Edit Information' : 'Add New Information'}
                            </h2>
                            <button
                                type="button"
                                onClick={onClose}
                                className="text-secondary-400 hover:text-secondary-600"
                                disabled={loading}
                                aria-label="Close modal"
                            >
                                <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>

                        {error && (
                            <div className="mb-4 rounded-md border border-red-200 bg-red-50 p-3 text-sm text-red-700">
                                {error}
                            </div>
                        )}

                        <div className="space-y-4">
                            <div>
                                <label htmlFor="ragKey" className="label">Key *</label>
                                <input
                                    type="text"
                                    id="ragKey"
                                    value={key}
                                    onChange={(e) => setKey(e.target.value)}
                                    className="input"
                                    required
                                    disabled={isEditMode || loading} // Disable key editing in edit mode
                                />
                                 {isEditMode && <p className="text-xs text-secondary-500 mt-1">Key cannot be changed after creation.</p>}
                            </div>
                            <div>
                                <label htmlFor="ragDescription" className="label">Description *</label>
                                <textarea
                                    id="ragDescription"
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    className="input" // Use global style
                                    rows={4}
                                    required
                                    disabled={loading}
                                />
                            </div>
                        </div>
                    </div>

                    <div className="bg-secondary-50 px-6 py-3 flex justify-end space-x-3">
                        <button
                            type="button"
                            onClick={onClose}
                            className="btn btn-secondary" // Use global style
                            disabled={loading}
                        >
                            Cancel
                        </button>
                        <button
                            type="submit"
                            className="btn btn-primary" // Use global style
                            disabled={loading || !key.trim() || !description.trim()}
                        >
                            {loading ? 'Saving...' : (isEditMode ? 'Save Changes' : 'Add Information')}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

File: src/components/RoleManagement/components/PermissionAssignmentModal.tsx
// src/components/RoleManagement/components/PermissionAssignmentModal.tsx
import React, { useEffect, useState, useMemo } from 'react';
import { Modal, Form, Button, Spin, Alert, Checkbox, Row, Col, Tooltip, Input, Empty, Tag } from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { Role, Permission, UpdateRoleRequest } from '../../../api/types'; 

interface PermissionAssignmentModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (roleId: number, permissionCodes: string[]) => Promise<boolean>; // Takes role ID and codes, returns success
    role: Role | null; // The role being edited
    availablePermissions: Permission[];
    loading: boolean; // Loading state for the submission process
    loadingPermissions: boolean; // Loading state for fetching permissions
}

const { Search } = Input;

export const PermissionAssignmentModal: React.FC<PermissionAssignmentModalProps> = ({
    isOpen,
    onClose,
    onSubmit,
    role,
    availablePermissions,
    loading,
    loadingPermissions,
}) => {
    const [form] = Form.useForm();
    const [formError, setFormError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');

    const isCoreRole = role?.name === 'admin' || role?.name === 'classifier'; // Basic check for core roles

    // Set initial form values when the modal opens or the role changes
    useEffect(() => {
        if (isOpen && role) {
            setFormError(null);
            form.setFieldsValue({
                // Get the codes from the role's permissions array
                permissions: (role.permissions || []).map(p => p.code),
            });
        } else if (!isOpen) {
            form.resetFields(); // Reset form when closing
            setSearchTerm(''); // Reset search term
        }
    }, [isOpen, role, form]);

    // Filter permissions based on search term
    const filteredPermissions = useMemo(() => {
        if (!searchTerm) {
            return availablePermissions;
        }
        const lowerSearch = searchTerm.toLowerCase();
        return availablePermissions.filter(
            (perm) =>
                perm.code.toLowerCase().includes(lowerSearch) ||
                (perm.description && perm.description.toLowerCase().includes(lowerSearch))
        );
    }, [availablePermissions, searchTerm]);

    const handleFinish = async (values: { permissions: string[] }) => {
        if (!role) return;
        setFormError(null);
        const selectedPermissionCodes = values.permissions || [];

        try {
            const success = await onSubmit(role.id, selectedPermissionCodes);
            if (success) {
                onClose(); // Close modal on successful submission from parent
            } else {
                // Error handling might be done in the parent hook via message.error
                setFormError("Failed to update role permissions. Please try again.");
            }
        } catch (error) {
             console.error("Error submitting permissions:", error);
             setFormError(error instanceof Error ? error.message : "An unexpected error occurred.");
        }
    };

    // Group permissions by category (e.g., 'classify:', 'users:') for better organization
    const groupedPermissions = useMemo(() => {
        const groups: Record<string, Permission[]> = {};
        filteredPermissions.forEach(perm => {
            const category = perm.code.split(':')[0] || 'other';
            if (!groups[category]) {
                groups[category] = [];
            }
            groups[category].push(perm);
        });
         // Sort categories alphabetically, put 'other' last
         return Object.entries(groups).sort(([catA], [catB]) => {
            if (catA === 'other') return 1;
            if (catB === 'other') return -1;
            return catA.localeCompare(catB);
        });
    }, [filteredPermissions]);

    return (
        <Modal
            title={`Manage Permissions for Role: "${role?.name}"`}
            open={isOpen}
            onCancel={onClose}
            confirmLoading={loading}
            destroyOnClose
            width={800} // Wider modal for better permission layout
            footer={[
                <Button key="back" onClick={onClose} disabled={loading}>
                    Cancel
                </Button>,
                <Button key="submit" type="primary" loading={loading} onClick={() => form.submit()}>
                    Save Permissions
                </Button>,
            ]}
        >
            <Spin spinning={loadingPermissions || loading} tip={loadingPermissions ? "Loading permissions..." : "Saving..."}>
                {formError && <Alert message={formError} type="error" showIcon closable onClose={() => setFormError(null)} className="mb-4" />}

                {isCoreRole && (
                    <Alert
                        message="Core Role"
                        description={`Modifying permissions for the core "${role?.name}" role is restricted and may have unintended consequences.`}
                        type="warning"
                        showIcon
                        className="mb-4"
                    />
                )}

                <Input
                    placeholder="Search permissions by code or description..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    allowClear
                    className="mb-4"
                    prefix={<SearchOutlined />}
                />

                <Form
                    form={form}
                    layout="vertical"
                    onFinish={handleFinish}
                    name="permissionAssignmentForm"
                    style={{ maxHeight: '60vh', overflowY: 'auto', paddingRight: '10px' }} // Make the form scrollable
                >
                    <Form.Item name="permissions" noStyle>
                        <Checkbox.Group style={{ width: '100%' }}>
                            {groupedPermissions.length > 0 ? (
                                groupedPermissions.map(([category, perms]) => (
                                     <div key={category} className="mb-4 pb-2 border-b border-gray-200 last:border-b-0">
                                         <div className="mb-2 font-medium text-gray-600 capitalize">{category.replace(/_/g,' ')}</div>
                                        <Row gutter={[16, 8]}>
                                            {perms.sort((a, b) => a.code.localeCompare(b.code)).map(perm => (
                                                <Col xs={24} sm={12} key={perm.id}>
                                                    <Tooltip title={perm.description || perm.code} placement="right">
                                                        <Checkbox value={perm.code} disabled={loading || isCoreRole}>
                                                            <Tag color="blue">{perm.code}</Tag>
                                                        </Checkbox>
                                                    </Tooltip>
                                                </Col>
                                            ))}
                                        </Row>
                                    </div>
                                ))
                            ) : (
                                <Empty description={loadingPermissions ? "Loading permissions..." : "No permissions found matching your search."} />
                            )}
                        </Checkbox.Group>
                    </Form.Item>
                </Form>
            </Spin>
        </Modal>
    );
};

File: src/components/RoleManagement/RoleManagementTab.tsx
// src/components/RoleManagement/RoleManagementTab.tsx
import React, { useState, useCallback } from 'react';
import { Button, Space, message, Alert } from 'antd';
import { PlusOutlined } from '@ant-design/icons';
import { ApiClient, Role, CreateRoleRequest, UpdateRoleRequest, Permission } from '../../api/types';
import { useRoles } from './hooks/useRoles';
import { RoleTable } from './components/RoleTable';
import { RoleFormModal } from './components/RoleFormModal';

interface RoleManagementTabProps {
  apiClient: ApiClient;
}

const RoleManagementTab: React.FC<RoleManagementTabProps> = ({ apiClient }) => {
  const {
    roles,
    permissions,
    loading,
    loadingPermissions,
    error,
    // totalRoles, // Add if using pagination
    fetchRoles, // Use to refresh
    createRole,
    updateRole,
    deleteRole,
  } = useRoles(apiClient);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingRole, setEditingRole] = useState<Role | undefined>(undefined);

  const handleAddRole = () => {
    setEditingRole(undefined);
    setIsModalOpen(true);
  };

  const handleEditRole = (role: Role) => {
    // Ensure we have the permissions loaded for the role being edited
    // The hook should ideally fetch roles with their permissions,
    // but if not, you might need an extra fetch here or pass all permissions.
    console.log("Editing Role:", role);
    setEditingRole(role);
    setIsModalOpen(true);
  };

  const handleDeleteRole = async (id: number) => {
      // Confirmation is handled within the RoleTable component via Popconfirm
      await deleteRole(id);
      // Hook refreshes the list
  };

  const handleModalSubmit = async (data: CreateRoleRequest | UpdateRoleRequest): Promise<boolean> => {
    let success = false;
    if (editingRole) {
      success = !!await updateRole(editingRole.id, data as UpdateRoleRequest);
    } else {
      success = !!await createRole(data as CreateRoleRequest);
    }
    if (success) {
      setIsModalOpen(false);
      setEditingRole(undefined);
    }
    return success; // Let modal know if it succeeded
  };

  const handleModalClose = () => {
      setIsModalOpen(false);
      setEditingRole(undefined);
  }

  return (
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
      <div className="flex justify-end items-center">
        {/* Optional: Add Search/Filter for Roles */}
        <Button
          type="primary"
          icon={<PlusOutlined />}
          onClick={handleAddRole}
          disabled={loading || loadingPermissions} // Disable if loading roles or permissions
          loading={loading || loadingPermissions}
        >
          Add Role
        </Button>
      </div>

       {error && (
            <Alert message={`Error: ${error}`} type="error" showIcon className="mb-4" />
       )}

      <RoleTable
        roles={roles}
        loading={loading}
        onEdit={handleEditRole}
        onDelete={handleDeleteRole}
        // Pass pagination props if implemented
      />

      {/* Render modal only when needed */}
      {isModalOpen && (
          <RoleFormModal
            key={editingRole ? `edit-${editingRole.id}` : 'create'} // Force re-render on edit/create change
            isOpen={isModalOpen}
            onClose={handleModalClose}
            onSubmit={handleModalSubmit}
            initialData={editingRole}
            availablePermissions={permissions} // Pass all available permissions
            loading={loading} // Pass general loading state for submit button
            loadingPermissions={loadingPermissions} // Pass permission loading state
          />
      )}
    </Space>
  );
};

export default RoleManagementTab;

File: src/components/RoleManagement/hooks/useRoles.ts
// src/components/RoleManagement/hooks/useRoles.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { message } from 'antd';
import {
  ApiClient, Role, Permission, CreateRoleRequest, UpdateRoleRequest,
  RoleListResponse, PermissionListResponse
} from '../../../api/types'; // Adjust path as needed

export interface UseRolesResult {
  roles: Role[];
  permissions: Permission[]; // All available permissions
  loading: boolean;
  loadingPermissions: boolean;
  error: string | null;
  totalRoles: number;
  // Add pagination state if needed for roles list
  // pagination: { current: number; pageSize: number; total: number };
  fetchRoles: () => Promise<void>; // Reload roles list
  fetchPermissions: () => Promise<void>; // Reload permissions
  createRole: (data: CreateRoleRequest) => Promise<Role | null>;
  updateRole: (id: number, data: UpdateRoleRequest) => Promise<Role | null>;
  deleteRole: (id: number) => Promise<boolean>;
}

export function useRoles(apiClient: ApiClient): UseRolesResult {
  const mountedRef = useRef(true);
  const [roles, setRoles] = useState<Role[]>([]);
  const [permissions, setPermissions] = useState<Permission[]>([]);
  const [totalRoles, setTotalRoles] = useState(0);
  const [loading, setLoading] = useState(true);
  const [loadingPermissions, setLoadingPermissions] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Safe state setters
  const safeSetState = <T,>(setter: React.Dispatch<React.SetStateAction<T>>) =>
    (value: T | ((prevState: T) => T)) => {
      if (mountedRef.current) {
        setter(value);
      }
    };
  const safeSetRoles = safeSetState(setRoles);
  const safeSetPermissions = safeSetState(setPermissions);
  const safeSetTotalRoles = safeSetState(setTotalRoles);
  const safeSetLoading = safeSetState(setLoading);
  const safeSetLoadingPermissions = safeSetState(setLoadingPermissions);
  const safeSetError = safeSetState(setError);

  const fetchRoles = useCallback(async () => {
    if (!mountedRef.current) return;
    safeSetLoading(true);
    safeSetError(null);
    try {
      // Fetch roles (assuming a reasonable limit for now, add pagination if needed)
      const response = await apiClient.getRoles({ limit: 500 });
      if (mountedRef.current) {
        // Ensure permissions array exists on each role
        const rolesWithPerms = (response.items || []).map(role => ({
            ...role,
            permissions: role.permissions || [] // Default to empty array
        }));
        safeSetRoles(rolesWithPerms);
        safeSetTotalRoles(response.totalCount || 0);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('Failed to fetch roles:', err);
        const msg = err instanceof Error ? err.message : 'Failed to load roles';
        safeSetError(msg);
        message.error(msg);
        safeSetRoles([]);
        safeSetTotalRoles(0);
      }
    } finally {
      if (mountedRef.current) safeSetLoading(false);
    }
  }, [apiClient, safeSetLoading, safeSetError, safeSetRoles, safeSetTotalRoles]);

  const fetchPermissions = useCallback(async () => {
    if (!mountedRef.current) return;
    safeSetLoadingPermissions(true);
    safeSetError(null); // Clear general error when loading permissions
    try {
      const response = await apiClient.getPermissions();
      if (mountedRef.current) {
        safeSetPermissions(response.items || []);
      }
    } catch (err) {
      if (mountedRef.current) {
        console.error('Failed to fetch permissions:', err);
        const msg = err instanceof Error ? err.message : 'Failed to load permissions list';
        safeSetError(msg); // Set error specific to permissions loading
        message.error(msg);
        safeSetPermissions([]); // Set empty on error
      }
    } finally {
      if (mountedRef.current) safeSetLoadingPermissions(false);
    }
  }, [apiClient, safeSetLoadingPermissions, safeSetPermissions, safeSetError]);

  useEffect(() => {
    fetchRoles();
    fetchPermissions();
  }, [fetchRoles, fetchPermissions]);

  const createRole = useCallback(async (data: CreateRoleRequest): Promise<Role | null> => {
    safeSetLoading(true); safeSetError(null);
    try {
      const newRole = await apiClient.createRole(data);
      message.success(`Role "${newRole.name}" created successfully.`);
      await fetchRoles(); // Refresh list
      return newRole;
    } catch (err) {
      console.error('Failed to create role:', err);
      const msg = err instanceof Error ? err.message : 'Failed to create role';
      safeSetError(msg);
      message.error(msg);
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, fetchRoles, safeSetLoading, safeSetError]);

  const updateRole = useCallback(async (id: number, data: UpdateRoleRequest): Promise<Role | null> => {
    safeSetLoading(true); safeSetError(null);
    try {
      const updatedRole = await apiClient.updateRole(id, data);
      message.success(`Role "${updatedRole.name}" updated successfully.`);
      await fetchRoles(); // Refresh list
      return updatedRole;
    } catch (err) {
      console.error('Failed to update role:', err);
      const msg = err instanceof Error ? err.message : 'Failed to update role';
      safeSetError(msg);
      message.error(msg);
      return null;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, fetchRoles, safeSetLoading, safeSetError]);

  const deleteRole = useCallback(async (id: number): Promise<boolean> => {
    safeSetLoading(true); safeSetError(null);
    try {
      await apiClient.deleteRole(id);
      message.success(`Role deleted successfully.`);
      await fetchRoles(); // Refresh list
      return true;
    } catch (err) {
      console.error('Failed to delete role:', err);
      const msg = err instanceof Error ? err.message : 'Failed to delete role';
      safeSetError(msg);
      message.error(msg);
      return false;
    } finally {
      safeSetLoading(false);
    }
  }, [apiClient, fetchRoles, safeSetLoading, safeSetError]);

  useEffect(() => { // Mount cleanup
    mountedRef.current = true;
    return () => { mountedRef.current = false; };
  }, []);

  return {
    roles,
    permissions,
    loading,
    loadingPermissions,
    error,
    totalRoles,
    // pagination: { current: 1, pageSize: 500, total: totalRoles }, // Add pagination if needed
    fetchRoles,
    fetchPermissions,
    createRole,
    updateRole,
    deleteRole,
  };
}

File: src/components/RoleManagement/RoleManagementComponent.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Modal, Form, Input, message, Space, Select, Tag, Tooltip, Row, Col, Alert } from 'antd';
import { useAuth } from '../../context/AuthContext';
import { EditOutlined, DeleteOutlined, EyeOutlined, PlusOutlined } from '@ant-design/icons';
import { 
  ApiClient, 
  CreateRoleRequest,
  UpdateRoleRequest,
  Role,
  Permission
} from '../../api/types';

// Define the types needed for Role Management functionality
export interface RoleManagementComponentProps {
  apiClient: ApiClient;
}

export const RoleManagementComponent: React.FC<RoleManagementComponentProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  // Component state
  const [roles, setRoles] = useState<Role[]>([]);
  const [permissions, setPermissions] = useState<Permission[]>([]);
  const [loading, setLoading] = useState(false);
  const [loadingPermissions, setLoadingPermissions] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showViewModal, setShowViewModal] = useState(false);
  const [selectedRole, setSelectedRole] = useState<Role | null>(null);
  const [pagination, setPagination] = useState({ current: 1, pageSize: 10, total: 0 });
  const [form] = Form.useForm();
  
  // State for tracking selected permissions directly
  const [selectedPermissions, setSelectedPermissions] = useState<string[]>([]);
  
  // Load roles and permissions when component mounts
  useEffect(() => {
    loadRoles();
    loadPermissions();
  }, []);
  
  // Reset selected permissions when modals close
  useEffect(() => {
    if (!showCreateModal && !showEditModal) {
      setSelectedPermissions([]);
    }
  }, [showCreateModal, showEditModal]);
  
  const loadRoles = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await apiClient.getRoles({ limit: 500 }); // Get all roles, adjust if needed
      setRoles(response.items || []);
      setPagination({
        ...pagination,
        total: response.totalCount || 0
      });
    } catch (err) {
      console.error('Failed to load roles:', err);
      setError('Failed to load roles');
    } finally {
      setLoading(false);
    }
  };
  
  const loadPermissions = async () => {
    setLoadingPermissions(true);
    
    try {
      const response = await apiClient.getPermissions();
      setPermissions(response.items || []);
    } catch (err) {
      console.error('Failed to load permissions:', err);
      message.error('Failed to load permissions. Permission selection may be incomplete.');
    } finally {
      setLoadingPermissions(false);
    }
  };
  
  const handleCreateRole = async (data: any) => {
    // Check if user has permission to create roles
    if (!checkPermission('roles:create')) {
      setError('You do not have permission to create roles');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: CreateRoleRequest = {
        name: data.name,
        description: data.description || undefined,
        permissions: selectedPermissions // Use the directly managed state
      };
      
      await apiClient.createRole(request);
      message.success('Role created successfully');
      setShowCreateModal(false);
      form.resetFields();
      setSelectedPermissions([]);
      loadRoles(); // Refresh the list
    } catch (err) {
      console.error('Failed to create role:', err);
      setError('Failed to create role');
    } finally {
      setLoading(false);
    }
  };
  
  const handleUpdateRole = async (data: any) => {
    // Check if user has permission to update roles
    if (!checkPermission('roles:update')) {
      setError('You do not have permission to update roles');
      return;
    }
    
    if (!selectedRole) {
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: UpdateRoleRequest = {
        name: data.name !== selectedRole.name ? data.name : undefined,
        description: data.description !== selectedRole.description ? data.description : undefined,
        permissions: selectedPermissions // Use the directly managed state
      };
      
      // Filter out undefined fields for cleaner request
      const filteredRequest = Object.fromEntries(
        Object.entries(request).filter(([_, v]) => v !== undefined)
      ) as UpdateRoleRequest;

      // Ensure permissions are always sent
      if (!filteredRequest.permissions) {
        filteredRequest.permissions = selectedPermissions;
      }
      
      await apiClient.updateRole(selectedRole.id, filteredRequest);
      message.success('Role updated successfully');
      setShowEditModal(false);
      form.resetFields();
      setSelectedPermissions([]);
      loadRoles(); // Refresh the list
    } catch (err) {
      console.error('Failed to update role:', err);
      setError('Failed to update role');
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeleteRole = async (id: number) => {
    // Check if user has permission to delete roles
    if (!checkPermission('roles:delete')) {
      setError('You do not have permission to delete roles');
      return;
    }
    
    setLoading(true);
    
    try {
      await apiClient.deleteRole(id);
      message.success('Role deleted successfully');
      loadRoles(); // Refresh the list
    } catch (err) {
      console.error('Failed to delete role:', err);
      setError('Failed to delete role');
    } finally {
      setLoading(false);
    }
  };
  
  const showDeleteConfirm = (id: number, name: string) => {
    // Don't allow deletion of core roles
    if (name === 'admin' || name === 'classifier') {
      message.error('Core system roles cannot be deleted');
      return;
    }
    
    Modal.confirm({
      title: `Are you sure you want to delete ${name}?`,
      content: 'This action cannot be undone. Users with only this role will lose permissions.',
      okText: 'Yes',
      okType: 'danger',
      cancelText: 'No',
      onOk() {
        handleDeleteRole(id);
      },
    });
  };
  
  const openCreateModal = () => {
    form.resetFields();
    setSelectedPermissions([]);
    setShowCreateModal(true);
  };
  
  const openEditModal = (role: Role) => {
    setSelectedRole(role);
    
    // Map role permissions to just the codes for the form
    const permissionCodes = role.permissions ? role.permissions.map(p => p.code) : [];
    
    form.setFieldsValue({
      name: role.name,
      description: role.description || '',
    });
    
    // Set selected permissions directly in state
    setSelectedPermissions(permissionCodes);
    
    setShowEditModal(true);
  };
  
  const openViewModal = (role: Role) => {
    setSelectedRole(role);
    setShowViewModal(true);
  };
  
  const isCoreRole = (name: string): boolean => {
    return name === 'admin' || name === 'classifier';
  };
  
  const formatPermissions = (perms: Permission[] | undefined) => {
    if (!perms || perms.length === 0) {
      return <Tag>No Permissions</Tag>;
    }
    
    const displayCount = 3; // Max permissions to show directly
    const hiddenCount = perms.length - displayCount;
    
    return (
      <Space size={[0, 4]} wrap>
        {perms.slice(0, displayCount).map(perm => (
          <Tooltip key={perm.id} title={perm.description || perm.code}>
            <Tag color="blue" style={{ cursor: 'help' }}>{perm.code}</Tag>
          </Tooltip>
        ))}
        {hiddenCount > 0 && (
          <Tooltip title={perms.slice(displayCount).map(p => p.code).join(', ')}>
            <Tag>+{hiddenCount} more</Tag>
          </Tooltip>
        )}
      </Space>
    );
  };
  
  const handlePermissionChange = (category: string, selected: string[]) => {
    // Get all permissions for this category
    const categoryPermissions = permissions
      .filter(p => (p.code.split(':')[0] || 'other') === category)
      .map(p => p.code);
    
    // Remove all permissions from this category from the selected list
    const filteredPermissions = selectedPermissions.filter(
      code => !categoryPermissions.includes(code)
    );
    
    // Add newly selected permissions from this category
    const newSelectedPermissions = [...filteredPermissions, ...selected];
    setSelectedPermissions(newSelectedPermissions);
  };
  
  // Group permissions by category for better organization
  const groupPermissionsByCategory = (perms: Permission[]) => {
    const grouped: Record<string, Permission[]> = {};
    
    perms.forEach(perm => {
      const category = perm.code.split(':')[0] || 'other';
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(perm);
    });
    
    return Object.entries(grouped).sort(([catA], [catB]) => {
      if (catA === 'other') return 1;
      if (catB === 'other') return -1;
      return catA.localeCompare(catB);
    });
  };

  const columns = [
    {
      title: 'Role Name',
      dataIndex: 'name',
      key: 'name',
      sorter: (a: Role, b: Role) => a.name.localeCompare(b.name),
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
    },
    {
      title: 'Permissions',
      dataIndex: 'permissions',
      key: 'permissions',
      render: (permissions: Permission[]) => formatPermissions(permissions),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: Role) => (
        <Space size="small">
          <Button 
            type="text" 
            icon={<EyeOutlined />} 
            onClick={() => openViewModal(record)}
          />
          {checkPermission('roles:update') && (
            <Button 
              type="text" 
              icon={<EditOutlined />} 
              onClick={() => openEditModal(record)}
            />
          )}
          {checkPermission('roles:delete') && !isCoreRole(record.name) && (
            <Button 
              type="text" 
              danger 
              icon={<DeleteOutlined />} 
              onClick={() => showDeleteConfirm(record.id, record.name)}
            />
          )}
        </Space>
      ),
    },
  ];
  
  return (
    <div className="role-management-container">
      {error && <div className="error-message mb-4 p-3 text-red-700 bg-red-50 border border-red-200 rounded">{error}</div>}
      
      <div className="actions-container" style={{ marginBottom: '16px' }}>
        {checkPermission('roles:create') && (
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={openCreateModal}
          >
            Add New Role
          </Button>
        )}
      </div>
      
      <Table
        dataSource={roles}
        columns={columns}
        rowKey="id"
        loading={loading}
        pagination={false} // Typically roles won't require pagination
      />
      
      {/* Create Modal - Using direct state for permissions instead of form fields */}
      <Modal
        title="Add New Role"
        open={showCreateModal}
        onCancel={() => setShowCreateModal(false)}
        footer={null}
        width={700} // Wider modal for permissions list
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleCreateRole}
        >
          <Form.Item
            name="name"
            label="Role Name"
            rules={[{ required: true, message: 'Please enter a role name' }]}
          >
            <Input placeholder="Enter role name (e.g., data_analyst)" />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
          >
            <Input.TextArea rows={2} placeholder="Description of the role's purpose and access level" />
          </Form.Item>
          
          <div className="form-section">
            <label className="ant-form-item-label">
              <span className="ant-form-item-label-text">Permissions</span>
            </label>
            <div className="ant-form-item-explain">Select permissions for this role</div>
            <div className="permissions-section" style={{ marginTop: '8px' }}>
              {groupPermissionsByCategory(permissions).map(([category, perms]) => {
                // Get the currently selected permissions for this category
                const categoryPermissions = selectedPermissions.filter(code => 
                  perms.some(p => p.code === code)
                );
                
                return (
                  <div key={category} className="mb-4">
                    <div className="font-medium text-gray-600 capitalize mb-2">
                      {category.replace(/_/g, ' ')} Permissions
                    </div>
                    <Select
                      mode="multiple"
                      placeholder={`Select ${category} permissions`}
                      style={{ width: '100%' }}
                      allowClear
                      options={perms.map(perm => ({
                        label: perm.code,
                        value: perm.code,
                        title: perm.description || perm.code,
                      }))}
                      value={categoryPermissions}
                      onChange={(values) => handlePermissionChange(category, values)}
                      listHeight={200}
                      maxTagCount={5}
                      optionFilterProp="label"
                    />
                  </div>
                );
              })}
              
              {selectedPermissions.length === 0 && (
                <div className="ant-form-item-explain ant-form-item-explain-error">
                  Please select at least one permission
                </div>
              )}
            </div>
          </div>
          
          <Form.Item style={{ marginTop: '16px' }}>
            <Button 
              type="primary" 
              htmlType="submit" 
              loading={loading} 
              style={{ marginRight: 8 }}
              disabled={selectedPermissions.length === 0}
            >
              Create
            </Button>
            <Button onClick={() => setShowCreateModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* Edit Modal - Using direct state for permissions instead of form fields */}
      <Modal
        title={`Edit Role: ${selectedRole?.name}`}
        open={showEditModal}
        onCancel={() => setShowEditModal(false)}
        footer={null}
        width={700} // Wider modal for permissions list
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleUpdateRole}
        >
          {selectedRole && isCoreRole(selectedRole.name) && (
            <Alert
              message="Core Role"
              description="This is a core system role. Some properties cannot be modified to prevent system disruption."
              type="warning"
              showIcon
              className="mb-4"
            />
          )}
          
          <Form.Item
            name="name"
            label="Role Name"
            rules={[{ required: true, message: 'Please enter a role name' }]}
          >
            <Input disabled={selectedRole ? isCoreRole(selectedRole.name) : false} />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
          >
            <Input.TextArea rows={2} />
          </Form.Item>
          
          <div className="form-section">
            <label className="ant-form-item-label">
              <span className="ant-form-item-label-text">Permissions</span>
            </label>
            <div className="permissions-section">
              {groupPermissionsByCategory(permissions).map(([category, perms]) => {
                // Get the currently selected permissions for this category
                const categoryPermissions = selectedPermissions.filter(code => 
                  perms.some(p => p.code === code)
                );
                
                return (
                  <div key={category} className="mb-4">
                    <div className="font-medium text-gray-600 capitalize mb-2">
                      {category.replace(/_/g, ' ')} Permissions
                    </div>
                    <Select
                      mode="multiple"
                      placeholder={`Select ${category} permissions`}
                      style={{ width: '100%' }}
                      allowClear
                      options={perms.map(perm => ({
                        label: perm.code,
                        value: perm.code,
                        title: perm.description || perm.code,
                        disabled: selectedRole && isCoreRole(selectedRole.name) ? 
                          (perm.code === 'roles:manage' || perm.code === 'users:manage') : undefined
                      }))}
                      value={categoryPermissions}
                      onChange={(values) => handlePermissionChange(category, values)}
                      listHeight={200}
                      maxTagCount={5}
                      optionFilterProp="label"
                    />
                  </div>
                );
              })}
            </div>
          </div>
          
          <Form.Item style={{ marginTop: '16px' }}>
            <Button 
              type="primary" 
              htmlType="submit" 
              loading={loading} 
              style={{ marginRight: 8 }}
              disabled={selectedPermissions.length === 0}
            >
              Update
            </Button>
            <Button onClick={() => setShowEditModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* View Modal */}
      <Modal
        title="Role Details"
        open={showViewModal}
        onCancel={() => setShowViewModal(false)}
        footer={[
          <Button key="close" onClick={() => setShowViewModal(false)}>
            Close
          </Button>
        ]}
        width={600}
      >
        {selectedRole && (
          <>
            <p><strong>Name:</strong> {selectedRole.name}</p>
            <p><strong>Description:</strong> {selectedRole.description || 'No description'}</p>
            <p><strong>Permissions:</strong></p>
            
            {selectedRole.permissions && selectedRole.permissions.length > 0 ? (
              <div className="mb-3 border p-3 rounded bg-gray-50" style={{ maxHeight: '200px', overflow: 'auto' }}>
                {groupPermissionsByCategory(selectedRole.permissions).map(([category, perms]) => (
                  <div key={category} className="mb-3 last:mb-0">
                    <div className="font-medium capitalize mb-1">{category.replace(/_/g, ' ')}:</div>
                    <div className="pl-2">
                      {perms.map(perm => (
                        <div key={perm.id} className="mb-1">
                          <Tag color="blue">{perm.code}</Tag>
                          {perm.description && <span className="text-sm text-gray-600 ml-2">{perm.description}</span>}
                        </div>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-gray-500">This role has no assigned permissions</div>
            )}
          </>
        )}
      </Modal>
    </div>
  );
};

export default RoleManagementComponent;

File: src/components/RoleManagement/components/RoleTable.tsx
// src/components/RoleManagement/components/RoleTable.tsx
import React from 'react';
import { Table, Space, Button, Tag, Popconfirm, Tooltip } from 'antd';
import { EditOutlined, DeleteOutlined } from '@ant-design/icons';
import { Role, Permission } from '../../../api/types'; // Adjust path

interface RoleTableProps {
  roles: Role[];
  loading: boolean;
  onEdit: (role: Role) => void;
  onDelete: (id: number) => void;
  // Add pagination props if implemented in useRoles hook
  // pagination: { current: number; pageSize: number; total: number };
  // onPageChange: (page: number, pageSize: number) => void;
}

export const RoleTable: React.FC<RoleTableProps> = ({
  roles,
  loading,
  onEdit,
  onDelete,
  // pagination,
  // onPageChange,
}) => {

  const columns = [
    {
      title: 'ID',
      dataIndex: 'id',
      key: 'id',
      width: 80,
      sorter: (a: Role, b: Role) => a.id - b.id,
    },
    {
      title: 'Role Name',
      dataIndex: 'name',
      key: 'name',
      sorter: (a: Role, b: Role) => a.name.localeCompare(b.name),
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true, // Truncate long descriptions
    },
    {
        title: 'Permissions',
        key: 'permissions',
        render: (_: any, record: Role) => {
            const permissions = record.permissions || [];
            const displayCount = 3; // Max permissions to show directly
            const hiddenCount = permissions.length - displayCount;

            return (
                <Space wrap size={[4, 4]}>
                    {permissions.slice(0, displayCount).map((perm: Permission) => (
                        <Tooltip key={perm.id} title={perm.description || perm.code}>
                             <Tag color="geekblue" style={{ cursor: 'help' }}>{perm.code}</Tag>
                        </Tooltip>
                    ))}
                    {hiddenCount > 0 && (
                        <Tooltip title={permissions.slice(displayCount).map(p => p.code).join(', ')}>
                            <Tag>+{hiddenCount} more</Tag>
                        </Tooltip>
                    )}
                    {permissions.length === 0 && <Tag>No Permissions</Tag>}
                </Space>
            );
        },
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 120,
      render: (_: any, record: Role) => (
        <Space size="small">
          <Tooltip title="Edit Role">
            <Button
              type="text"
              icon={<EditOutlined />}
              onClick={() => onEdit(record)}
              aria-label={`Edit role ${record.name}`}
            />
          </Tooltip>
          {/* Prevent deleting core roles like 'admin' if needed */}
          {record.name !== 'admin' && record.name !== 'classifier' && (
              <Popconfirm
                title={`Delete role "${record.name}"?`}
                description="Users assigned only this role will lose its permissions. This cannot be undone."
                onConfirm={() => onDelete(record.id)}
                okText="Delete"
                okType="danger"
                cancelText="Cancel"
              >
                <Tooltip title="Delete Role">
                  <Button
                    type="text"
                    danger
                    icon={<DeleteOutlined />}
                    aria-label={`Delete role ${record.name}`}
                  />
                </Tooltip>
              </Popconfirm>
          )}
        </Space>
      ),
    },
  ];

  return (
    <Table
      rowKey="id"
      columns={columns}
      dataSource={roles}
      loading={loading}
      pagination={false} // Add pagination prop from hook if implemented
      // onChange={(p) => onPageChange(p.current ?? 1, p.pageSize ?? 10)} // Add if paginated
      scroll={{ x: 'max-content' }}
      size="small"
    />
  );
};

File: src/components/Sidebar/LeftSidebar.interface.ts
import React from 'react';

/**
 * Type definition for icon components, explicitly including both SVG components and Ant Design icons
 */
export type SvgComponent = 
  | React.ComponentType<React.SVGProps<SVGSVGElement>> 
  | React.ForwardRefExoticComponent<any>;

/**
 * Interface for sidebar menu items
 */
export interface LeftSidebarItem {
  key: string;
  isBeta?: boolean;
  title: string;
  redirect_url?: string;
  icon: SvgComponent;
  dataTestId: string;
  disableExpandIcon?: boolean;
  children?: Array<LeftSidebarItem>;
  onClick?: () => void;
  requiredPermission?: string; // Permission code required to see this item
}

/**
 * Interface for the LeftSidebar component props
 */
export interface LeftSidebarProps {
  isSidebarCollapsed?: boolean;
  onLogout?: () => void;
  ragEnabled?: boolean; // Added for conditional RAG items
}

File: src/components/RagInfoTab/RagInfoTab.tsx
// src/components/RagInfoTab/RagInfoTab.tsx
import React, { useState, useCallback, useRef } from 'react';
import { ApiClient, RagInfoItem, CreateRagInfoRequest, UpdateRagInfoRequest } from '../../api/types'; // Adjust path
import { useRagInfo } from './hooks/useRagInfo';
import { RagInfoFilters } from './components/RagInfoFilters';
import { RagInfoTable } from './components/RagInfoTable';
import { RagInfoPagination } from './components/RagInfoPagination';
import { RagInfoFormModal } from './components/RagInfoFormModal';
import { PlusIcon, ArrowDownTrayIcon, ArrowUpTrayIcon } from '@heroicons/react/24/solid'; // Added ArrowUpTrayIcon
import { useAuth } from '../../context/AuthContext'; // Import useAuth hook
import { message } from 'antd'; // Import message for notifications

interface RagInfoTabProps {
    apiClient: ApiClient;
}

const PAGE_SIZE = 10; // Must match the hook

// Helper function to convert RAG info items to CSV and trigger download
const exportToCSV = (items: RagInfoItem[]): void => {
    const headers = ['Key', 'Description', 'Created At', 'Updated At'];
    const csvContent = [
        headers.join(','),
        ...items.map(item => [
            `"${item.key.replace(/"/g, '""')}"`,
            `"${item.description.replace(/"/g, '""')}"`,
            item.createdAt ? new Date(item.createdAt).toLocaleString() : '',
            item.updatedAt ? new Date(item.updatedAt).toLocaleString() : ''
        ].join(','))
    ].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `rag-info-export-${new Date().toISOString().slice(0, 10)}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
};

// Helper function to parse CSV data into RAG info items
const parseCSV = (csvText: string): CreateRagInfoRequest[] => {
    const lines = csvText.split(/\r?\n/);
    if (lines.length < 2) {
        throw new Error('CSV file is empty or has incorrect format');
    }
    const headers = lines[0].toLowerCase().split(',');
    const keyIndex = headers.findIndex(header => header.trim() === 'key');
    const descriptionIndex = headers.findIndex(header => header.trim() === 'description');
    if (keyIndex === -1 || descriptionIndex === -1) {
        throw new Error('CSV must contain "Key" and "Description" columns');
    }
    const items: CreateRagInfoRequest[] = [];
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        const values: string[] = [];
        let inQuote = false;
        let currentValue = '';
        for (let j = 0; j < line.length; j++) {
            const char = line[j];
            if (char === '"') {
                if (j + 1 < line.length && line[j + 1] === '"') {
                    currentValue += '"';
                    j++;
                } else {
                    inQuote = !inQuote;
                }
            } else if (char === ',' && !inQuote) {
                values.push(currentValue);
                currentValue = '';
            } else {
                currentValue += char;
            }
        }
        values.push(currentValue);
        const key = values[keyIndex]?.trim();
        const description = values[descriptionIndex]?.trim();
        if (key && description) {
            items.push({ key, description });
        }
    }
    return items;
};

export const RagInfoTab: React.FC<RagInfoTabProps> = ({ apiClient }) => {
    const { checkPermission } = useAuth(); // Get permission checker
    
    const {
        items,
        loading,
        error,
        totalCount,
        totalPages,
        currentPage,
        searchTerm,
        setCurrentPage,
        setSearchTerm,
        refreshList,
        createItem,
        updateItem,
        deleteItem,
        fetchAllForExport,
    } = useRagInfo(apiClient);

    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingItem, setEditingItem] = useState<RagInfoItem | undefined>(undefined);
    const [isExporting, setIsExporting] = useState(false);
    const [isImporting, setIsImporting] = useState(false);
    const [importStatus, setImportStatus] = useState<{
        total: number;
        success: number;
        failed: number;
        message?: string;
    } | null>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleAddClick = () => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied."); 
            return; 
        }
        setEditingItem(undefined);
        setIsModalOpen(true);
    };

    const handleEditClick = (item: RagInfoItem) => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied."); 
            return; 
        }
        setEditingItem(item);
        setIsModalOpen(true);
    };

    const handleDeleteClick = async (item: RagInfoItem) => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied."); 
            return; 
        }
        if (window.confirm(`Are you sure you want to delete the item "${item.key}"?`)) {
            await deleteItem(item.id); // deleteItem hook handles loading/error state
        }
    };

    const handleExportClick = async () => {
        if (!checkPermission('rag:view')) { // Use view permission for export
            message.error("Permission denied to export data.");
            return;
        }
        setIsExporting(true);
        try {
            const allItems = await fetchAllForExport(searchTerm);
            if (allItems.length === 0) {
                message.info('No RAG info items to export.');
                return;
            }
            exportToCSV(allItems);
            console.log(`Successfully exported ${allItems.length} RAG info items to CSV`);
        } catch (error) {
            console.error('Error exporting data:', error);
            message.error('Failed to export data. Please try again.');
        } finally {
            setIsExporting(false);
        }
    };

    const handleImportClick = () => {
        if (!checkPermission('rag:manage')) { 
            message.error("Permission denied to import data."); 
            return; 
        }
        if (fileInputRef.current) {
            fileInputRef.current.value = '';
            fileInputRef.current.click();
        }
    };

    const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
        // Permission check already done in handleImportClick
        const file = e.target.files?.[0];
        if (!file) return;
        setIsImporting(true);
        setImportStatus(null);
        try {
            const text = await readFileAsText(file);
            const itemsToImport = parseCSV(text);
            if (itemsToImport.length === 0) {
                throw new Error('No valid items found in the CSV file');
            }
            const importResults = await importItems(itemsToImport);
            setImportStatus({
                total: itemsToImport.length,
                success: importResults.success,
                failed: importResults.failed,
                message: `Successfully imported ${importResults.success} items. ${importResults.failed} items failed.`
            });
            await refreshList();
        } catch (error) {
            console.error('Import error:', error);
            setImportStatus({
                total: 0,
                success: 0,
                failed: 0,
                message: `Import failed: ${error instanceof Error ? error.message : 'Unknown error'}`
            });
        } finally {
            setIsImporting(false);
        }
    };

    const readFileAsText = (file: File): Promise<string> => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target?.result as string);
            reader.onerror = (e) => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        });
    };

    const importItems = async (items: CreateRagInfoRequest[]): Promise<{ success: number; failed: number }> => {
        let success = 0;
        let failed = 0;
        const batchSize = 10;
        for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            const results = await Promise.allSettled(
                batch.map(item => createItem(item))
            );
            results.forEach(result => {
                if (result.status === 'fulfilled' && result.value) {
                    success++;
                } else {
                    failed++;
                }
            });
        }
        return { success, failed };
    };

    const handleModalSubmit = async (data: CreateRagInfoRequest | UpdateRagInfoRequest): Promise<boolean> => {
        // Permissions checked before opening modal, but double-check is safe
        if (!checkPermission('rag:manage')) {
            message.error("Permission denied.");
            return false;
        }
        let success = false;
        if (editingItem) {
            success = !!(await updateItem(editingItem.id, data as UpdateRagInfoRequest));
        } else {
            success = !!(await createItem(data as CreateRagInfoRequest));
        }
        return success;
    };

    return (
        <div className="space-y-6">
            <div className="flex justify-between items-center">
                <div className="flex-grow mr-4">
                    <RagInfoFilters
                        searchTerm={searchTerm}
                        onSearchChange={setSearchTerm}
                        loading={loading}
                    />
                </div>
                <div className="flex space-x-2">
                    <button
                        onClick={handleImportClick}
                        className="btn btn-secondary inline-flex items-center"
                        disabled={loading || isImporting || isExporting || !checkPermission('rag:manage')}
                        title={!checkPermission('rag:manage') ? "Permission denied" : "Import data from CSV file"}
                    >
                        <ArrowUpTrayIcon className={`h-5 w-5 mr-1 ${!checkPermission('rag:manage') ? 'opacity-50' : ''}`} />
                        {isImporting ? 'Importing...' : 'Import CSV'}
                    </button>
                    <input
                        ref={fileInputRef}
                        type="file"
                        accept=".csv"
                        className="hidden"
                        onChange={handleFileChange}
                    />
                    <button
                        onClick={handleExportClick}
                        className="btn btn-secondary inline-flex items-center"
                        disabled={loading || isExporting || isImporting || items.length === 0 || !checkPermission('rag:view')}
                        title={!checkPermission('rag:view') ? "Permission denied" : "Export data to CSV file"}
                    >
                        <ArrowDownTrayIcon className={`h-5 w-5 mr-1 ${!checkPermission('rag:view') ? 'opacity-50' : ''}`} />
                        {isExporting ? 'Exporting...' : 'Export CSV'}
                    </button>
                    <button
                        onClick={handleAddClick}
                        className="btn btn-primary inline-flex items-center"
                        disabled={loading || isImporting || !checkPermission('rag:manage')}
                        title={!checkPermission('rag:manage') ? "Permission denied" : "Add new RAG info item"}
                    >
                        <PlusIcon className={`h-5 w-5 mr-1 ${!checkPermission('rag:manage') ? 'opacity-50' : ''}`} />
                        Add Info
                    </button>
                </div>
            </div>

            {!checkPermission('rag:view') && (
                <div className="rounded-md border border-amber-200 bg-amber-50 p-4 text-sm text-amber-700">
                    You don't have permission to view or manage RAG information items.
                </div>
            )}

            {importStatus && importStatus.message && (
                <div className={`rounded-md border p-4 text-sm ${
                    importStatus.failed > 0 
                    ? 'border-yellow-200 bg-yellow-50 text-yellow-700' 
                    : 'border-green-200 bg-green-50 text-green-700'
                }`}>
                    {importStatus.message}
                </div>
            )}

            {error && (
                <div className="rounded-md border border-red-200 bg-red-50 p-4 text-sm text-red-700">
                    Error: {error}
                </div>
            )}

            <RagInfoTable
                items={items}
                loading={loading}
                onEdit={handleEditClick}
                onDelete={handleDeleteClick}
                canEdit={checkPermission('rag:manage')}
                canDelete={checkPermission('rag:manage')}
            />

            <RagInfoPagination
                currentPage={currentPage}
                totalPages={totalPages}
                totalCount={totalCount}
                pageSize={PAGE_SIZE}
                loading={loading}
                onPageChange={setCurrentPage}
            />

            <RagInfoFormModal
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                onSubmit={handleModalSubmit}
                initialData={editingItem}
                loading={loading}
            />
        </div>
    );
};

File: src/components/Settings/SettingsTab.tsx
import React, { useState, useEffect } from 'react';
import { Tabs, Spin, Alert, Form, Input, InputNumber, Switch, Select, Descriptions, Tooltip } from 'antd';
import { QuestionCircleOutlined } from '@ant-design/icons';
import type { FormInstance } from 'antd/es/form';
import { ApiClient, LlmConfig, UpdateConfigRequest } from '../../api/types';
import ConfigValue, { getConfigLabel } from '../ConfigValue'; // Import helper too

const { TabPane } = Tabs;
const { Option } = Select;
const { Item: FormItem } = Form; // Alias Form.Item for clarity

// Define the props including edit state and handlers
export interface SettingsTabProps {
  apiClient: ApiClient;
  isEditing: boolean;
  onSave: (updatedConfig: UpdateConfigRequest) => Promise<void>; // Function to call with update payload
  form: FormInstance<any>; // Pass the form instance down
  initialConfig: LlmConfig | null; // Pass fetched config
  loading: boolean; // Pass loading state
  error: string | null; // Pass error state
}

// Helper to get description for a config key
const getConfigDescription = (keyPath: string[]): string | null => {
  const descriptions: Record<string, string> = {
    "server.logLevel": "Set the minimum level for server logs (debug, info, warn, error).",
    "server.requestTimeout": "Maximum duration for handling incoming HTTP requests (e.g., '60s', '5m').",
    "service.llmEndpoint": "The base URL of the Language Model API.",
    "service.llmApiKey": "Your API key for the LLM service. Leave blank to keep the existing key.",
    "service.llmModel": "The specific LLM model to use for classification.",
    "service.llmMaxTokens": "Maximum number of tokens the LLM can generate in a response.",
    "service.llmTemperature": "Controls randomness in LLM output (0.0 = deterministic, >1.0 = more creative).",
    "service.useTypePrompt": "Whether to include specific guidance for GOODS/SERVICE/OTHER in UNSPSC Segment prompts.",
    "service.maxSkipLogs": "Maximum number of 'skipped row' warnings to log during Excel loading.",
    "database.ragEnabled": "Enable/disable Retrieval-Augmented Generation using vector database context.",
    "database.ragServiceUrl": "The URL of the RAG vector database service.",
    "database.ragManualInfoCollection": "Name of the collection storing manually added RAG context.",
    "database.ragUnspscCollection": "Name of the collection storing UNSPSC category data for RAG.",
    "database.ragCommonCollection": "Name of the collection storing Common Categories data for RAG.",
    "validation.maxHistoryLimit": "Maximum number of classification history items to store.",
    "validation.tokenLimit": "Estimated maximum token limit supported by the configured LLM.",
    "validation.defaultTimeout": "Default timeout for external service calls (e.g., '15s').",
    "alert.emailSettings.smtpHost": "Hostname of the SMTP server for sending email alerts.",
    "alert.emailSettings.smtpPort": "Port number of the SMTP server.",
    "alert.emailSettings.smtpUser": "Username for SMTP authentication.",
    "alert.emailSettings.smtpPassword": "Password for SMTP authentication. Leave blank to keep the existing password.",
    "alert.emailSettings.fromEmail": "The 'From' email address for alerts.",
    "alert.webhookSettings.url": "The URL to send webhook alerts to.",
    "auth.enabled": "Enable or disable user authentication and authorization.",
    "auth.jwtExpirationHours": "Number of hours a user's login session (JWT token) remains valid.",
  };
  return descriptions[keyPath.join('.')] || null;
};

// --- Component ---
const SettingsTab: React.FC<SettingsTabProps> = ({
  apiClient, // Keep apiClient if needed for other things, otherwise remove
  isEditing,
  onSave,
  form,
  initialConfig, // Receive config from parent
  loading: parentLoading, // Use loading state from parent
  error: parentError, // Use error state from parent
}) => {
  const [activeTab, setActiveTab] = useState<string | undefined>(undefined);

  // Initialize form when initialConfig is available or edit mode changes
  useEffect(() => {
    if (initialConfig) {
      // Prepare initial values for the form, handling nested structure
      const formValues: any = {};
      Object.keys(initialConfig).forEach(topKey => {
        const section = initialConfig[topKey as keyof LlmConfig];
        if (section && typeof section === 'object') {
          formValues[topKey] = {};
          Object.keys(section).forEach(subKey => {
            // Handle sensitive fields - DO NOT put masked value in form
            const fullKey = `${topKey}.${subKey}`;
             if (['service.llmApiKey', 'database.password', 'alert.emailSettings.smtpPassword', 'auth.jwtSecret', 'auth.initialAdminPassword'].includes(fullKey)) {
               formValues[topKey][subKey] = ''; // Set to empty for editing
             } else {
               formValues[topKey][subKey] = section[subKey as keyof typeof section];
             }
          });
        }
      });
      form.setFieldsValue(formValues);

      // Set default active tab if not already set
      if (!activeTab) {
        const firstKey = getTopLevelKeys(initialConfig)[0];
        setActiveTab(firstKey);
      }
    } else {
      form.resetFields(); // Reset form if no config
    }
  }, [initialConfig, form, activeTab]); // Add activeTab dependency

  // Recursive function to render form items OR display values
  const renderConfigEntries = (data: any, parentPath: string[] = []): React.ReactNode[] => {
    if (data === null || typeof data !== 'object' || Array.isArray(data)) {
      return []; // Should not happen at top level sections
    }

    return Object.entries(data)
      .map(([key, value]) => {
        const currentPath = [...parentPath, key];
        const fullKey = currentPath.join('.');
        const label = getConfigLabel(key);
        const description = getConfigDescription(currentPath);

        // Determine input type based on key or value type
        let inputType: 'text' | 'password' | 'number' | 'boolean' | 'select' | 'duration' | 'textarea' | 'unsupported' = 'text';
        const lowerKey = key.toLowerCase();

        // Determine if the field should be editable
        const isReadOnly = ['host', 'port', 'user', 'name', 'dataPath', 'initialAdminUser', 'jwtSecret', 'initialAdminPassword'].includes(key) || parentPath.includes('unspscExcelLoader') || parentPath.includes('commonExcelLoader');
        const isSensitive = ['llmApiKey', 'password', 'smtpPassword'].includes(key);

        if (isReadOnly && isEditing) {
           // Display read-only value even in edit mode
           return (
             <FormItem key={fullKey} label={renderLabel(label, description)} name={currentPath} style={{ marginBottom: '10px' }}>
                <ConfigValue configKey={key} value={value} className="text-secondary-500 italic" />
                <span className="text-xs text-secondary-400 ml-2">(Read-only)</span>
             </FormItem>
           );
        }

        if (typeof value === 'boolean') {
          inputType = 'boolean';
        } else if (typeof value === 'number') {
          inputType = 'number';
        } else if (lowerKey.includes('password') || lowerKey.includes('apikey') || lowerKey.includes('secret')) {
           inputType = 'password';
        } else if (key === 'logLevel') {
           inputType = 'select';
        } else if (key.includes('Timeout') || key.includes('duration')) { // Simple check for duration-like fields
          inputType = 'duration';
        } else if (typeof value === 'string' && value.length > 100) { // Treat long strings as textarea
          inputType = 'textarea';
        } else if (typeof value === 'object' || Array.isArray(value)) {
           inputType = 'unsupported'; // Don't render form items for nested objects/arrays directly here
        }

        if (inputType === 'unsupported') {
          // In read-only mode, show nested details
          if (!isEditing) {
            return (
              <Descriptions.Item key={fullKey} label={<span title={fullKey}>{label}</span>} span={1}>
                <div className="nested-config pl-4 border-l-2 border-secondary-200">
                  {renderConfigEntries(value, currentPath).map((node, idx) => <div key={idx}>{node}</div>)}
                </div>
              </Descriptions.Item>
            );
          }
          return null; // Don't show form item for complex types in edit mode here
        }

        // --- Render Edit Mode Form Item ---
        if (isEditing) {
           let fieldComponent: React.ReactNode;
           const commonProps = {
             disabled: parentLoading || isReadOnly, // Disable input if loading or read-only
             placeholder: isSensitive ? "Leave blank to keep current" : `Enter ${label}`
           };

          switch (inputType) {
            case 'boolean':
              fieldComponent = <Switch disabled={parentLoading} />;
              break;
            case 'number':
              fieldComponent = <InputNumber {...commonProps} style={{ width: '100%' }} />;
              break;
            case 'password':
               fieldComponent = <Input.Password {...commonProps} autoComplete="new-password" />;
               break;
            case 'select': // Example for logLevel
               if (key === 'logLevel') {
                 fieldComponent = (
                   <Select {...commonProps} placeholder="Select log level">
                     <Option value="debug">Debug</Option>
                     <Option value="info">Info</Option>
                     <Option value="warn">Warn</Option>
                     <Option value="error">Error</Option>
                   </Select>
                 );
               } else {
                  fieldComponent = <Input {...commonProps} />; // Fallback
               }
               break;
            case 'duration':
              fieldComponent = <Input {...commonProps} placeholder="e.g., 60s, 5m, 1h" />;
              break;
            case 'textarea':
               fieldComponent = <Input.TextArea {...commonProps} rows={3} />;
               break;
            default: // text
               fieldComponent = <Input {...commonProps} />;
          }

          // Use FormItem for layout and validation (add rules later if needed)
          return (
            <FormItem
              key={fullKey}
              name={currentPath} // Use array for nested keys
              label={renderLabel(label, description)}
              valuePropName={inputType === 'boolean' ? 'checked' : 'value'} // Important for Switch
              style={{ marginBottom: '10px' }}
            >
              {fieldComponent}
            </FormItem>
          );
        } else {
          // --- Render Read-Only Mode ---
          return (
            <Descriptions.Item key={fullKey} label={<span title={fullKey}>{label}</span>} span={1} labelStyle={{ width: '30%' }}>
              <ConfigValue configKey={key} value={value} />
            </Descriptions.Item>
          );
        }
      })
      .filter(Boolean); // Remove null entries (like unsupported types in edit mode)
  };

   // Helper to render label with tooltip
   const renderLabel = (label: string, description: string | null) => (
     <span>
       {label}
       {description && (
         <Tooltip title={description} overlayStyle={{ maxWidth: '300px' }}>
           <QuestionCircleOutlined style={{ marginLeft: 4, color: 'rgba(0,0,0,.45)', cursor: 'help' }} />
         </Tooltip>
       )}
     </span>
   );

   // Get top-level keys for Tabs
   const getTopLevelKeys = (cfg: LlmConfig | null): string[] => {
      if (!cfg) return [];
      const desiredOrder = ['server', 'service', 'database', 'auth', 'validation', 'alert'];
      const keys = Object.keys(cfg).filter(key =>
        typeof cfg[key as keyof LlmConfig] === 'object' && cfg[key as keyof LlmConfig] !== null
      );
      keys.sort((a, b) => {
         const indexA = desiredOrder.indexOf(a);
         const indexB = desiredOrder.indexOf(b);
         if (indexA === -1 && indexB === -1) return a.localeCompare(b);
         if (indexA === -1) return 1;
         if (indexB === -1) return -1;
         return indexA - indexB;
      });
      return keys;
    };

  // --- Render Logic ---

  if (parentLoading && !initialConfig) { // Show loading only on initial fetch
    return (
      <div className="flex justify-center items-center py-10">
        <Spin size="large" tip="Loading configuration..." />
      </div>
    );
  }

  if (parentError) {
    return (
      <Alert
        message="Error Loading Configuration"
        description={parentError}
        type="error"
        showIcon
      />
    );
  }

  if (!initialConfig) {
    return <Alert message="No configuration data available." type="warning" showIcon />;
  }

  const topLevelKeys = getTopLevelKeys(initialConfig);

  return (
    <Form
      form={form}
      layout="vertical"
      name="settingsForm"
      // onFinish is handled by the onSave prop passed from parent
      // initialValues are set via form.setFieldsValue in useEffect
    >
      <Tabs
         activeKey={activeTab}
         onChange={setActiveTab}
         tabPosition="top"
      >
         {topLevelKeys.map(topKey => {
            const sectionData = initialConfig[topKey as keyof LlmConfig];
            if (!sectionData || typeof sectionData !== 'object') return null; // Skip non-objects

            const sectionLabel = getConfigLabel(topKey);

            return (
               <TabPane tab={sectionLabel} key={topKey}>
                 <div className="py-4 px-2">
                   {isEditing
                     ? renderConfigEntries(sectionData, [topKey]) // Render FormItems
                     : ( // Render Descriptions for read-only
                       <Descriptions bordered column={1} size="small" className="config-descriptions">
                         {renderConfigEntries(sectionData, [topKey])}
                       </Descriptions>
                       )
                   }
                 </div>
               </TabPane>
            );
         })}
      </Tabs>
    </Form>
  );
};

export default SettingsTab;

File: src/components/RoleManagement/components/RoleFormModal.tsx
// src/components/RoleManagement/components/RoleFormModal.tsx
import React, { useEffect, useState } from 'react';
import { Modal, Form, Input, Select, Button, Spin, Alert, Checkbox, Row, Col, Tooltip, message } from 'antd';
import { Role, Permission, CreateRoleRequest, UpdateRoleRequest } from '../../../api/types';

interface RoleFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: CreateRoleRequest | UpdateRoleRequest) => Promise<boolean>; // Returns success status
  initialData?: Role;
  availablePermissions: Permission[];
  loading: boolean; // Loading state for submission
  loadingPermissions: boolean; // Loading state for permissions list
}

const { Option } = Select;

export const RoleFormModal: React.FC<RoleFormModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  initialData,
  availablePermissions,
  loading,
  loadingPermissions,
}) => {
  const [form] = Form.useForm();
  const [formError, setFormError] = useState<string | null>(null);

  const isEditMode = !!initialData;
  const isCoreRole = isEditMode && (initialData?.name === 'admin' || initialData?.name === 'classifier');

  useEffect(() => {
    if (isOpen) {
      setFormError(null);
      if (isEditMode && initialData) {
        form.setFieldsValue({
          name: initialData.name,
          description: initialData.description || '',
          permissions: (initialData.permissions || []).map(p => p.code), // Set codes for Checkbox.Group
        });
      } else {
        form.resetFields();
      }
    }
  }, [isOpen, initialData, form, isEditMode]);

  const handleFinish = async (values: any) => {
    setFormError(null);
    const permissionCodes = values.permissions || [];

    let success = false;
    if (isEditMode && initialData) {
      const updateData: UpdateRoleRequest = {
        name: values.name !== initialData.name ? values.name : undefined, // Only send if changed
        description: values.description !== (initialData.description || '') ? values.description : undefined,
        permissions: permissionCodes, // Always send permissions array
      };
       // Filter out undefined fields
       const filteredUpdateData = Object.fromEntries(
           Object.entries(updateData).filter(([_, v]) => v !== undefined)
       ) as UpdateRoleRequest;

        // Check if anything changed (permissions comparison needs care)
        const initialPermCodes = (initialData.permissions || []).map(p => p.code).sort();
        const currentPermCodes = [...permissionCodes].sort();
        const permsChanged = JSON.stringify(initialPermCodes) !== JSON.stringify(currentPermCodes);

        if (Object.keys(filteredUpdateData).length === 0 && !permsChanged) {
            message.info("No changes detected.");
            onClose();
            return;
        }
        // If only permissions changed, ensure the permissions field is included
        if (Object.keys(filteredUpdateData).length === 0 && permsChanged) {
            filteredUpdateData.permissions = permissionCodes;
        }


      success = await onSubmit(filteredUpdateData);
    } else {
      const createData: CreateRoleRequest = {
        name: values.name,
        description: values.description || undefined,
        permissions: permissionCodes,
      };
      success = await onSubmit(createData);
    }

    if (success) {
      onClose();
    } else {
      setFormError("Failed to save role. Please check the console for details.");
    }
  };

  return (
    <Modal
      title={isEditMode ? `Edit Role: ${initialData?.name}` : 'Create New Role'}
      open={isOpen}
      onCancel={onClose}
      confirmLoading={loading}
      destroyOnClose
      footer={[
        <Button key="back" onClick={onClose} disabled={loading}>
          Cancel
        </Button>,
        <Button key="submit" type="primary" loading={loading} onClick={() => form.submit()}>
          {isEditMode ? 'Save Changes' : 'Create Role'}
        </Button>,
      ]}
      width={700} // Wider modal for permissions
    >
      <Spin spinning={loading || loadingPermissions}>
        {formError && <Alert message={formError} type="error" showIcon closable onClose={() => setFormError(null)} className="mb-4" />}
        <Form
          form={form}
          layout="vertical"
          onFinish={handleFinish}
          name="roleForm"
        >
          <Form.Item
            name="name"
            label="Role Name"
            rules={[{ required: true, message: 'Please input the role name!' }]}
          >
            <Input placeholder="Enter role name (e.g., data_viewer)" disabled={isCoreRole} />
            {isCoreRole && <p className="text-xs text-amber-600 mt-1">Core role names cannot be changed.</p>}
          </Form.Item>

          <Form.Item
            name="description"
            label="Description"
          >
            <Input.TextArea rows={2} placeholder="Optional: Describe the role's purpose" />
          </Form.Item>

          <Form.Item
            name="permissions"
            label="Permissions"
             rules={[{ type: 'array' }]}
          >
            <Checkbox.Group style={{ width: '100%' }}>
                <Row gutter={[8, 8]}>
                    {availablePermissions.sort((a, b) => a.code.localeCompare(b.code)).map(perm => (
                        <Col span={12} key={perm.id}>
                           <Tooltip title={perm.description || perm.code} placement="right">
                             <Checkbox value={perm.code} disabled={isCoreRole && perm.code !== 'config:update' && perm.code !== 'classify:item'}> {/* Example: prevent removing most admin perms */}
                                {perm.code}
                             </Checkbox>
                           </Tooltip>
                        </Col>
                    ))}
                     {availablePermissions.length === 0 && !loadingPermissions && (
                        <Col span={24}><Alert message="No permissions found or failed to load." type="warning" showIcon /></Col>
                    )}
                 </Row>
            </Checkbox.Group>
            {isCoreRole && <p className="text-xs text-amber-600 mt-1">Permissions for core roles ('admin', 'classifier') cannot be modified significantly.</p>}
          </Form.Item>

        </Form>
      </Spin>
    </Modal>
  );
};

File: src/components/BatchTab/BatchProgress.tsx
import React from 'react';

interface BatchProgressProps {
  current: number;
  total: number;
  currentKey?: string; // Add new prop for the current key being processed
}

const BatchProgress: React.FC<BatchProgressProps> = ({ current, total, currentKey }) => {
  // Ensure we don't divide by zero and get a valid percentage
  const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
  
  // Determine if processing is truly complete
  const isComplete = total > 0 && current === total;
  
  // Check if processing has actually started
  const hasStarted = current > 0;

  return (
    <div className="w-96">
      {/* Progress text */}
      <div className="flex justify-between mb-1">
        <span className="text-sm font-medium text-secondary-700">
          {hasStarted ? `Processing... (${current}/${total} items)` : `Initializing... (0/${total} items)`}
        </span>
        <span className="text-sm font-medium text-secondary-700">
          {percentage}%
        </span>
      </div>

      {/* Progress bar */}
      <div className="w-full bg-secondary-200 rounded-full h-2.5">
        <div
          className="bg-primary-600 h-2.5 rounded-full transition-all duration-500 ease-in-out"
          style={{ width: `${percentage}%` }}
        />
      </div>

      {/* Current key being processed - only show if key is provided */}
      {currentKey && hasStarted && !isComplete && (
        <div className="mt-1 text-xs text-secondary-600">
          Current key: <span className="font-medium">{currentKey}</span>
        </div>
      )}

      {/* Status message - only show when truly complete */}
      {isComplete && (
        <div className="mt-1 text-xs text-secondary-500">
          <span className="text-green-600">Processing complete</span>
        </div>
      )}
    </div>
  );
};

export default BatchProgress;

File: src/components/RagInfoTab/components/RagInfoPagination.tsx
// src/components/RagInfoTab/components/RagInfoPagination.tsx
import React from 'react';

interface RagInfoPaginationProps {
    currentPage: number;
    totalPages: number;
    totalCount: number;
    pageSize: number; // Pass pageSize if needed for display
    loading: boolean;
    onPageChange: (page: number) => void;
}

export const RagInfoPagination: React.FC<RagInfoPaginationProps> = ({
    currentPage, totalPages, totalCount, pageSize, loading, onPageChange
}) => {
    // Don't show pagination if only one page or no results
    if (!totalCount || totalPages <= 1) {
        return null;
    }

    const firstItem = (currentPage - 1) * pageSize + 1;
    const lastItem = Math.min(currentPage * pageSize, totalCount);

    return (
        <div className="mt-6 flex items-center justify-between">
            {/* Results Count Text */}
            <p className="text-sm text-secondary-600">
                Showing <span className="font-medium">{firstItem}</span>-
                <span className="font-medium">{lastItem}</span> of{' '}
                <span className="font-medium">{totalCount}</span> results
            </p>
            {/* Pagination Buttons */}
            <div className="flex items-center gap-1">
                <button
                    onClick={() => onPageChange(1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >First</button>
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Previous</button>
                <span className="text-sm text-secondary-600 px-2">
                    Page {currentPage} of {totalPages}
                </span>
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Next</button>
                <button
                    onClick={() => onPageChange(totalPages)}
                    disabled={currentPage === totalPages || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Last</button>
            </div>
        </div>
    );
};

File: src/components/RagInfo/RagInfoComponent.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Modal, Form, Input, message, Space } from 'antd';
import { useAuth } from '../../context/AuthContext';
import { EditOutlined, DeleteOutlined, EyeOutlined, PlusOutlined } from '@ant-design/icons';
import { 
  ApiClient, 
  CreateRagInfoRequest,
  UpdateRagInfoRequest,
  RagInfoRequestParams
} from '../../api/types';

// Define the types needed for RAG functionality
export interface RagInfoComponentProps {
  apiClient: ApiClient;
}

// Updated RagInfoData interface to match API types while adding UI-specific fields
interface RagInfoData {
  id: string;
  key: string; 
  description: string;
  createdAt: string;
  updatedAt: string;
}

interface RagFormData {
  key: string;
  description: string;
}

export const RagInfoComponent: React.FC<RagInfoComponentProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();
  
  // Component state
  const [ragInfoItems, setRagInfoItems] = useState<RagInfoData[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showViewModal, setShowViewModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState<RagInfoData | null>(null);
  const [form] = Form.useForm();
  
  // Load RAG info items when component mounts
  useEffect(() => {
    loadRagInfo();
  }, []);
  
  const loadRagInfo = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Use the correct API method for listing all items
      const params: RagInfoRequestParams = { limit: 100 };
      const response = await apiClient.getRagInfoList(params);
      
      // Map the API response directly to our component's data structure
      const transformedItems = response.items.map(item => ({
        ...item
      }));
      
      setRagInfoItems(transformedItems || []);
    } catch (err) {
      console.error('Failed to load RAG information:', err);
      setError('Failed to load information items');
    } finally {
      setLoading(false);
    }
  };
  
  const handleCreateInfo = async (data: RagFormData) => {
    // Check if user has permission to create RAG info
    if (!checkPermission('rag:create')) {
      setError('You do not have permission to create RAG information');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: CreateRagInfoRequest = {
        key: data.key,
        description: data.description
      };
      
      await apiClient.createRagInfo(request);
      message.success('RAG information created successfully');
      setShowCreateModal(false);
      form.resetFields();
      loadRagInfo(); // Refresh the list
    } catch (err) {
      console.error('Failed to create RAG information:', err);
      setError('Failed to create information item');
    } finally {
      setLoading(false);
    }
  };
  
  const handleUpdateInfo = async (data: RagFormData) => {
    // Check if user has permission to update RAG info
    if (!checkPermission('rag:update')) {
      setError('You do not have permission to update RAG information');
      return;
    }
    
    if (!selectedItem) {
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const request: UpdateRagInfoRequest = {
        key: data.key,
        description: data.description
      };
      
      await apiClient.updateRagInfo(selectedItem.id, request);
      message.success('RAG information updated successfully');
      setShowEditModal(false);
      form.resetFields();
      loadRagInfo(); // Refresh the list
    } catch (err) {
      console.error('Failed to update RAG information:', err);
      setError('Failed to update information item');
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeleteInfo = async (id: string) => {
    // Check if user has permission to delete RAG info
    if (!checkPermission('rag:delete')) {
      setError('You do not have permission to delete RAG information');
      return;
    }
    
    setLoading(true);
    
    try {
      await apiClient.deleteRagInfo(id);
      message.success('RAG information deleted successfully');
      loadRagInfo(); // Refresh the list
    } catch (err) {
      console.error('Failed to delete RAG information:', err);
      setError('Failed to delete information item');
    } finally {
      setLoading(false);
    }
  };
  
  const showDeleteConfirm = (id: string) => {
    Modal.confirm({
      title: 'Are you sure you want to delete this item?',
      content: 'This action cannot be undone.',
      okText: 'Yes',
      okType: 'danger',
      cancelText: 'No',
      onOk() {
        handleDeleteInfo(id);
      },
    });
  };
  
  const openCreateModal = () => {
    form.resetFields();
    setShowCreateModal(true);
  };
  
  const openEditModal = (item: RagInfoData) => {
    setSelectedItem(item);
    form.setFieldsValue({
      key: item.key,
      description: item.description
    });
    setShowEditModal(true);
  };
  
  const openViewModal = (item: RagInfoData) => {
    setSelectedItem(item);
    setShowViewModal(true);
  };
  
  const columns = [
    {
      title: 'Key',
      dataIndex: 'key',
      key: 'key',
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
    },
    {
      title: 'Created At',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: 'Updated At',
      dataIndex: 'updatedAt',
      key: 'updatedAt',
      render: (text: string) => new Date(text).toLocaleString(),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: RagInfoData) => (
        <Space size="small">
          <Button 
            type="text" 
            icon={<EyeOutlined />} 
            onClick={() => openViewModal(record)}
          />
          {checkPermission('rag:update') && (
            <Button 
              type="text" 
              icon={<EditOutlined />} 
              onClick={() => openEditModal(record)}
            />
          )}
          {checkPermission('rag:delete') && (
            <Button 
              type="text" 
              danger 
              icon={<DeleteOutlined />} 
              onClick={() => showDeleteConfirm(record.id)}
            />
          )}
        </Space>
      ),
    },
  ];
  
  return (
    <div className="rag-info-container">
      {error && <div className="error-message">{error}</div>}
      
      <div className="actions-container" style={{ marginBottom: '16px' }}>
        {checkPermission('rag:create') && (
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={openCreateModal}
          >
            Add New Information
          </Button>
        )}
      </div>
      
      <Table
        dataSource={ragInfoItems}
        columns={columns}
        rowKey="id"
        loading={loading}
        pagination={{ pageSize: 10 }}
      />
      
      {/* Create Modal */}
      <Modal
        title="Add New RAG Information"
        open={showCreateModal}
        onCancel={() => setShowCreateModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleCreateInfo}
        >
          <Form.Item
            name="key"
            label="Key"
            rules={[{ required: true, message: 'Please enter a key' }]}
          >
            <Input />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
            rules={[{ required: true, message: 'Please enter a description' }]}
          >
            <Input.TextArea rows={6} />
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Create
            </Button>
            <Button onClick={() => setShowCreateModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* Edit Modal */}
      <Modal
        title="Edit RAG Information"
        open={showEditModal}
        onCancel={() => setShowEditModal(false)}
        footer={null}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleUpdateInfo}
        >
          <Form.Item
            name="key"
            label="Key"
            rules={[{ required: true, message: 'Please enter a key' }]}
          >
            <Input />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="Description"
            rules={[{ required: true, message: 'Please enter a description' }]}
          >
            <Input.TextArea rows={6} />
          </Form.Item>
          
          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} style={{ marginRight: 8 }}>
              Update
            </Button>
            <Button onClick={() => setShowEditModal(false)}>
              Cancel
            </Button>
          </Form.Item>
        </Form>
      </Modal>
      
      {/* View Modal */}
      <Modal
        title="RAG Information Details"
        open={showViewModal}
        onCancel={() => setShowViewModal(false)}
        footer={[
          <Button key="close" onClick={() => setShowViewModal(false)}>
            Close
          </Button>
        ]}
      >
        {selectedItem && (
          <>
            <p><strong>Key:</strong> {selectedItem.key}</p>
            <p><strong>Description:</strong></p>
            <pre style={{ 
              whiteSpace: 'pre-wrap', 
              backgroundColor: '#f5f5f5', 
              padding: '10px', 
              borderRadius: '4px',
              maxHeight: '300px',
              overflow: 'auto'
            }}>
              {selectedItem.description}
            </pre>
            <p><strong>Created:</strong> {new Date(selectedItem.createdAt).toLocaleString()}</p>
            <p><strong>Last Updated:</strong> {new Date(selectedItem.updatedAt).toLocaleString()}</p>
          </>
        )}
      </Modal>
    </div>
  );
};

export default RagInfoComponent;

File: src/components/RagInfoTab/components/RagInfoTable.tsx
// src/components/RagInfoTab/components/RagInfoTable.tsx
import React from 'react';
import { RagInfoItem } from '../../../api/types'; // Adjust path
import { formatDate } from '../../../utils/dateFormat'; // Adjust path

interface RagInfoTableProps {
    items: RagInfoItem[];
    loading: boolean;
    onEdit: (item: RagInfoItem) => void;
    onDelete: (item: RagInfoItem) => void;
    canEdit: boolean; // Add permission props
    canDelete: boolean; // Add permission props
}

export const RagInfoTable: React.FC<RagInfoTableProps> = ({
    items,
    loading,
    onEdit,
    onDelete,
    canEdit,
    canDelete
}) => {
    if (loading && items.length === 0) {
        return <div className="text-center py-8 text-secondary-500">Loading...</div>;
    }

    if (!loading && items.length === 0) {
        return <div className="text-center py-8 text-secondary-500">No information found.</div>;
    }

    return (
        <div className="overflow-x-auto rounded-card border border-secondary-200">
            <table className="min-w-full divide-y divide-secondary-200">
                <thead className="bg-secondary-50">
                    <tr>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Key</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Description</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Created At</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Updated At</th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Actions</th>
                    </tr>
                </thead>
                <tbody className="bg-white divide-y divide-secondary-200">
                    {items.map((item) => (
                        <tr key={item.id} className="hover:bg-secondary-50">
                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-secondary-900">{item.key}</td>
                            <td className="px-6 py-4 text-sm text-secondary-600 max-w-md truncate" title={item.description}>{item.description}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-500">
                                <span title={formatDate(item.createdAt).fullText}>
                                    {formatDate(item.createdAt).displayText}
                                </span>
                            </td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-secondary-500">
                                <span title={formatDate(item.updatedAt).fullText}>
                                    {formatDate(item.updatedAt).displayText}
                                </span>
                             </td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm space-x-2">
                                <button
                                    onClick={() => onEdit(item)}
                                    className={`btn py-1 px-2 text-xs ${
                                        canEdit 
                                        ? 'btn-secondary hover:bg-secondary-50' 
                                        : 'btn-disabled opacity-50 cursor-not-allowed'
                                    }`}
                                    aria-label={`Edit item ${item.key}`}
                                    disabled={loading || !canEdit}
                                    title={!canEdit ? "Permission denied" : `Edit item ${item.key}`}
                                > Edit </button>
                                <button
                                    onClick={() => onDelete(item)}
                                    className={`btn py-1 px-2 text-xs ${
                                        canDelete
                                        ? 'btn-secondary text-red-600 border-red-200 hover:bg-red-50'
                                        : 'btn-disabled opacity-50 cursor-not-allowed text-red-300'
                                    }`}
                                    aria-label={`Delete item ${item.key}`}
                                    disabled={loading || !canDelete}
                                    title={!canDelete ? "Permission denied" : `Delete item ${item.key}`}
                                > Delete </button>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

File: src/components/BatchTab/BatchTab.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { BatchClassificationRequest, BatchClassificationResult, BatchItemResult } from '../../api/types';
import FileUpload from './FileUpload';
import ColumnSelector from './ColumnSelector';
import BatchProgress from './BatchProgress';
import PreviewTable from './PreviewTable';
import BatchSummary from './BatchSummary';
import { BatchTabProps, ColumnConfig as ColumnConfigBase, PreviewData, SystemConfig } from './types';
import Papa from 'papaparse'; // Make sure papaparse is installed
import * as XLSX from 'xlsx'; // Make sure xlsx is installed
import { useAuth } from '../../context/AuthContext'; // Import useAuth hook

// Define a more specific type for the state if needed
interface BatchColumnConfig extends Omit<ColumnConfigBase, 'resultColumns' | 'keyColumns'> {
  keyColumnNames: string[];
}

// Helper function to check if a result has valid classification
const isValidClassification = (result: BatchItemResult): boolean => {
  try {
    if (!result?.result?.levels) {
      console.debug('Missing result or levels:', { result });
      return false;
    }

    // Check if any level has both code and name
    return Object.values(result.result.levels).some(level => 
      level && typeof level === 'object' &&
      typeof level.code === 'string' && level.code.length > 0 &&
      typeof level.name === 'string' && level.name.length > 0
    );
  } catch (error) {
    console.error('Error validating classification:', error);
    return false;
  }
};

// Parse file function to handle uploaded files (CSV/Excel)
const parseFile = async (file: File): Promise<PreviewData> => {
  return new Promise((resolve, reject) => {
    const fileType = file.name.split('.').pop()?.toLowerCase();
    
    if (fileType === 'csv') {
      // Parse CSV
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          if (results.errors && results.errors.length > 0) {
            console.error('CSV parsing errors:', results.errors);
            reject(new Error('Failed to parse CSV file'));
            return;
          }
          
          // Get headers from first row
          const headers = results.meta.fields || [];
          
          // Convert data to array of string arrays
          const rows = results.data.map((row: any) => {
            return headers.map(header => row[header] || '');
          });
          
          resolve({
            headers,
            rows,
            fileName: file.name,
            fileType: 'csv'
          });
        },
        error: (error) => {
          console.error('CSV parsing error:', error);
          reject(error);
        }
      });
    } else if (fileType === 'xlsx' || fileType === 'xls') {
      // Parse Excel
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target?.result as ArrayBuffer);
          const workbook = XLSX.read(data, { type: 'array' });
          
          // Get first sheet
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          
          // Convert to JSON
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }) as any[][];
          
          // Extract headers from first row
          const headers = jsonData[0].map(h => String(h));
          
          // Extract data rows, starting from second row
          const rows = jsonData.slice(1).map(row => {
            // Ensure all cells are strings and handle missing cells
            return headers.map((_, i) => row[i] !== undefined ? String(row[i]) : '');
          });
          
          resolve({
            headers,
            rows,
            fileName: file.name,
            fileType: 'excel'
          });
        } catch (error) {
          console.error('Excel parsing error:', error);
          reject(error);
        }
      };
      
      reader.onerror = (error) => {
        console.error('File reading error:', error);
        reject(error);
      };
      
      reader.readAsArrayBuffer(file);
    } else {
      reject(new Error('Unsupported file format. Please upload a CSV or Excel file.'));
    }
  });
};

export const BatchTab: React.FC<BatchTabProps> = ({ apiClient }) => {
  // Get permission checker from auth context
  const { checkPermission } = useAuth();

  const [file, setFile] = useState<File | null>(null);
  const [previewData, setPreviewData] = useState<PreviewData | null>(null);
  const [sourceColumn, setSourceColumn] = useState<string>('');
  const [contextColumn, setContextColumn] = useState<string | undefined>(undefined);
  const [selectedKeyColumns, setSelectedKeyColumns] = useState<string[]>([]); // Store key names
  const [isProcessing, setIsProcessing] = useState(false);
  const [processedItems, setProcessedItems] = useState<number>(0);
  const [batchId, setBatchId] = useState<string | null>(null);
  const [batchResults, setBatchResults] = useState<BatchItemResult[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [completedBatch, setCompletedBatch] = useState<BatchClassificationResult | null>(null);
  const [rowsToProcess, setRowsToProcess] = useState<number>(5);
  const [processAll, setProcessAll] = useState<boolean>(false);
  const [batchTotalItems, setBatchTotalItems] = useState<number>(0);

  // Pagination states
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize] = useState(10);
  const [totalPages, setTotalPages] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [availableSystems, setAvailableSystems] = useState<SystemConfig[]>([]);
  const [selectedSystem, setSelectedSystem] = useState<SystemConfig | null>(null);

  // Load classification systems on mount
  useEffect(() => {
    const loadSystems = async () => {
      try {
        const systems = await apiClient.getClassificationSystems();
        const systemConfigs = await Promise.all(
          systems.map(async (system: { code: any; }) => {
            const details = await apiClient.getClassificationSystem(system.code);
            return details;
          })
        );
        setAvailableSystems(systemConfigs);
      } catch (error) {
        console.error('Error loading classification systems:', error);
        setError('Failed to load classification systems');
      }
    };
    loadSystems();
  }, [apiClient]);

  // Effect for polling batch status
  useEffect(() => {
    let intervalId: NodeJS.Timeout;

    const pollBatchStatus = async () => {
      if (!batchId || !isProcessing) return;

      try {
        setError(null);
        console.log('Polling batch status:', batchId);
        const status = await apiClient.getBatchStatus(batchId);
        console.log('Received status:', status);

        if (!status) {
          throw new Error('No status received from server');
        }

        // Fix case sensitivity issue - server returns lowercase 'results'
        const resultsArray = status.results || [];
        console.log('Got results array with', resultsArray.length, 'items');

        // Clone and validate results
        const results = resultsArray.map((r: BatchItemResult) => ({
          description: r.description || '',
          additional_context: r.additional_context || '',
          key: r.key || '', // Ensure key field is preserved
          error: r.error || null,
          result: r.result ? {
            ...r.result,
            levels: r.result.levels ? { ...r.result.levels } : {}
          } : null
        }));

        // Update batch results
        const totalItems = results.length;
        setTotalCount(totalItems);
        setTotalPages(Math.ceil(totalItems / pageSize));
        
        // Calculate paginated results
        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const paginatedResults = results.slice(startIndex, endIndex);
        setBatchResults(paginatedResults);

        // Count valid results
        const validResults = results.filter(isValidClassification);
        console.log('Processing status:', {
          total: totalItems,
          valid: validResults.length,
          currentPage,
          totalPages: Math.ceil(totalItems / pageSize)
        });
        
        // Check if results have key fields
        const hasKeys = results.some((r: { key: any; }) => r.key);
        console.log('Batch contains key fields:', hasKeys);
        
        // Count only items that have been actually processed (either success or error)
        const processedCount = results.filter((r: { result: { status: string }; }) =>
          r.result && r.result.status && r.result.status !== 'pending'
        ).length;
        setProcessedItems(processedCount);

        if (status.status === 'completed' || status.status === 'error') {
          console.log('Batch processing finished:', status.status);

          // Set completed batch state
          setCompletedBatch({
            id: status.id || batchId,
            status: status.status,
            timestamp: status.timestamp || new Date().toISOString(),
            results: results
          });

          // Clear processing state
          setIsProcessing(false);
          setBatchId(null);
        }
      } catch (error) {
        console.error('Error polling batch status:', error);
        setError('Failed to get batch status');
        setIsProcessing(false);
        setBatchId(null);
        setCompletedBatch(null);
        setBatchResults([]);
      }
    };

    if (isProcessing && batchId) {
      intervalId = setInterval(pollBatchStatus, 2000);
    }

    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [batchId, isProcessing, apiClient, currentPage, pageSize]);

  const handleFileUpload = async (uploadedFile: File) => {
    setFile(uploadedFile);
    setError(null);
    setBatchResults([]);
    setCompletedBatch(null);
    setProcessedItems(0);

    try {
      const result = await parseFile(uploadedFile);
      setPreviewData(result);
      setRowsToProcess(Math.min(5, result.rows.length));
    } catch (error) {
      console.error('Error parsing file:', error);
      setError('Failed to parse file. Please make sure it is a valid CSV or Excel file.');
    }
  };

  const handleSystemSelect = (systemCode: string) => {
    setSelectedSystem(availableSystems.find(s => s.system.code === systemCode) || null);
  };

  // Modify handler passed to ColumnSelector
  const handleColumnSelectionUpdate = useCallback((
    config: { sourceColumn: string; contextColumn?: string; keyColumnNames: string[] }
  ) => {
    setSourceColumn(config.sourceColumn);
    setContextColumn(config.contextColumn);
    setSelectedKeyColumns(config.keyColumnNames);
    setError(null); // Reset error on selection change
  }, []);

  const handleRowCountChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(event.target.value, 10);
    if (!isNaN(value) && value > 0 && previewData) {
      setRowsToProcess(Math.min(value, previewData.rows.length));
    }
  };

  const handleStartProcessing = async () => {
    if (!checkPermission('classify:batch')) {
      setError('You do not have permission to perform batch classifications');
      return;
    }

    if (!file || !sourceColumn || !previewData || !selectedSystem) {
      setError("Please select the source description column.");
      return;
    }

    // Determine and set the fixed total for this run
    const totalForThisBatch = processAll ? previewData.rows.length : rowsToProcess;
    setBatchTotalItems(totalForThisBatch);

    setIsProcessing(true);
    setBatchResults([]);
    setProcessedItems(0);
    setError(null);
    setCompletedBatch(null);

    try {
      const allRows = previewData.rows;
      const rowsToUse = allRows.slice(0, totalForThisBatch);

      const items = rowsToUse.map(row => {
        const sourceIndex = previewData.headers.indexOf(sourceColumn);
        const contextIndex = contextColumn
          ? previewData.headers.indexOf(contextColumn)
          : -1;
        
        // Generate composite key from selected key columns
        let key = '';
        if (selectedKeyColumns && selectedKeyColumns.length > 0) {
          const keyParts = selectedKeyColumns.map(keyCol => {
            const keyIndex = previewData.headers.indexOf(keyCol);
            return keyIndex >= 0 ? row[keyIndex] : '';
          }).filter(Boolean); // Remove empty values
          
          key = keyParts.join('|'); // Join with pipe delimiter for multiple key parts
        }

        return {
          description: row[sourceIndex],
          additionalContext: contextIndex >= 0 ? row[contextIndex] : undefined,
          key: key || undefined // Only include key if it has a value
        };
      });

      // Create request with key column names
      const request: BatchClassificationRequest & { key_column_names?: string[] } = {
        items,
        systemCode: selectedSystem.system.code,
        key_column_names: selectedKeyColumns // Pass the selected key names
      };

      console.log('Starting batch with request:', { 
        itemCount: request.items.length,
        systemCode: request.systemCode,
        keyColumnNames: request.key_column_names
      });

      const result = await apiClient.classifyBatch(request);
      console.log('Started batch processing:', result?.id);

      if (!result?.id) {
        throw new Error('No batch ID received from server');
      }

      setBatchId(result.id);
    } catch (error) {
      console.error('Error starting batch process:', error);
      setError('Failed to start batch processing');
      setIsProcessing(false);
      setBatchTotalItems(0); // Reset total on error
    }
  };

  const handlePageChange = (page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
      // Results will be updated by the polling effect
      console.debug('Changing to page:', page);
    }
  };

  return (
    <div className="max-w-8xl mx-auto space-y-10" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem'}}>
      {!checkPermission('classify:batch') && (
        <div className="bg-white shadow-card rounded-card p-6 border-l-4 border-yellow-500">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-yellow-800">Permission Notice</h3>
              <div className="mt-2 text-sm text-yellow-700">
                <p>You don't have permission to perform batch classifications. Contact your administrator for access.</p>
              </div>
            </div>
          </div>
        </div>
      )}

      <div className="bg-white shadow-card rounded-card p-8 w-full" style={{ paddingRight: '5rem', paddingLeft: '3rem'}}>
        <div className="space-y-8">
          {error && (
            <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3">
              <p className="text-sm text-red-700">{error}</p>
            </div>
          )}

          <div className="border-b pb-6">
            <h3 className="text-lg font-medium mb-3">1. Upload File</h3>
            <FileUpload onFileUpload={handleFileUpload} />
          </div>

          {previewData && (
            <>
              <div className="border-b pb-6">
                <div className="flex justify-between items-center mb-3">
                  <h3 className="text-lg font-medium">2. Preview Data</h3>
                  {isProcessing && (
                    <div className="ml-4">
                      <BatchProgress 
                        current={processedItems} 
                        total={batchTotalItems}
                      />
                    </div>
                  )}
                </div>
                <PreviewTable 
                  data={previewData}
                  columnConfig={{
                    sourceColumn,
                    contextColumn,
                    keyColumns: selectedKeyColumns, // Pass key columns to preview
                    resultColumns: [],
                    descriptionColumnIndex: sourceColumn ? previewData.headers.indexOf(sourceColumn) : -1
                  }}
                  batchResults={batchResults}
                  isProcessing={isProcessing}
                />
              </div>

              <div className="border-b pb-6">
                <h3 className="text-lg font-medium mb-3">3. Select Columns</h3>
                <ColumnSelector 
                  headers={previewData.headers}
                  onColumnSelect={handleColumnSelectionUpdate}
                  availableSystems={availableSystems}
                  onSystemSelect={handleSystemSelect}
                  selectedSystem={selectedSystem}
                />
              </div>
            </>
          )}

          {!isProcessing && completedBatch && (
            <div className="border-b pb-6">
              <h3 className="text-lg font-medium mb-3">Results</h3>
              <BatchSummary
                result={completedBatch}
                originalData={{
                  headers: previewData?.headers || [],
                  rows: previewData?.rows || []
                }}
              />
              
              {/* Move pagination controls here */}
              {batchResults.length > 0 && (
                <div className="mt-6 flex items-center justify-between">
                  <div className="flex-1 flex justify-between items-center">
                    <p className="text-sm text-secondary-600">
                      Showing {Math.min((currentPage - 1) * pageSize + 1, totalCount)} - {Math.min(currentPage * pageSize, totalCount)} of {totalCount} results
                    </p>
                    
                    {/* Pagination buttons */}
                    <div className="flex items-center gap-2">
                      <button
                        onClick={() => handlePageChange(1)}
                        disabled={currentPage === 1 || isProcessing}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        First
                      </button>
                      
                      <button
                        onClick={() => handlePageChange(currentPage - 1)}
                        disabled={currentPage === 1 || isProcessing}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Previous
                      </button>

                      {(() => {
                        const pages = [];
                        const maxButtons = 5;
                        let start = Math.max(1, currentPage - Math.floor(maxButtons / 2));
                        let end = Math.min(start + maxButtons - 1, totalPages);

                        // Adjust start if we're at the end
                        if (end === totalPages) {
                          start = Math.max(1, end - maxButtons + 1);
                        }

                        // Show dots at start if needed
                        if (start > 1) {
                          pages.push(
                            <span key="start-dots" className="px-2 py-2 text-secondary-500">...</span>
                          );
                        }

                        // Page numbers
                        for (let i = start; i <= end; i++) {
                          pages.push(
                            <button
                              key={i}
                              onClick={() => handlePageChange(i)}
                              disabled={isProcessing}
                              className={`px-3 py-2 rounded-lg border text-sm font-medium ${
                                i === currentPage
                                  ? 'bg-primary-600 text-white border-primary-600'
                                  : 'border-secondary-200 text-secondary-700 hover:bg-secondary-50'
                              }`}
                            >
                              {i}
                            </button>
                          );
                        }

                        // Show dots at end if needed
                        if (end < totalPages) {
                          pages.push(
                            <span key="end-dots" className="px-2 py-2 text-secondary-500">...</span>
                          );
                        }

                        return pages;
                      })()}

                      <button
                        onClick={() => handlePageChange(currentPage + 1)}
                        disabled={currentPage === totalPages || isProcessing}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Next
                      </button>
                      
                      <button
                        onClick={() => handlePageChange(totalPages)}
                        disabled={currentPage === totalPages || isProcessing || totalPages <= 1}
                        className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Last
                      </button>
                    </div>
                  </div>
                </div>
              )}
              
              <button
                onClick={() => {
                  setCompletedBatch(null);
                  setBatchResults([]);
                  setProcessedItems(0);
                  setError(null);
                }}
                className="mt-4 w-full py-3 px-4 rounded-card text-white font-medium transition-colors bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
              >
                Process Another Batch
              </button>
            </div>
          )}

          {previewData && sourceColumn && selectedSystem && !completedBatch && (
            <div className="space-y-6">
              {/* Selected System Display */}
              <div className="flex flex-col space-y-3">
                <h3 className="text-lg font-medium">4. Selected System</h3>
                <div className="bg-secondary-50 rounded-card border border-secondary-200 p-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <p className="text-sm font-medium text-secondary-700">System Name</p>
                      <p className="mt-1 text-sm text-secondary-900">{selectedSystem.system.name}</p>
                    </div>
                    <div>
                      <p className="text-sm font-medium text-secondary-700">System Code</p>
                      <p className="mt-1 text-sm text-secondary-900">{selectedSystem.system.code}</p>
                    </div>
                    {selectedSystem.system.description && (
                      <div className="col-span-2">
                        <p className="text-sm font-medium text-secondary-700">Description</p>
                        <p className="mt-1 text-sm text-secondary-900">{selectedSystem.system.description}</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Processing Options */}
              <div className="flex flex-col space-y-3">
                <h3 className="text-lg font-medium">5. Processing Options</h3>
                <div>
                  <label className="block text-sm font-medium text-secondary-700 mb-1">
                    Rows to Process
                  </label>
                    
                  {/* Restructure to a single line with flex layout */}
                  <div className="flex items-center">
                    <div className="flex items-center mr-6">
                    <input
                      type="number"
                      min="1"
                      max={previewData.rows.length}
                      value={processAll ? previewData.rows.length : rowsToProcess}
                      onChange={handleRowCountChange}
                      disabled={processAll || isProcessing}
                      className="w-24 px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent disabled:bg-gray-100"
                    />
                    </div>
                    
                    <div className="flex items-center mr-6">
                    <input
                      type="checkbox"
                      id="processAll"
                      checked={processAll}
                      onChange={(e) => setProcessAll(e.target.checked)}
                      disabled={isProcessing}
                      className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-secondary-300 rounded"
                    />
                    <label htmlFor="processAll" className="ml-2 text-sm text-secondary-700">
                      Process all rows ({previewData.rows.length} total)
                    </label>
                    </div>
     
                
                  {/* Progress indicator takes remaining space */}
                  {isProcessing && (
                    <div className="flex-grow max-w-">
                    <BatchProgress 
                      current={processedItems} 
                      total={batchTotalItems}
                    />
                    </div>
                  )}
                  </div>
                </div>
              </div>

              <div className="flex justify-center items-center pt-4">
                <button
                  onClick={handleStartProcessing}
                  disabled={isProcessing}
                  className={`py-3 rounded-card text-white font-medium transition-colors ${
                    isProcessing 
                      ? 'bg-secondary-400 cursor-not-allowed w-full' 
                      : 'bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 px-8'
                  }`}
                >
                  {isProcessing ? 'Processing...' : 'Start Processing'}
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default BatchTab;


File: src/components/Layout/Breadcrumb.tsx
import React, { useMemo } from 'react';
import { Breadcrumb as AntBreadcrumb } from 'antd';
import { useLocation, Link } from 'react-router-dom';

/**
 * Map of paths to their display names
 */
const PATH_LABELS: Record<string, string> = {
  '/': 'Home',
  '/test': 'Test',
  '/batch': 'Batch',
  '/history': 'History',
  '/settings': 'Settings'
};

/**
 * Breadcrumb component that shows the current location in the application
 */
const Breadcrumb: React.FC = () => {
  const location = useLocation();

  const breadcrumbItems = useMemo(() => {
    // Split the path into segments
    const pathSegments = location.pathname.split('/').filter(Boolean);
    
    // Start with home
    const items = [{
      title: <Link to="/">Home</Link>,
    }];

    // Build up the path progressively
    let currentPath = '';
    pathSegments.forEach(segment => {
      currentPath += `/${segment}`;
      const label = PATH_LABELS[currentPath] || segment.charAt(0).toUpperCase() + segment.slice(1);
      
      items.push({
        title: currentPath === location.pathname ? 
          <span>{label}</span> : 
          <Link to={currentPath}>{label}</Link>,
      });
    });

    return items;
  }, [location.pathname]);

  return (
    <AntBreadcrumb 
      className="px-4 py-2 bg-white shadow-sm"
      items={breadcrumbItems}
    />
  );
};

export default Breadcrumb;

File: src/components/RagInfoTab/components/RagInfoFilters.tsx
// src/components/RagInfoTab/components/RagInfoFilters.tsx
import React from 'react';

interface RagInfoFiltersProps {
    searchTerm: string;
    onSearchChange: (term: string) => void;
    loading: boolean;
}

export const RagInfoFilters: React.FC<RagInfoFiltersProps> = ({
    searchTerm,
    onSearchChange,
    loading
}) => {
    return (
        <div className="mb-4">
            <label htmlFor="ragSearch" className="label">
                Search Key / Description
            </label>
            <input
                type="text"
                id="ragSearch"
                placeholder="Search..."
                className="input" // Use global style from index.css
                value={searchTerm}
                onChange={(e) => onSearchChange(e.target.value)}
                disabled={loading}
            />
        </div>
    );
};

File: src/components/BatchTab/BatchSummary.tsx
import React from 'react';
import { BatchClassificationResult, ClassificationError, BatchItemResult } from '../../api/types';
import { saveAs } from 'file-saver';
import { formatDate } from '../../utils/dateFormat';
import { 
  isSuccessfulItem, 
  isFailedItem, 
  isPartialItem 
} from '../BatchJobsTab/utils/batchJobUtils';

interface BatchSummaryProps {
  result: BatchClassificationResult;
  originalData: {
    headers: string[];
    rows: string[][];
  };
}

// Helper function to get error message from either string or ClassificationError
const getErrorMessage = (error: string | ClassificationError | undefined): string => {
  if (!error) return '';
  if (typeof error === 'string') return error;
  return error.message || 'Unknown error';
};

// Function to split multi-keys into array (separated by |)
const splitMultiKey = (key: string = ''): string[] => {
  if (!key) return [''];
  return key.split('|').map(k => k.trim());
};

// Determines the maximum number of key parts across all items
const getMaxKeyParts = (results: BatchItemResult[]): number => {
  let maxParts = 1; // Default to at least one key column
  
  for (const item of results) {
    if (item.key) {
      const keyParts = splitMultiKey(item.key);
      maxParts = Math.max(maxParts, keyParts.length);
    }
  }
  
  return maxParts;
};

const BatchSummary: React.FC<BatchSummaryProps> = ({ result, originalData }) => {
  const results = result.Results || result.results || [];
  const successCount = results.filter(r => isSuccessfulItem(r)).length;
  const partialCount = results.filter(r => isPartialItem(r)).length;
  const failureCount = results.filter(r => isFailedItem(r)).length;

  // Check if any result has a key field
  const hasKeys = results.some(r => r.key);
  // Calculate maximum number of key parts
  const maxKeyParts = hasKeys ? getMaxKeyParts(results) : 0;

  const downloadResults = () => {
    try {
      // Get level codes from the first successful result
      const firstSuccess = results.find(r => r.result);
      
      if (!firstSuccess || !firstSuccess.result) {
        alert('No successful results to download');
        return;
      }
      
      // Verify the levels object exists
      const levels = firstSuccess.result.levels || {};
      console.log('Levels found:', Object.keys(levels).join(', '));
      
      if (Object.keys(levels).length === 0) {
        alert('Warning: No classification levels found in the results');
      }
      
      // Define the level order (if available)
      const levelOrder: Record<string, number> = {
        'segment': 1,
        'family': 2,
        'class': 3,
        'commodity': 4
      };
      
      // Get all possible level codes
      const levelCodes = Object.keys(levels).sort((a, b) =>
        (levelOrder[a] ?? 999) - (levelOrder[b] ?? 999)
      );
      
      // Create a clean CSV with the right number of columns for each row
      
      // Step 1: Analyze original data to understand the structure
      console.log('Original headers length:', originalData.headers.length);
      
      // Step 2: Create CSV content manually to ensure perfect alignment
      // Start with building the header row
      let csvContent = '';
      
      // Add Key columns based on the maximum number of key parts found
      if (hasKeys) {
        for (let i = 0; i < maxKeyParts; i++) {
          csvContent += `Key_${i+1},`;
        }
      }
      
      // Add original headers
      for (let i = 0; i < originalData.headers.length; i++) {
        const header = originalData.headers[i];
        const escapedHeader = escapeCsvValue(header);
        csvContent += escapedHeader + ',';
      }
      
      // Add classification status
      csvContent += 'Classification_Status,';

      // Add RAG context column if any result uses RAG
      const useRagColumn = results.some(r => r.result?.ragContextUsed);
      if (useRagColumn) {
        csvContent += 'RAG_Context,';
      }
      
      // Add level headers
      for (const level of levelCodes) {
        csvContent += `${level}_Code,${level}_Name,`;
      }
      
      // Add error column and end the header row
      csvContent += 'Error\n';
      
      // Add data rows
      for (let rowIdx = 0; rowIdx < results.length; rowIdx++) {
        const res = results[rowIdx];
        const originalRow = rowIdx < originalData.rows.length 
          ? originalData.rows[rowIdx] 
          : Array(originalData.headers.length).fill('');
          
        // Add key fields if present - split by | and add to separate columns
        if (hasKeys) {
          const keyParts = splitMultiKey(res.key || '');
          // Fill in key columns - add empty strings for missing parts
          for (let i = 0; i < maxKeyParts; i++) {
            csvContent += escapeCsvValue(keyParts[i] || '') + ',';
          }
        }
        
        // Add original data cells
        for (let colIdx = 0; colIdx < originalData.headers.length; colIdx++) {
          const cellValue = colIdx < originalRow.length ? originalRow[colIdx] : '';
          csvContent += escapeCsvValue(cellValue) + ',';
        }
        
        // Add status using consistent logic
        let status = 'Failed';
        if (isSuccessfulItem(res)) {
          status = 'Success';
        } else if (isPartialItem(res)) {
          status = 'Partial';
        }
        csvContent += escapeCsvValue(status) + ',';

        // Add RAG context if applicable
        if (useRagColumn) {
          csvContent += escapeCsvValue(res.result?.ragContext || '') + ',';
        }
        
        // Add level values
        for (const level of levelCodes) {
          const levelData = res.result?.levels?.[level];
          csvContent += escapeCsvValue(levelData?.code || '') + ',';
          csvContent += escapeCsvValue(levelData?.name || '') + ',';
        }
        
        // Add error message, including both explicit errors and level-specific error cases
        let errorMessage = '';
        if (res.error) {
          errorMessage = getErrorMessage(res.error);
        } else if (res.result?.error) {
          errorMessage = getErrorMessage(res.result.error);
        } else if (!res.result) {
          errorMessage = 'No classification result received';
        } else if (Object.keys(res.result.levels || {}).length === 0) {
          errorMessage = 'No category levels found';
        } else if (isPartialItem(res)) {
          errorMessage = 'Partial classification, some levels missing';
        }
        csvContent += escapeCsvValue(errorMessage);
        
        // End the row
        if (rowIdx < results.length - 1) {
          csvContent += '\n';
        }
      }
      
      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      
      // Create and download the file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
      saveAs(blob, `batch_classification_${timestamp}.csv`);
      
      console.log('Download initiated with file size:', blob.size, 'bytes');
      console.log('Multi-key columns used:', maxKeyParts);
    } catch (error) {
      console.error('Error generating CSV:', error);
      alert(`Error generating download: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };
  
  // Helper function to escape CSV values
  const escapeCsvValue = (value: any): string => {
    if (value === null || value === undefined) return '';
    
    const stringValue = String(value);
    const needsQuoting = stringValue.includes(',') || 
                        stringValue.includes('"') || 
                        stringValue.includes('\n') ||
                        stringValue.includes('\r');
    
    if (!needsQuoting) return stringValue;
    
    // Double up quotes and wrap in quotes
    return `"${stringValue.replace(/"/g, '""')}"`;
  };

  return (
    <div className="rounded-lg border border-secondary-200 bg-white p-6 shadow-sm">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-medium text-secondary-900">Processing Complete</h3>
      
        <span 
          className="text-sm text-secondary-600" 
          title={formatDate(result.timestamp).fullText}
        >
          {formatDate(result.timestamp).displayText}
        </span>
      </div>
      <div className="grid grid-cols-3 gap-4 mb-6">
        <div className="rounded-md bg-green-50 p-4">
          <div className="text-green-800 text-sm font-medium">Successful</div>
          <div className="text-2xl font-bold text-green-600">{successCount}</div>
        </div>
        <div className="rounded-md bg-yellow-50 p-4">
          <div className="text-yellow-800 text-sm font-medium">Partial</div>
          <div className="text-2xl font-bold text-yellow-600">{partialCount}</div>
        </div>
        <div className="rounded-md bg-red-50 p-4">
          <div className="text-red-800 text-sm font-medium">Failed</div>
          <div className="text-2xl font-bold text-red-600">{failureCount}</div>
        </div>
      </div>

      <button
        onClick={downloadResults}
        className="w-full py-3 px-4 rounded-card text-white font-medium transition-colors bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
      >
        Download Results
      </button>

      {(failureCount > 0 || partialCount > 0) && (
        <div className="mt-4">
          <h4 className="text-sm font-medium text-secondary-900 mb-2">Items with Issues:</h4>
          <div className="max-h-40 overflow-y-auto">
            {results.map((res, idx) => {
              // Show failed and partial items
              if (!isFailedItem(res) && !isPartialItem(res)) return null;

              const isProblem = isFailedItem(res);
              const bgColor = isProblem ? 'bg-red-50' : 'bg-yellow-50';
              const textColor = isProblem ? 'text-red-600' : 'text-yellow-700';
              const statusText = isProblem ? 'Failed' : 'Partial';

              return (
                <div key={idx} className={`text-sm ${textColor} mb-2 p-2 ${bgColor} rounded-md`}>
                  <div className="font-medium flex justify-between">
                    <span>Row {idx + 1} - {statusText}</span>
                    {res.key && <span className="text-xs bg-amber-100 text-amber-800 px-2 py-1 rounded">Key: {res.key}</span>}
                  </div>
                  <div className="text-xs mt-1">
                    <span className="font-medium">Description:</span> {res.description || `Item ${idx + 1}`}
                  </div>
                  <div className="text-xs mt-1">
                    <span className="font-medium">Issue:</span>{' '}
                    {res.error
                      ? getErrorMessage(res.error)
                      : res.result?.error
                      ? getErrorMessage(res.result.error)
                      : !res.result
                      ? 'Invalid classification result'
                      : isPartialItem(res)
                      ? 'Partial classification - some levels may be missing or have errors'
                      : 'Unknown issue'}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
};

export default BatchSummary;

File: src/components/Layout/PageLayout.tsx
import React, { useState, useEffect } from 'react';
import { Outlet } from 'react-router-dom';
import LeftSidebar from '../Sidebar/LeftSidebar.component';

interface PageLayoutProps {
  ragEnabled: boolean;
  onLogout: () => void; // Add logout handler prop
}

const PageLayout: React.FC<PageLayoutProps> = ({ ragEnabled, onLogout }) => {
  const [sidebarExpanded, setSidebarExpanded] = useState(false);
  
  // Add debug logging for ragEnabled prop
  useEffect(() => {
    console.log('[PageLayout] ragEnabled prop value:', ragEnabled);
  }, [ragEnabled]);
  
  const handleMouseEnter = () => {
    setSidebarExpanded(true);
  };
  
  const handleMouseLeave = () => {
    setSidebarExpanded(false);
  };

  return (
    <div className="app-container">
      <header className="app-header">
        <h1 className="app-title">GovIlm</h1>
      </header>
      
      <div className="app-content">
        <div 
          className="sidebar-wrapper"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
        >
          <LeftSidebar 
            isSidebarCollapsed={!sidebarExpanded} 
            onLogout={onLogout} // Pass the logout handler down
            ragEnabled={ragEnabled}
          />
        </div>
        
        <main className={`main-content ${sidebarExpanded ? 'sidebar-expanded' : ''}`}>
          <Outlet />
        </main>
      </div>
    </div>
  );
};

export default PageLayout;

File: src/components/BatchTab/ColumnSelector.tsx
import React, { useState, useEffect } from 'react';
import { ColumnConfig, ResultColumn, SystemConfig } from './types';

interface ColumnSelectorProps {
  headers: string[];
  onColumnSelect: (config: Omit<ColumnConfig, 'resultColumns'> & { keyColumnNames: string[] }) => void; // Pass key names separately for clarity initially
  availableSystems: SystemConfig[];
  onSystemSelect: (systemCode: string) => void;
  selectedSystem: SystemConfig | null;
}

const ColumnSelector: React.FC<ColumnSelectorProps> = ({
  headers,
  onColumnSelect,
  availableSystems,
  onSystemSelect,
  selectedSystem
}) => {
  const [sourceColumn, setSourceColumn] = useState('');
  const [contextColumn, setContextColumn] = useState('');
  const [keyColumns, setKeyColumns] = useState<string[]>([]); // State for key column names
  const [resultColumns, setResultColumns] = useState<ResultColumn[]>([]);

  // Initialize result columns when system changes
  useEffect(() => {
    if (selectedSystem) {
      const initialResultColumns: ResultColumn[] = selectedSystem.levels.map(level => ({
        levelCode: level.code,
        levelName: level.name,
        codeColumn: `${level.name}_Code`,
        nameColumn: `${level.name}_Name`,
        isNewColumn: true
      }));
      setResultColumns(initialResultColumns);
    }
  }, [selectedSystem]);

  // Effect to call onColumnSelect when selections change
  useEffect(() => {
    if (sourceColumn) { // Only call if source is selected
      onColumnSelect({
        sourceColumn,
        contextColumn: contextColumn || undefined, // Ensure undefined if empty
        keyColumnNames: keyColumns, // Pass selected key columns 
        keyColumns: keyColumns, // Also map to keyColumns for type compatibility
        descriptionColumnIndex: -1 // Keep dummy value for backward compatibility
      });
    }
  }, [sourceColumn, contextColumn, keyColumns, onColumnSelect]);

  const handleSourceColumnChange = (value: string) => {
    setSourceColumn(value);
  };

  const handleContextColumnChange = (value: string) => {
    setContextColumn(value);
  };

  const handleKeyColumnChange = (header: string, isChecked: boolean) => {
    setKeyColumns(prev => {
      if (isChecked) {
        // Add to key columns if not already present
        return [...prev, header];
      } else {
        // Remove from key columns
        return prev.filter(col => col !== header);
      }
    });
    // Note: The useEffect above will trigger onColumnSelect
  };

  const handleResultColumnChange = (levelCode: string, changes: Partial<ResultColumn>) => {
    setResultColumns(prev => ({
      ...prev,
      resultColumns: prev.map(col =>
        col.levelCode === levelCode
          ? { ...col, ...changes }
          : col
      )
    }));
  };

  const isColumnDisabled = (header: string, currentType: keyof ColumnConfig | string) => {
    if (currentType === 'sourceColumn' || currentType === 'contextColumn') {
      return (
        (currentType === 'sourceColumn' ? sourceColumn !== header : contextColumn !== header) &&
        (sourceColumn === header || contextColumn === header)
      );
    }
    // Key columns can overlap with any column
    if (currentType === 'keyColumns') {
      return false;
    }
    // For result columns
    return sourceColumn === header || contextColumn === header;
  };

  return (
    <div className="space-y-4">
      {/* Classification System Selection */}
      <div className="space-y-2">
        <label 
          htmlFor="systemSelect"
          className="block text-sm font-medium text-secondary-700"
        >
          Classification System *
        </label>
        <select
          id="systemSelect"
          value={selectedSystem?.system.code || ''}
          onChange={(e) => onSystemSelect(e.target.value)}
          className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
          required
        >
          <option value="">Select a classification system</option>
          {availableSystems.map((sys) => (
            <option key={sys.system.code} value={sys.system.code}>
              {sys.system.name} ({sys.levels.length} levels)
            </option>
          ))}
        </select>
      </div>

      {/* Source Column Selection */}
      <div className="space-y-2">
        <label 
          htmlFor="sourceColumn"
          className="block text-sm font-medium text-secondary-700"
        >
          Source Description Column *
        </label>
        <select
          id="sourceColumn"
          value={sourceColumn}
          onChange={(e) => handleSourceColumnChange(e.target.value)}
          className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
          required
        >
          <option value="">Select a column</option>
          {headers.map((header) => (
            <option 
              key={header} 
              value={header}
              disabled={isColumnDisabled(header, 'sourceColumn')}
            >
              {header}
            </option>
          ))}
        </select>
      </div>

      {/* Context Column Selection */}
      <div className="space-y-2">
        <label 
          htmlFor="contextColumn"
          className="block text-sm font-medium text-secondary-700"
        >
          Additional Context Column (Optional)
        </label>
        <select
          id="contextColumn"
          value={contextColumn}
          onChange={(e) => handleContextColumnChange(e.target.value)}
          className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
        >
          <option value="">None</option>
          {headers.map((header) => (
            <option 
              key={header} 
              value={header}
              disabled={isColumnDisabled(header, 'contextColumn')}
            >
              {header}
            </option>
          ))}
        </select>
      </div>

      {/* Key Column Selection */}
      <div className="space-y-2">
        <label className="block text-sm font-medium text-secondary-700">
          Key Columns (Select one or more columns to use as unique identifiers)
        </label>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2 p-3 border border-secondary-200 rounded-card bg-white">
          {headers.map((header) => (
            <div key={header} className="flex items-center">
              <input
                type="checkbox"
                id={`key-${header}`}
                // Use keyColumns state here
                checked={keyColumns.includes(header)}
                onChange={(e) => handleKeyColumnChange(header, e.target.checked)}
                className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-secondary-300 rounded"
              />
              <label htmlFor={`key-${header}`} className="ml-2 block text-sm text-secondary-900 truncate">
                {header}
              </label>
            </div>
          ))}
        </div>
        <p className="text-xs text-secondary-500">
          These columns will be combined to form a unique key for each row. When downloading results, 
          they will be available as separate columns (key1, key2, etc.).
        </p>
      </div>

      {/* Result Columns Selection */}
      {selectedSystem && (
        <div className="space-y-4">
          <h4 className="font-medium text-secondary-700">Result Columns</h4>
          {resultColumns.map((resultCol) => (
            <div key={resultCol.levelCode} className="space-y-2">
              <label className="block text-sm font-medium text-secondary-700">
                {resultCol.levelName} Result Columns *
              </label>
              <div className="grid grid-cols-2 gap-4">
               {/* Code Column Selection */}
               <div>
                 <select
                   value={resultCol.isNewColumn ? '__new__' : resultCol.codeColumn}
                   onChange={(e) => {
                     const isNew = e.target.value === '__new__';
                     handleResultColumnChange(resultCol.levelCode, {
                       isNewColumn: isNew,
                       codeColumn: isNew ? `${resultCol.levelName}_Code` : e.target.value
                     });
                   }}
                   className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  >
                    <option value="__new__">{resultCol.levelName} Code (New)</option>
                    {headers.map((header) => (
                      <option 
                        key={header} 
                        value={header}
                        disabled={isColumnDisabled(header, resultCol.levelCode)}
                      >
                        {header}
                      </option>
                    ))}
                  </select>
                  {resultCol.isNewColumn && (
                    <input
                      type="text"
                      value={resultCol.codeColumn}
                      onChange={(e) => handleResultColumnChange(resultCol.levelCode, {
                        codeColumn: e.target.value
                      })}
                      placeholder="Code column name"
                      className="mt-2 w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                    />
                  )}
                </div>

                {/* Name Column Selection */}
                <div>
                  <select
                    value={resultCol.isNewColumn ? '__new__' : resultCol.nameColumn}
                    onChange={(e) => {
                      const isNew = e.target.value === '__new__';
                      handleResultColumnChange(resultCol.levelCode, {
                        isNewColumn: isNew,
                        nameColumn: isNew ? `${resultCol.levelName}_Name` : e.target.value
                      });
                    }}
                    className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                  >
                    <option value="__new__">{resultCol.levelName} Name (New)</option>
                    {headers.map((header) => (
                      <option 
                        key={header} 
                        value={header}
                        disabled={isColumnDisabled(header, resultCol.levelCode)}
                      >
                        {header}
                      </option>
                    ))}
                  </select>
                  {resultCol.isNewColumn && (
                    <input
                      type="text"
                      value={resultCol.nameColumn}
                      onChange={(e) => handleResultColumnChange(resultCol.levelCode, {
                        nameColumn: e.target.value
                      })}
                      placeholder="Name column name"
                      className="mt-2 w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                    />
                  )}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Helper Text */}
      <p className="text-sm text-secondary-500 mt-2">
        * Required fields. Each column must be unique.
      </p>
    </div>
  );
};

export default ColumnSelector;

File: src/components/BatchTab/FileUpload.tsx
import React, { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import * as XLSX from 'xlsx';
import Papa from 'papaparse';
import type { PreviewData } from './types';

export interface FileUploadProps {
  onFileUpload: (file: File, sheetName?: string) => void;
}

export const parseFile = async (file: File, sheetName?: string): Promise<PreviewData> => {
  return new Promise((resolve, reject) => {
    if (file.type === 'text/csv') {
      Papa.parse(file, {
        complete: (result) => {
          if (!result.data || result.data.length === 0) {
            return reject(new Error('CSV file is empty or invalid'));
          }
          
          resolve({
            headers: result.data[0] as string[],
            rows: result.data.slice(1) as string[][],
            fileName: file.name,
            fileType: 'csv'
          });
        },
        error: (error) => reject(error)
      });
    } else {
      // Excel files
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = e.target?.result;
          const workbook = XLSX.read(data, { type: 'binary' });
          
          // If no sheet is specified, use the first one
          const selectedSheet = sheetName || workbook.SheetNames[0];
          
          if (!workbook.SheetNames.includes(selectedSheet)) {
            return reject(new Error(`Sheet "${selectedSheet}" not found in workbook`));
          }
          
          const worksheet = workbook.Sheets[selectedSheet];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          
          if (!jsonData || jsonData.length === 0) {
            return reject(new Error('Excel sheet is empty or invalid'));
          }
          
          resolve({
            headers: jsonData[0] as string[],
            rows: jsonData.slice(1) as string[][],
            fileName: file.name,
            fileType: 'excel'
          });
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = (error) => reject(error);
      reader.readAsBinaryString(file);
    }
  });
};

const FileUpload: React.FC<FileUploadProps> = ({ onFileUpload }) => {
  const [currentFile, setCurrentFile] = useState<File | null>(null);
  const [sheetOptions, setSheetOptions] = useState<string[]>([]);
  const [selectedSheet, setSelectedSheet] = useState<string>('');

  const processExcelFile = async (file: File) => {
    try {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = e.target?.result;
          const workbook = XLSX.read(data, { type: 'binary' });
          const sheets = workbook.SheetNames;
          
          if (sheets.length === 1) {
            // If there's only one sheet, just use it directly
            setCurrentFile(file);
            onFileUpload(file, sheets[0]);
          } else if (sheets.length > 1) {
            // If there are multiple sheets, show selector
            setSheetOptions(sheets);
            setSelectedSheet(sheets[0]);
            setCurrentFile(file);
          } else {
            throw new Error('No sheets found in the Excel file');
          }
        } catch (error) {
          console.error('Error processing Excel file:', error);
          alert('Failed to process Excel file: ' + (error instanceof Error ? error.message : 'Unknown error'));
        }
      };
      reader.onerror = (error) => {
        console.error('Error reading file:', error);
        alert('Failed to read file');
      };
      reader.readAsBinaryString(file);
    } catch (error) {
      console.error('Error reading Excel file:', error);
      alert('Failed to read Excel file. Please check if the file is valid.');
    }
  };

  const handleSheetSelect = async () => {
    if (!currentFile || !selectedSheet) return;

    try {
      await parseFile(currentFile, selectedSheet);
      onFileUpload(currentFile, selectedSheet);
      setSheetOptions([]); // Hide selector after selection
    } catch (error) {
      console.error('Error parsing file:', error);
      alert('Failed to parse file: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  };

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (!file) return;

    // Validate file type
    if (!isValidFileType(file)) {
      alert('Please upload a CSV or Excel file');
      return;
    }

    // Validate file size (50MB limit)
    if (file.size > 50 * 1024 * 1024) {
      alert('File size must be less than 50MB');
      return;
    }
    
    // Reset state
    setSheetOptions([]);
    
    // Handle Excel files with potential multiple sheets
    if (file.type.includes('excel') || file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
      processExcelFile(file);
    } else {
      // For CSV files, process directly
      try {
        await parseFile(file);
        setCurrentFile(file);
        onFileUpload(file);
      } catch (error) {
        console.error('Error parsing file:', error);
        alert('Failed to parse file: ' + (error instanceof Error ? error.message : 'Unknown error'));
      }
    }
  }, [onFileUpload]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'text/csv': ['.csv'],
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
      'application/vnd.ms-excel': ['.xls']
    },
    multiple: false
  });

  return (
    <>
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer
          ${isDragActive 
            ? 'border-primary-500 bg-primary-50' 
            : 'border-secondary-300 hover:border-primary-400'
          }`}
      >
        <input {...getInputProps()} />
        <div className="space-y-2">
          {currentFile && sheetOptions.length === 0 ? (
            <div>
              <svg 
                className="mx-auto h-12 w-12 text-green-500"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth={2} 
                  d="M5 13l4 4L19 7" 
                />
              </svg>
              <div className="mt-2">
                <p className="text-sm font-medium text-secondary-900">{currentFile.name}</p>
                <p className="text-xs text-secondary-500">
                  {(currentFile.size / 1024 / 1024).toFixed(2)} MB
                </p>
                <p className="text-xs text-primary-500 mt-2">
                  Click or drop to replace file
                </p>
              </div>
            </div>
          ) : (
            <>
              <svg 
                className="mx-auto h-12 w-12 text-secondary-400"
                stroke="currentColor"
                fill="none"
                viewBox="0 0 48 48"
                aria-hidden="true"
              >
                <path
                  d="M24 8v24m12-12H12"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
              <div className="text-secondary-600">
                {isDragActive ? (
                  <p>Drop the file here...</p>
                ) : (
                  <p>
                    Drag and drop a file here, or{' '}
                    <span className="text-primary-500">browse</span>
                  </p>
                )}
              </div>
              <p className="text-sm text-secondary-500">
                Supported formats: CSV, Excel (.xlsx, .xls)
              </p>
            </>
          )}
        </div>
      </div>

      {/* Sheet selector only shown when multiple sheets are detected */}
      {sheetOptions.length > 1 && (
        <div className="mt-4 p-4 border border-secondary-200 rounded-lg bg-secondary-50">
          <h4 className="text-sm font-medium text-secondary-900 mb-2">
            This Excel file contains multiple sheets. Please select one to process:
          </h4>
          <div className="flex space-x-4">
            <select
              value={selectedSheet}
              onChange={(e) => setSelectedSheet(e.target.value)}
              className="w-full px-4 py-2.5 bg-white border border-secondary-200 rounded-card text-secondary-900 shadow-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
            >
              {sheetOptions.map((sheet) => (
                <option key={sheet} value={sheet}>
                  {sheet}
                </option>
              ))}
            </select>
            <button
              onClick={handleSheetSelect}
              className="px-4 py-2 rounded-card text-white font-medium bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
            >
              Use This Sheet
            </button>
          </div>
        </div>
      )}
    </>
  );
};

// Utility functions
const isValidFileType = (file: File): boolean => {
  const validTypes = [
    'text/csv',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-excel'
  ];
  
  // Also check file extension for cases where MIME type isn't reliable
  const fileExtension = file.name.split('.').pop()?.toLowerCase() ?? '';
  const validExtensions = ['csv', 'xlsx', 'xls'];
  
  return validTypes.includes(file.type) || 
    validExtensions.includes(fileExtension);
};

export default FileUpload;

File: src/components/BatchTab/index.ts
// Export all components
export { default as FileUpload } from './FileUpload';
export { default as ColumnSelector } from './ColumnSelector';
export { default as PreviewTable } from './PreviewTable';
export { default as BatchProgress } from './BatchProgress';
export { default as BatchTab } from './BatchTab';
export { default as BatchSummary } from './BatchSummary';

// Export types
export interface BatchTabProps {
  apiClient: any; // Replace with proper API client type
}

export interface ColumnConfig {
  sourceColumn: string;
  contextColumn?: string;
}

export interface PreviewData {
  headers: string[];
  rows: string[][];
  fileName: string;
  fileType: 'csv' | 'excel';
}

export interface SystemConfig {
  system: {
    code: string;
    name: string;
    description?: string;
  };
  levels: Array<{
    code: string;
    name: string;
  }>;
}

File: src/components/BatchTab/PreviewTable.tsx
import React from 'react';
import { PreviewData, ColumnConfig } from './types';
import { BatchItemResult, ClassificationError } from '../../api/types';

interface PreviewTableProps {
  data: PreviewData;
  columnConfig: ColumnConfig | null;
  batchResults?: BatchItemResult[];
  isProcessing?: boolean;
}

const PreviewTable: React.FC<PreviewTableProps> = ({ data, columnConfig, batchResults, isProcessing }) => {
  const { headers, rows } = data;
  const previewRows = rows.slice(0, 5); // Show only first 5 rows

  // Generate keys for preview display
  const getGeneratedKey = (row: string[]): string => {
    if (!columnConfig || !columnConfig.keyColumns || columnConfig.keyColumns.length === 0) {
      return '';
    }
    
    const keyParts = columnConfig.keyColumns.map(keyCol => {
      const keyIndex = headers.indexOf(keyCol);
      return keyIndex >= 0 ? row[keyIndex] : '';
    }).filter(Boolean); // Remove empty values
    
    return keyParts.join('|'); // Join with pipe delimiter for multiple key parts
  };

  // Helper function to get error message from either string or ClassificationError
  const getErrorMessage = (error: string | ClassificationError | undefined): string => {
    if (!error) return '';
    if (typeof error === 'string') return error;
    return error.message || 'Unknown error';
  };

  const isHighlightedColumn = (header: string): boolean => {
    if (!columnConfig) return false;
    return (
      header === columnConfig.sourceColumn ||
      header === columnConfig.contextColumn ||
      columnConfig.keyColumns?.includes(header) || // Include key columns in highlighting
      columnConfig.resultColumns?.some(col =>
        col.codeColumn === header || col.nameColumn === header
      )
    );
  };

  const getColumnType = (header: string): string | null => {
    if (!columnConfig) return null;
    if (header === columnConfig.sourceColumn) return 'Source';
    if (header === columnConfig.contextColumn) return 'Context';
    if (columnConfig.keyColumns?.includes(header)) return 'Key'; // Identify key columns
    
    const resultCol = columnConfig.resultColumns?.find(
      col => col.codeColumn === header || col.nameColumn === header
    );
    if (resultCol) {
      return header === resultCol.codeColumn
        ? `${resultCol.levelName} Code`
        : `${resultCol.levelName} Name`;
    }
    
    return null;
  };

  const getCellClassName = (header: string): string => {
    const baseClass = 'px-4 py-2 whitespace-nowrap text-sm';
    
    if (!columnConfig) return `${baseClass} text-secondary-500`;
    
    // Special styling for key columns
    if (columnConfig.keyColumns?.includes(header)) {
      return `${baseClass} bg-amber-50 text-secondary-900 font-medium`;
    }
    
    if (isHighlightedColumn(header)) {
      return `${baseClass} bg-primary-50 text-secondary-900`;
    }
    
    return `${baseClass} text-secondary-500`;
  };

  const getHeaderClassName = (header: string): string => {
    const baseClass = 'px-4 py-2 text-left text-xs font-medium tracking-wider';
    
    if (!columnConfig) return `${baseClass} bg-secondary-50 text-secondary-500`;
    
    // Special styling for key columns
    if (columnConfig.keyColumns?.includes(header)) {
      return `${baseClass} bg-amber-50 text-amber-700`;
    }
    
    if (isHighlightedColumn(header)) {
      return `${baseClass} bg-primary-50 text-primary-700`;
    }
    
    return `${baseClass} bg-secondary-50 text-secondary-500`;
  };

  const getProcessingStatus = (index: number) => {
    if (!batchResults) return null;
    
    const result = batchResults[index];
    if (!result) return (
      isProcessing && (
      <div className="flex items-center space-x-2 text-secondary-600">
        <svg className="animate-pulse h-4 w-4" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none"/>
        </svg>
        <span className="ml-2">Waiting...</span>
      </div>
      )
    );

    // Check if the result is actually successful (has valid levels)
    const isSuccess = result.result?.levels && 
      Object.values(result.result.levels).some(level => level.code && level.name);

    // If it has a result but no valid levels, it's a failure
    if (result.result && !isSuccess) return (
      <div className="flex items-center space-x-2 text-red-600">
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <span className="ml-2">Error: Invalid classification</span>
      </div>
    );

    if (result.error) return (
      <div className="flex items-center space-x-2 text-red-600">
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <div className="flex flex-col">
          <span className="ml-2">Error</span>
          {result.error && (
            <span 
              className="ml-2 text-xs text-red-500 max-w-sm truncate" 
              title={getErrorMessage(result.error)}
            >
              {getErrorMessage(result.error)}
            </span>
          )}
        </div>
      </div>
    );

    if (isSuccess) return (
      <div className="flex items-center space-x-2 text-green-600">
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
        </svg>
        <span className="ml-2">Completed</span>
      </div>
    );

    return (
      isProcessing && (
      <div className="flex items-center space-x-2 text-primary-600">
        <svg className="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span className="ml-2">Processing...</span>
      </div>
      )
    );
  };

  return (
    <div className="overflow-x-auto rounded-lg border border-secondary-200">
      <table className="min-w-full divide-y divide-secondary-200">
        <thead>
          <tr>
            {/* Processing Status column */}
            <th className="w-48 px-4 py-2 bg-secondary-50 text-left text-xs font-medium text-secondary-500 tracking-wider">Status</th>
            
            {/* Generated Key column - only show if key columns are selected */}
            {columnConfig?.keyColumns && columnConfig.keyColumns.length > 0 && (
              <th className="w-64 px-4 py-2 bg-amber-50 text-left text-xs font-medium text-amber-700 tracking-wider">
                <div className="flex flex-col">
                  <span>Generated Key</span>
                  <span className="mt-1 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-amber-100 text-amber-800">
                    Composite Key
                  </span>
                </div>
              </th>
            )}
            
            {headers.map((header: string, index: number) => (
              <th
                key={index}
                className={getHeaderClassName(header)}
              >
                <div className="flex flex-col">
                  <span>{header}</span>
                  {isHighlightedColumn(header) && (
                    <span className="mt-1 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-primary-100 text-primary-800">
                      {getColumnType(header)}
                    </span>
                  )}
                </div>
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-secondary-200">
          {previewRows.map((row: string[], rowIndex: number) => (
            <tr key={rowIndex}>
              {/* Status cell */}
              <td className="w-48 px-4 py-2 whitespace-nowrap border-r border-secondary-200">
                {getProcessingStatus(rowIndex)}
              </td>
              
              {/* Generated Key cell - only show if key columns are selected */}
              {columnConfig?.keyColumns && columnConfig.keyColumns.length > 0 && (
                <td className="w-64 px-4 py-2 whitespace-nowrap border-r border-secondary-200 bg-amber-50 font-medium">
                  {getGeneratedKey(row)}
                </td>
              )}
              
              {row.map((cell: string, cellIndex: number) => (
                <td
                  key={cellIndex}
                  className={getCellClassName(headers[cellIndex])}
                >
                  {cell}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>

      {previewRows.length === 0 ? (
        <div className="text-center py-4 text-secondary-500">
          No preview data available
        </div>
      ) : (
        <div className="bg-secondary-50 px-4 py-2 text-sm text-secondary-500">
          Showing first {previewRows.length} of {rows.length} rows
        </div>
      )}
    </div>
  );
};

export default PreviewTable;

File: src/components/BatchTab/types.ts
// Types for BatchTab functionality

import { ClassificationSystem, BatchStatus as ApiBatchStatus } from "../../api/types";

export interface PreviewData {
    headers: string[];
    rows: string[][];
    fileName: string;
    fileType: 'csv' | 'excel';
}

export interface ResultColumn {
    levelCode: string;
    levelName: string;
    codeColumn: string;
    nameColumn: string;
    isNewColumn: boolean;
}

export interface ColumnConfig {
    // Original properties
    descriptionColumnIndex: number;
    contextColumnIndex?: number;
    keyColumnIndex?: number;
    multiKeyIndices?: number[];
    
    // New properties being used in components
    sourceColumn: string;
    contextColumn?: string;
    keyColumns: string[];
    resultColumns: ResultColumn[];
}

export interface BatchTabProps {
    availableSystems: { system: ClassificationSystem }[];
    apiClient: any; // TODO: Replace with proper API client type
}

// Specialized types for key handling
export interface MultiKey {
    original: string;
    normalized: string;
    parts: string[];
}

// Key processing utilities
export const normalizeDecimalKey = (key: string): string => {
    // Simply return the key as is - we're no longer normalizing decimal suffixes
    return key;
};

export const splitMultiKey = (key: string): string[] => {
    if (!key) return [];
    return key.split('|');
};

export const processMultiKey = (key: string): MultiKey => {
    if (!key) return { original: '', normalized: '', parts: [] };
    
    const normalized = normalizeDecimalKey(key);
    const parts = splitMultiKey(normalized);
    
    return {
        original: key,
        normalized,
        parts
    };
}

// Define and export the filter type
export type BatchJobStatusFilterType = ApiBatchStatus | 'all' | 'partial';

export interface SystemConfig {
    system: ClassificationSystem;
    levels: Array<{
        code: string;
        name: string;
        description?: string;
    }>;
}

export interface BatchJobStatus {
    batchId: string | null;
    isProcessing: boolean;
}

File: src/components/BatchJobsTab/BatchJobsTab.tsx
// src/components/BatchJobsTab/BatchJobsTab.tsx
import React, { useState, useCallback, useRef, useEffect } from 'react';
import type { JSX } from 'react';
import { Spin } from 'antd';
import { ApiClient, BatchClassificationResult } from '../../api/types';
import { ExecutionStatusFilterType, ResultStatusFilterType, getExecutionStatus, calculateResultStatus } from './utils/batchJobUtils';
import BatchJobDetailsModal from './BatchJobDetailsModal';
import { BatchJobsFilters } from './components/BatchJobsFilters';
import { BatchJobsTable } from './components/BatchJobsTable';

interface BatchJobsTabProps {
  apiClient: ApiClient;
}

export const BatchJobsTab = ({ apiClient }: BatchJobsTabProps): JSX.Element => {
  const mountedRef = useRef(true);
  const [jobs, setJobs] = useState<BatchClassificationResult[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [cursor, setCursor] = useState<string | undefined>(undefined);
  const [currentPage, setCurrentPage] = useState(1);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | undefined>(undefined);
  const [selectedJob, setSelectedJob] = useState<BatchClassificationResult | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [pageSize] = useState(10);
  const [totalPages, setTotalPages] = useState(1);

  const [selectedExecutionStatus, setSelectedExecutionStatus] = useState<ExecutionStatusFilterType>('all');
  const [selectedResultStatus, setSelectedResultStatus] = useState<ResultStatusFilterType>('all');
  const [startDate, setStartDate] = useState<string>(() => {
    const d = new Date();
    d.setDate(d.getDate() - 7);
    return d.toISOString().split('T')[0];
  });
  const [endDate, setEndDate] = useState<string>(() => new Date().toISOString().split('T')[0]);

  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const requestIdRef = useRef(0);
  const isInitialMount = useRef(true);
  const loadingRef = useRef(loading);

  // Safe state updates
  const safeSetJobs = useCallback((data: BatchClassificationResult[]) => {
    if (mountedRef.current) setJobs(data);
  }, []);
  const safeSetTotalCount = useCallback((count: number) => {
    if (mountedRef.current) setTotalCount(count);
  }, []);
  const safeSetCursor = useCallback((newCursor: string | undefined) => {
    if (mountedRef.current) setCursor(newCursor);
  }, []);
  const safeSetLoading = useCallback((isLoading: boolean) => {
    if (mountedRef.current) {
      setLoading(isLoading);
      loadingRef.current = isLoading;
    }
  }, []);
  const safeSetError = useCallback((err: string | undefined) => {
    if (mountedRef.current) setError(err);
  }, []);

  // Component lifecycle
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
      requestIdRef.current++;
    };
  }, []);

  // Load jobs data
  const loadJobs = useCallback(async (pageToLoad: number, cursorToUse: string | undefined) => {
    const currentRequestId = ++requestIdRef.current;
    if (!loadingRef.current) {
      safeSetLoading(true);
    }
    safeSetError(undefined);

    try {
      const formattedStartDate = startDate ? new Date(startDate).toISOString() : undefined;
      const formattedEndDate = endDate ? new Date(endDate + 'T23:59:59.999Z').toISOString() : undefined;

      const result = await apiClient.getBatchJobs({
        cursor: cursorToUse,
        limit: pageSize,
        status: selectedExecutionStatus === 'all' ? undefined : selectedExecutionStatus,
        startDate: formattedStartDate,
        endDate: formattedEndDate,
      });

      // Debug the raw response from the backend
      console.log('Batch jobs API response:', result);
      console.log('First job totalItems value:', result.items?.[0]?.totalItems);

      if (!mountedRef.current || currentRequestId !== requestIdRef.current) {
        return;
      }

      const resultItems = result.items || [];
      // Apply client-side filtering for result status
      const filteredItems = selectedResultStatus !== 'all'
        ? resultItems.filter(job => {
            if (getExecutionStatus(job) === 'pending' || getExecutionStatus(job) === 'processing') {
              return false;
            }
            return calculateResultStatus(job) === selectedResultStatus;
          })
        : resultItems;

      safeSetJobs(filteredItems);
      safeSetTotalCount(result.totalCount || 0);
      safeSetCursor(result.nextCursor);
      const newTotalPages = Math.ceil((result.totalCount || 0) / pageSize);
      setTotalPages(newTotalPages > 0 ? newTotalPages : 1);
      safeSetLoading(false);

    } catch (err) {
      if (mountedRef.current && currentRequestId === requestIdRef.current) {
        safeSetError('Failed to load batch jobs: ' + (err instanceof Error ? err.message : 'Unknown error'));
        safeSetJobs([]);
        safeSetTotalCount(0);
        safeSetCursor(undefined);
        setTotalPages(1);
        safeSetLoading(false);
      }
    }
  }, [apiClient, startDate, endDate, selectedExecutionStatus, selectedResultStatus, pageSize, safeSetLoading, safeSetError, safeSetJobs, safeSetTotalCount, safeSetCursor]);

  // Reset page when filters change
  useEffect(() => {
    if (!isInitialMount.current) {
      setCurrentPage(1);
      setCursor(undefined);
    }
  }, [selectedExecutionStatus, selectedResultStatus, startDate, endDate]);

  // Load data when page changes
  useEffect(() => {
    loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
    if (isInitialMount.current) {
      isInitialMount.current = false;
    }
  }, [currentPage, cursor, loadJobs]);

  // Polling for active jobs
  const refreshJobs = useCallback(async () => {
    await loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
  }, [loadJobs, currentPage, cursor]);

  useEffect(() => {
    const hasActiveJobs = jobs.some(job => 
      getExecutionStatus(job) === 'processing' || getExecutionStatus(job) === 'pending'
    );

    if (hasActiveJobs && !loadingRef.current && !pollIntervalRef.current) {
      pollIntervalRef.current = setInterval(refreshJobs, 5000);
    } else if (!hasActiveJobs && pollIntervalRef.current) {
      clearInterval(pollIntervalRef.current);
      pollIntervalRef.current = null;
    }

    return () => {
      if (pollIntervalRef.current) {
        clearInterval(pollIntervalRef.current);
        pollIntervalRef.current = null;
      }
    };
  }, [jobs, refreshJobs]);

  // Pagination handler
  const handlePageChange = useCallback((newPage: number) => {
    if (loadingRef.current || newPage < 1 || newPage > totalPages || newPage === currentPage) return;
    setCurrentPage(newPage);
  }, [currentPage, totalPages]);

  return (
    <div className="max-w-8xl mx-auto space-y-6" style={{ minWidth: '40rem', paddingRight: '1rem', paddingLeft: '1rem' }}>
      {/* Filters */}
      <div className="bg-white shadow-card rounded-card p-6 w-full">
        <BatchJobsFilters
          selectedExecutionStatus={selectedExecutionStatus}
          selectedResultStatus={selectedResultStatus}
          startDate={startDate}
          endDate={endDate}
          onExecutionStatusChange={setSelectedExecutionStatus}
          onResultStatusChange={setSelectedResultStatus}
          onStartDateChange={setStartDate}
          onEndDateChange={setEndDate}
          loading={loadingRef.current}
        />
      </div>

      {/* Main Content */}
      <div className="bg-white shadow-card rounded-card p-6 w-full">
        {error && (
          <div className="rounded-card border border-red-200 bg-red-50/50 px-4 py-3 mb-4" role="alert">
            <p className="text-sm text-red-700">{error}</p>
          </div>
        )}

        {loadingRef.current && jobs.length === 0 && (
          <div className="text-center py-8">
            <div className="flex justify-center">
              <Spin size="large" />
              <span className="ml-3">Loading jobs...</span>
            </div>
          </div>
        )}

        {!loadingRef.current && jobs.length === 0 && !error && (
          <div className="text-center py-8 text-sm text-secondary-500">
            No batch jobs found.
          </div>
        )}

        {jobs.length > 0 && (
          <>
            <BatchJobsTable
              jobs={jobs}
              onViewDetails={(job) => {
                setSelectedJob(job);
                setIsModalOpen(true);
              }}
            />

            {/* Always show pagination when we have jobs */}
            {jobs.length > 0 && (
              <div className="mt-6 flex items-center justify-between">
                <div className="flex-1 flex justify-between items-center">
                  <p className="text-sm text-secondary-600">
                    Showing {Math.min((currentPage - 1) * pageSize + 1, totalCount || jobs.length)} - {Math.min(currentPage * pageSize, totalCount || jobs.length)} of {totalCount || jobs.length} results
                  </p>
                  
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => handlePageChange(1)}
                      disabled={currentPage === 1 || loading}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      First
                    </button>
                    
                    <button
                      onClick={() => handlePageChange(currentPage - 1)}
                      disabled={currentPage === 1 || loading}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Previous
                    </button>

                    {(() => {
                      const pages = [];
                      const maxButtons = 5;
                      let start = Math.max(1, currentPage - Math.floor(maxButtons / 2));
                      let end = Math.min(start + maxButtons - 1, totalPages);

                      // Adjust start if we're at the end
                      if (end === totalPages) {
                        start = Math.max(1, end - maxButtons + 1);
                      }

                      // Show dots at start if needed
                      if (start > 1) {
                        pages.push(
                          <span key="start-dots" className="px-2 py-2 text-secondary-500">...</span>
                        );
                      }

                      // Page numbers
                      for (let i = start; i <= end; i++) {
                        pages.push(
                          <button
                            key={i}
                            onClick={() => handlePageChange(i)}
                            disabled={loading || (i > currentPage && !cursor)}
                            className={`px-3 py-2 rounded-lg border text-sm font-medium ${
                              i === currentPage
                                ? 'bg-primary-600 text-white border-primary-600'
                                : 'border-secondary-200 text-secondary-700 hover:bg-secondary-50'
                            }`}
                          >
                            {i}
                          </button>
                        );
                      }

                      // Show dots at end if needed
                      if (end < totalPages) {
                        pages.push(
                          <span key="end-dots" className="px-2 py-2 text-secondary-500">...</span>
                        );
                      }

                      return pages;
                    })()}

                    <button
                      onClick={() => handlePageChange(currentPage + 1)}
                      disabled={currentPage === totalPages || loading || !cursor}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Next
                    </button>
                    
                    <button
                      onClick={() => handlePageChange(totalPages)}
                      disabled={currentPage === totalPages || loading}
                      className="px-3 py-2 rounded-lg border border-secondary-200 text-sm font-medium text-secondary-700 hover:bg-secondary-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Last
                    </button>
                  </div>
                </div>
              </div>
            )}
          </>
        )}

        {/* Job Details Modal */}
        <BatchJobDetailsModal
          job={selectedJob}
          open={isModalOpen}
          onClose={() => {
            setSelectedJob(null);
            setIsModalOpen(false);
          }}
        />
      </div>
    </div>
  );
};

export default BatchJobsTab;

File: src/components/README.md
# System Configuration Components

This directory contains components for displaying system configuration in a user-friendly way.

## Components

### ConfigValue

A reusable component for rendering different types of configuration values. Features:
- Masks sensitive data (password, apiKey, etc.)
- Formats boolean values with color-coded styling
- Handles complex objects and arrays with summary views
- Supports custom styling via className prop

```tsx
<ConfigValue configKey="apiKey" value="secret" />        // Renders: ********
<ConfigValue configKey="enabled" value={true} />         // Renders: True (with green styling)
<ConfigValue configKey="items" value={[1, 2, 3]} />     // Renders: Array[3]
```

### Settings

Main configuration display component that shows system settings in an organized, collapsible format:
- Groups RAG-related settings separately
- Supports nested configuration objects
- Provides expandable/collapsible sections
- Uses ConfigValue for consistent value rendering

## Testing

Tests are written using React Testing Library and cover:
- Value rendering for different data types
- Sensitive data masking
- Boolean value styling
- Complex object handling
- Custom styling support

## Development

To modify these components:

1. Ensure all tests pass:
```bash
npm test
```

2. Use ConfigValue for any new configuration value rendering
3. Update tests when adding new functionality
4. Document any new features or changes

## Dependencies

- React Testing Library
- Jest DOM utilities
- TypeScript type definitions

File: src/components/BatchJobsTab/index.ts
// src/components/BatchJobsTab/index.ts
export { default as BatchJobsTab } from './BatchJobsTab';

File: src/components/BatchJobsTab/BatchJobDetailsModal.tsx
// src/components/BatchJobsTab/BatchJobDetailsModal.tsx
import React, { useMemo, useCallback, useRef, useEffect, memo, JSX } from 'react';
import { Modal, Typography } from 'antd';
// Import necessary types from your API types file
import { BatchClassificationResult, BatchItemResult, CategoryLevel } from '../../api/types'; // Ensure CategoryLevel is imported if used
import { 
    getExecutionStatus, 
    calculateResultStatus, 
    getFormattedErrorMessage,
    isSuccessfulItem,
    isFailedItem,
    isPartialItem,
    isProcessedItem
} from './utils/batchJobUtils'; // Import all utility functions
import { ExecutionStatusBadge, ResultStatusBadge } from './components/JobStatusDisplay'; 
import './BatchJobDetailsModal.css'; // Assuming this exists

// Define Props Interface
interface BatchJobDetailsModalProps {
  job: BatchClassificationResult | null;
  open: boolean;
  onClose: () => void;
}

// Keyboard keys constant
const KEYS = {
  ESCAPE: 'Escape',
  TAB: 'Tab'
} as const;

const formatDuration = (ms: number): string => {
  if (isNaN(ms)) return 'N/A'; // Handle potential NaN
  const seconds = Math.floor(Math.abs(ms) / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) return `${hours}h ${minutes % 60}m`;
  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
  if (seconds >= 0) return `${seconds}s`; // Ensure non-negative seconds are shown
  return '0s'; // Default if calculation is odd
};

const formatDateTime = (dateInput: string | Date | undefined | null): string => {
    if (!dateInput) return 'N/A';
    try {
        const date = typeof dateInput === 'string' ? new Date(dateInput) : dateInput;
        if (isNaN(date.getTime())) { // Check if date is valid
           console.warn("Attempted to format invalid date:", dateInput);
           return 'Invalid Date';
        }
        return date.toLocaleString(undefined, {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    } catch (e) {
        console.error("Error formatting date:", dateInput, e);
        return 'Error';
    }
};


// Component Definition
const BatchJobDetailsModalComponent = ({ job, open, onClose }: BatchJobDetailsModalProps): JSX.Element | null => {
  // Early return if no job or modal not open
  if (!job || !open) return null;

  // Refs for focus management
  const modalRef = useRef<HTMLDivElement>(null);
  const lastFocusedElementRef = useRef<HTMLElement | null>(null);

  // Compute timing information safely
  const timingInfo = useMemo(() => {
        if (!job?.timestamp) {
            return { startTime: 'N/A', endTime: 'N/A', duration: 'N/A' };
        }

        const startTime = new Date(job.timestamp);
        const endTime = job.updated_at ? new Date(job.updated_at) : new Date(); // Use updated_at if available, otherwise fallback to current time.

        const duration = endTime.getTime() - startTime.getTime();

        // Format results
        const formattedStartTime = formatDateTime(startTime);
        const formattedEndTime = formatDateTime(endTime);
        const formattedDuration = formatDuration(duration);

        return {
            startTime: formattedStartTime,
            endTime: formattedEndTime,
            duration: formattedDuration,
        };
    }, [job]);

  // Effect for focus trapping when modal opens/closes
  useEffect(() => {
    let timer: NodeJS.Timeout;
    if (open) {
      lastFocusedElementRef.current = document.activeElement as HTMLElement;
      // Use timeout to ensure modal is fully rendered before focusing
      timer = setTimeout(() => {
          // Check if modalRef.current exists before focusing
          const modalContent = modalRef.current?.querySelector('.ant-modal-content');
          if (modalContent instanceof HTMLElement) {
              modalContent.focus();
          } else {
              modalRef.current?.focus(); // Fallback to modal wrapper
          }
      }, 100);

    } else if (lastFocusedElementRef.current) {
      // Ensure the element still exists and is focusable before focusing
      if (document.body.contains(lastFocusedElementRef.current) && typeof lastFocusedElementRef.current.focus === 'function') {
          lastFocusedElementRef.current.focus();
      }
      lastFocusedElementRef.current = null; // Clear ref after restoring focus or if it's no longer valid
    }
    // Cleanup timer on unmount or when 'open' changes
    return () => clearTimeout(timer);
  }, [open]);

  // Effect for handling keydown events (Escape, Tab)
  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLDivElement>) => { // Add type to event
    switch (e.key) {
      case KEYS.ESCAPE:
        onClose(); // Call the passed onClose function
        break;
      case KEYS.TAB:
        // Focus trapping logic
        if (modalRef.current) {
            // Query within the modalRef element
            const focusableElements = modalRef.current.querySelectorAll<HTMLElement>(
              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements.length > 0) {
              const firstElement = focusableElements[0];
              const lastElement = focusableElements[focusableElements.length - 1];
              const currentActive = document.activeElement as HTMLElement; // Get currently focused element

              if (e.shiftKey) { // Shift + Tab
                if (currentActive === firstElement || !modalRef.current.contains(currentActive)) {
                    // If focus is on the first element or outside the modal, wrap to last
                    e.preventDefault();
                    lastElement.focus();
                }
              } else { // Tab
                 if (currentActive === lastElement || !modalRef.current.contains(currentActive)) {
                    // If focus is on the last element or outside the modal, wrap to first
                    e.preventDefault();
                    firstElement.focus();
                 }
              }
              // Allow normal tab behavior within the modal otherwise
            }
        }
        break;
    }
  }, [onClose]); // Dependency array is correct

  // --- Render Helper Functions ---
  const renderSummary = useCallback(() => {
    const resultsArray = job.results || [];    // Filter to show only processed items
    const processedResults = resultsArray.filter(isProcessedItem);

    // Use refined utils for counting on processed items only
    const successItems = processedResults.filter(isSuccessfulItem).length;
    const partialItems = processedResults.filter(isPartialItem).length;
    const failedItems = processedResults.filter(isFailedItem).length;

    return (
      <div className="mb-6 space-y-4">
        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <div className="rounded-md bg-green-50 p-4 text-center sm:text-left">
            <div className="text-sm font-medium text-green-700">Successful</div>
            <div className="mt-1 text-2xl font-semibold text-green-600">{successItems}</div>
          </div>
          {/* Partial Count */}
          <div className="rounded-md bg-yellow-50 p-4 text-center sm:text-left">
            <div className="text-sm font-medium text-yellow-700">Partial</div>
            <div className="mt-1 text-2xl font-semibold text-yellow-600">{partialItems}</div>
          </div>
          <div className="rounded-md bg-red-50 p-4 text-center sm:text-left">
            <div className="text-sm font-medium text-red-700">Failed</div>
            <div className="mt-1 text-2xl font-semibold text-red-600">{failedItems}</div>
          </div>
        </div>
      </div>
    );
  }, [job]);

  const renderJobInfo = useCallback(() => {
    const executionStatus = getExecutionStatus(job);
    const resultStatus = calculateResultStatus(job);

    return (
      <div className="space-y-4">
        <h3 className="text-lg font-semibold text-secondary-800">Job Information</h3>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Execution Status</div>
            <div className="flex items-center">
              <ExecutionStatusBadge status={executionStatus} />
            </div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Result Status</div>
            <div className="flex items-center">
              <ResultStatusBadge status={resultStatus} />
            </div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Created</div>
            <div className="text-sm text-secondary-700">{timingInfo.startTime}</div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Completed</div>
            <div className="text-sm text-secondary-700">{timingInfo.endTime}</div>
          </div>
          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Duration</div>
            <div className="text-sm text-secondary-700">{timingInfo.duration}</div>
          </div>          <div className="p-3 bg-secondary-50 rounded-md">
            <div className="text-xs text-secondary-500 mb-1">Batch Size</div>            <div className="text-sm text-secondary-700">
              {job.processedItems !== undefined ? job.processedItems : (job.results || []).filter(isProcessedItem).length} / {(job.results || []).length} items processed
            </div>
          </div>
        </div>
      </div>
    );
  }, [job, timingInfo]);
  const renderResultDetails = useCallback(() => {
    const resultsArray = job.results || [];
    
    // Filter to only show processed items
    const processedResults = resultsArray.filter(isProcessedItem);
    
    if (!resultsArray.length) {
      return <div className="text-center py-8"><p className="text-secondary-600">No results available for this job yet.</p></div>;
    }
    
    if (!processedResults.length) {
      return <div className="text-center py-8"><p className="text-secondary-600">No processed items available yet. Processing is in progress.</p></div>;
    }    return (
      <div className="overflow-x-auto border border-secondary-200 rounded-md">
        <table className="min-w-full divide-y divide-secondary-200">
          <thead className="bg-secondary-50 sticky top-0 z-10"> {/* Make header sticky */}
            <tr>
              <th className="px-4 py-2 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-2/5">Item Description & Context</th>
              <th className="px-4 py-2 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-auto">Status</th>
              <th className="px-4 py-2 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-3/5">Classification / Error</th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-secondary-200">
            {processedResults.map((resultItem: BatchItemResult, index: number) => {
              // Determine individual item status using refined utils
              let status: 'Success' | 'Partial' | 'Failed' = 'Failed'; // Default to Failed
              let statusClass = 'bg-red-100 text-red-800 border-red-200';
              
              if (isSuccessfulItem(resultItem)) {
                status = 'Success';
                statusClass = 'bg-green-100 text-green-800 border-green-200';
              } else if (isPartialItem(resultItem)) {
                status = 'Partial';
                statusClass = 'bg-yellow-100 text-yellow-800 border-yellow-200';
              }
              // isFailedItem is implicitly covered by the default

              return (
                <tr key={index} className="hover:bg-secondary-50 align-top">
                  <td className="px-4 py-2 text-sm text-secondary-900">
                    <div className="font-medium">{resultItem.description || `Item ${index + 1}`}</div>
                    {/* Show key value if present */}
                    {resultItem.key && <p className="text-xs text-amber-700 font-medium mt-1 break-words">Key: {resultItem.key}</p>}
                    {resultItem.additional_context && (<p className="text-xs text-secondary-500 mt-1 break-words">Context: {resultItem.additional_context}</p>)}
                  </td>
                  <td className="px-4 py-2 text-sm">
                    {/* Use determined status and class */}
                    <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium border ${statusClass}`}>
                      {status}
                    </span>
                  </td>
                  <td className="px-4 py-2 text-sm text-secondary-600">
                    {/* Display error OR classification */}
                    {isFailedItem(resultItem) ? (
                      <div className="text-red-600 whitespace-pre-wrap break-words">
                        {getFormattedErrorMessage(resultItem.error || resultItem.result?.error) || 'Classification failed'}
                      </div>
                    ) : resultItem.result ? (
                      <div className="text-sm space-y-1">
                        {Object.entries(resultItem.result.levels || {})
                          // Sort levels by logical order
                          .sort(([a], [b]) => {
                            const levelOrder: Record<string, number> = { 'segment': 1, 'family': 2, 'class': 3, 'commodity': 4, 'SUBCAT1': 1, 'SUBCAT2': 2 };
                            return (levelOrder[a] ?? 99) - (levelOrder[b] ?? 99);
                          })
                          .map(([levelCode, category]: [string, CategoryLevel | undefined]) => (
                            <div key={levelCode}>
                              <span className="font-medium text-secondary-700">{levelCode}:</span>{' '}
                              <span className="text-secondary-600">
                                {category ? `${category.code} - ${category.name}` : 'N/A'}
                                {/* Show level-specific error if present */}
                                {category?.error && (<span className="text-xs text-red-600 ml-2">({category.error})</span>)}
                              </span>
                            </div>
                          ))}
                        {/* Show partial status explanation if applicable */}
                        {status === 'Partial' && !getFormattedErrorMessage(resultItem.error || resultItem.result?.error) && (
                          <p className="text-xs text-yellow-700 mt-1 italic">Result is partial, check levels.</p>
                        )}
                        {/* Display RAG context if available */}
                        {resultItem.result?.ragContextUsed && (
                          <div className="mt-2 border-t border-secondary-200 pt-2">
                            <details className="text-xs">
                              <summary className="text-blue-600 cursor-pointer">RAG Context Used</summary>
                              <div className="mt-1 bg-blue-50 p-2 rounded text-secondary-700 whitespace-pre-wrap">
                                {resultItem.result.ragContext || 'No specific context text available.'}
                              </div>
                            </details>
                          </div>
                        )}
                      </div>
                    ) : (
                      <div className="text-secondary-500">No classification data.</div>
                    )}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    );
  }, [job]);

  // --- Main Render ---
  return (
      <Modal
        title={
          <div className="flex items-center justify-between pr-4">
              <Typography.Title level={4} style={{ margin: 0, flexGrow: 1 }}>
                Batch Job Details
              </Typography.Title>
              <span className="text-sm text-secondary-600 font-mono">
                  ID: {job.id}
              </span>
          </div>
        }
        open={open} // Use 'open' prop for visibility (AntD v5+)
        onCancel={onClose} // Use the correct prop from Ant Design
        keyboard={true}     // Allow closing with ESC
        maskClosable={true} // Allow closing by clicking mask
        footer={null}       // No default footer buttons
        width={1000}        // Set desired width
        // Use 'styles' prop for new AntD versions v5+
        styles={{
            body: {
                maxHeight: 'calc(85vh - 120px)', // Adjust height calculation
                overflowY: 'auto', // Ensure vertical scroll
                padding: '24px' // Add padding to body
            },
            // Ensure header doesn't contribute to scroll height unnecessarily
            header: {
                padding: '16px 24px', // Standard AntD padding
                borderBottom: '1px solid #f0f0f0' // Standard AntD border
            },
            content: {
                padding: 0 // Reset padding if body padding is set
            }
        }}
        destroyOnClose={true} // Optional: Reset internal state when modal closes
        className="batch-details-modal" // Custom class for styling
        // The Modal component itself handles focus trapping. Ref and keydown on wrapper are for custom actions if needed.
        // ref={modalRef} // Not strictly needed for AntD modal focus trapping
        // onKeyDown={handleKeyDown} // Can attach here if Modal supports it, or use wrapper below
      >
          {/* Content Wrapper with Keydown Handler */}
          <div onKeyDown={handleKeyDown} tabIndex={-1} className="focus:outline-none">
             <div className="space-y-6">
                {renderSummary()}
                <div className="border-t border-secondary-200 pt-4">
                    {renderJobInfo()}
                </div>
                 <div className="border-t border-secondary-200 pt-4">                <div className="flex justify-between items-center mb-3">
                    <h3 className="text-lg font-semibold text-secondary-800">Results Breakdown</h3>                    <span className="text-sm text-secondary-500">
                        {`${job.processedItems !== undefined ? job.processedItems : (job.results || []).filter(isProcessedItem).length} of ${(job.results || []).length} items processed`}
                    </span>
                </div>
                    {renderResultDetails()}
                 </div>
             </div>
          </div>
      </Modal>
  );
};

export default memo(BatchJobDetailsModalComponent);

File: src/components/BatchJobsTab/hooks/useBatchJobs.ts
// src/components/BatchJobsTab/hooks/useBatchJobs.ts
import { useState, useEffect, useRef, useCallback } from 'react';
import { ApiClient, BatchClassificationResult, BatchJobParams } from '../../../api/types'; // Adjust import
import { BatchJobStatusFilterType } from '../../BatchTab/types'; // Adjust import if type moved

export interface UseBatchJobsResult {
    jobs: BatchClassificationResult[];
    loading: boolean;
    error: string | undefined;
    totalCount: number;
    totalPages: number;
    currentPage: number;
    selectedStatus: BatchJobStatusFilterType;
    startDate: string;
    endDate: string;
    cursor: string | undefined;
    setSelectedStatus: React.Dispatch<React.SetStateAction<BatchJobStatusFilterType>>;
    setStartDate: React.Dispatch<React.SetStateAction<string>>;
    setEndDate: React.Dispatch<React.SetStateAction<string>>;
    setCurrentPage: React.Dispatch<React.SetStateAction<number>>;
    refreshJobs: () => Promise<void>;
}

const POLLING_INTERVAL = 5000;
const PAGE_SIZE = 10;

export function useBatchJobs(apiClient: ApiClient): UseBatchJobsResult {
    const mountedRef = useRef(true);
    const [jobs, setJobs] = useState<BatchClassificationResult[]>([]);
    const [totalCount, setTotalCount] = useState(0);
    const [cursor, setCursor] = useState<string | undefined>(undefined);
    const [currentPage, setCurrentPage] = useState(1);
    const [loading, setLoading] = useState(true); // Start loading true
    const [error, setError] = useState<string | undefined>(undefined);
    const [totalPages, setTotalPages] = useState(1);

    const [selectedStatus, setSelectedStatus] = useState<BatchJobStatusFilterType>('all');
    const [startDate, setStartDate] = useState<string>(() => { const d = new Date(); d.setDate(d.getDate() - 7); return d.toISOString().split('T')[0]; });
    const [endDate, setEndDate] = useState<string>(() => new Date().toISOString().split('T')[0]);

    const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
    const requestIdRef = useRef(0);
    const isInitialMount = useRef(true);
    const loadingRef = useRef(loading);

    // --- Use specific safe setters ---
    const safeSetJobs = useCallback((data: BatchClassificationResult[]) => { if (mountedRef.current) setJobs(data); }, []);
    const safeSetTotalCount = useCallback((count: number) => { if (mountedRef.current) setTotalCount(count); }, []);
    const safeSetCursor = useCallback((newCursor: string | undefined) => { if (mountedRef.current) setCursor(newCursor); }, []);
    const safeSetCurrentPage = useCallback((page: number | ((prevPage: number) => number)) => { if (mountedRef.current) setCurrentPage(page); }, []);
    const safeSetTotalPages = useCallback((pages: number) => { if (mountedRef.current) setTotalPages(pages); }, []);
    const safeSetLoading = useCallback((isLoading: boolean) => { if (mountedRef.current) { setLoading(isLoading); loadingRef.current = isLoading; } }, []);
    const safeSetError = useCallback((err: string | undefined) => { if (mountedRef.current) setError(err); }, []);
    // --- End specific safe setters ---

    // Lifecycle
    useEffect(() => {
        mountedRef.current = true;
        return () => { mountedRef.current = false; if (pollIntervalRef.current) clearInterval(pollIntervalRef.current); requestIdRef.current++; };
    }, []);

    // Core loading logic
    const loadJobs = useCallback(async (pageToLoad: number, cursorToUse: string | undefined) => {
        const currentRequestId = ++requestIdRef.current;
        console.log(`[useBatchJobs loadJobs ${currentRequestId}] Req Start. Page: ${pageToLoad}, Cursor: ${cursorToUse}`);
        if (!loadingRef.current) { safeSetLoading(true); }
        safeSetError(undefined); // Use specific safe setter
        try {
            const params: BatchJobParams = {
                cursor: cursorToUse, limit: PAGE_SIZE, status: selectedStatus === 'all' ? undefined : selectedStatus,
                startDate: startDate ? new Date(startDate).toISOString() : undefined,
                endDate: endDate ? new Date(endDate + 'T23:59:59.999Z').toISOString() : undefined,
            };
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] Calling API with params:`, params);
            const result = await apiClient.getBatchJobs(params);
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] API call successful.`);
            if (!mountedRef.current || currentRequestId !== requestIdRef.current) { console.log(`[useBatchJobs loadJobs ${currentRequestId}] Discarded.`); return; }
            if (!result) throw new Error('No response data');
            const items = result.items || [];
            const total = result.totalCount || 0;
            const nextCursor = result.nextCursor;
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] Processing result: Items=${items.length}, Total=${total}, NextCursor=${nextCursor}`);

            // Use specific safe setters
            safeSetJobs(items);
            safeSetTotalCount(total);
            safeSetCursor(nextCursor);
            const newTotalPages = Math.ceil(total / PAGE_SIZE);
            safeSetTotalPages(newTotalPages > 0 ? newTotalPages : 1); // Use specific safe setter

            safeSetLoading(false);
            console.log(`[useBatchJobs loadJobs ${currentRequestId}] State updated, loading=false.`);
        } catch (err) {
            console.error(`[useBatchJobs loadJobs ${currentRequestId}] Error:`, err);
            if (mountedRef.current && currentRequestId === requestIdRef.current) {
                // Use specific safe setters
                safeSetError('Failed to load: ' + (err instanceof Error ? err.message : 'Unknown error'));
                safeSetJobs([]);
                safeSetTotalCount(0);
                safeSetCursor(undefined);
                safeSetTotalPages(1); // Use specific safe setter
                safeSetLoading(false);
                console.log(`[useBatchJobs loadJobs ${currentRequestId}] Error state set, loading=false.`);
            } else { console.log(`[useBatchJobs loadJobs ${currentRequestId}] Error ignored.`); }
        }
     // Update dependencies to use specific safe setters
    }, [apiClient, startDate, endDate, selectedStatus, PAGE_SIZE, safeSetLoading, safeSetError, safeSetJobs, safeSetTotalCount, safeSetCursor, safeSetTotalPages]);

    // Effect to reset page when filters change
    useEffect(() => {
        if (!isInitialMount.current) {
            console.log('[useBatchJobs] Filters changed, resetting to page 1.');
            // Use specific safe setters
            safeSetCurrentPage(1);
            safeSetCursor(undefined);
        }
     // Update dependencies to use specific safe setters
    }, [selectedStatus, startDate, endDate, safeSetCurrentPage, safeSetCursor]);

    // Effect for loading data when page changes OR after filters force page reset
    useEffect(() => {
        console.log('[useBatchJobs] Load trigger effect running for page:', currentPage);
        loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
        if (isInitialMount.current) isInitialMount.current = false;
    }, [currentPage, cursor, loadJobs]); // Include loadJobs dependency

    // Refresh current page data
    const refreshJobs = useCallback(async () => {
        console.log('[useBatchJobs refreshJobs] Refreshing current page:', currentPage);
        await loadJobs(currentPage, currentPage === 1 ? undefined : cursor);
    }, [loadJobs, currentPage, cursor]);

    // Effect for polling active jobs
    useEffect(() => {
        const hasActiveJobs = jobs.some(job => job.status === 'processing' || job.status === 'pending');
        const setupPollingInterval = () => {
            if (!pollIntervalRef.current) {
                console.log('[useBatchJobs Polling] Starting interval.');
                pollIntervalRef.current = setInterval(() => {
                    if (!loadingRef.current) { console.log('[useBatchJobs Polling] Refreshing...'); refreshJobs(); }
                    else { console.log('[useBatchJobs Polling] Skipping refresh: loading.'); }
                }, POLLING_INTERVAL);
            }
        };
        const clearPollingInterval = () => {
            if (pollIntervalRef.current) { console.log('[useBatchJobs Polling] Clearing interval.'); clearInterval(pollIntervalRef.current); pollIntervalRef.current = null; }
        };
        if (hasActiveJobs && !loadingRef.current) setupPollingInterval(); else clearPollingInterval();
        return clearPollingInterval;
    }, [jobs, refreshJobs]);

    // Return hook state and *original* setters for filters/page
    return {
        jobs, loading, error, totalCount, totalPages, currentPage,
        selectedStatus, startDate, endDate, cursor,
        setSelectedStatus, // Expose original setter
        setStartDate,      // Expose original setter
        setEndDate,        // Expose original setter
        setCurrentPage,    // Expose original setter
        refreshJobs,
    };
}

File: src/components/BatchJobsTab/components/BatchJobsPagination.tsx
// src/components/BatchJobsTab/components/BatchJobsPagination.tsx
import React from 'react';

interface BatchJobsPaginationProps {
    currentPage: number;
    totalPages: number;
    totalCount: number;
    pageSize: number;
    loading: boolean;
    cursor?: string;
    onPageChange: (page: number) => void;
}

export const BatchJobsPagination: React.FC<BatchJobsPaginationProps> = ({
    currentPage, totalPages, totalCount, pageSize, loading, cursor, onPageChange
}) => {
    // Don't show pagination if only one page or no results
    if (totalCount <= pageSize && totalPages <= 1) {
        return null;
    }

    const firstItem = (currentPage - 1) * pageSize + 1;
    const lastItem = Math.min(currentPage * pageSize, totalCount);

    return (
        <div className="mt-6 flex items-center justify-between">
            {/* Results Count Text */}
            <p className="text-sm text-secondary-600">
                Showing <span className="font-medium">{firstItem}</span>-
                <span className="font-medium">{lastItem}</span> of{' '}
                <span className="font-medium">{totalCount}</span> results
            </p>
            {/* Pagination Buttons */}
            <div className="flex items-center gap-1">
                <button
                    onClick={() => onPageChange(1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >First</button>
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1 || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Previous</button>
                <span className="text-sm text-secondary-600 px-2">
                    Page {currentPage} of {totalPages}
                </span>
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages || loading || !cursor}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Next</button>
                <button
                    onClick={() => onPageChange(totalPages)}
                    disabled={currentPage === totalPages || loading}
                    className="btn btn-secondary px-2 py-1 text-xs" // Use global style
                >Last</button>
            </div>
        </div>
    );
};

File: src/components/BatchJobsTab/components/BatchJobsTable.tsx
// src/components/BatchJobsTab/components/BatchJobsTable.tsx
import React, { useState } from 'react';
import { BatchClassificationResult } from '../../../api/types';
import { JobStatusDisplay } from './JobStatusDisplay';
import { downloadJobReport, DownloadFormat } from '../utils/csvGenerator';

interface BatchJobsTableProps {
    jobs: BatchClassificationResult[];
    onViewDetails: (job: BatchClassificationResult) => void;
}

export const BatchJobsTable: React.FC<BatchJobsTableProps> = ({ jobs, onViewDetails }) => {
    // Track open dropdown state for each job
    const [openDropdown, setOpenDropdown] = useState<string | null>(null);

    // Handle download with specified format
    const handleDownload = (job: BatchClassificationResult, format: DownloadFormat) => {
        // No longer need to normalize keys - we want to preserve decimal suffixes
        downloadJobReport(job, format);
        setOpenDropdown(null); // Close dropdown after action
    };

    // Toggle dropdown visibility
    const toggleDropdown = (jobId: string) => {
        setOpenDropdown(openDropdown === jobId ? null : jobId);
    };

    return (
        <div className="overflow-x-auto rounded-card border border-secondary-200 mb-6">
            <table className="min-w-full divide-y divide-secondary-200">
                <thead className="bg-secondary-50">
                    <tr>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Job ID</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">System</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Exec. Status</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Result Status</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Created</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider w-52">Progress</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Summary</th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-secondary-500 uppercase tracking-wider">Actions</th>
                    </tr>
                </thead>
                <tbody className="bg-white divide-y divide-secondary-200">
                    {jobs.map((job) => (
                        <tr key={job.id} className="hover:bg-secondary-50">
                            {/* Job ID */}
                            <td className="px-4 py-4 whitespace-nowrap text-sm text-secondary-900 font-mono">{job.id}</td>
                            <td className="px-4 py-4 whitespace-nowrap text-sm text-secondary-900">
                                {(job.system_code) ? (
                                    <div className="flex flex-col">
                                        <span className="font-medium">{job.system_code}</span>
                                    </div>
                                ) : (
                                    <span className="text-secondary-400">N/A</span>
                                )}
                            </td>
                            {/* Execution Status, Result Status, Created, Progress, Summary (rendered by JobStatusDisplay) */}
                            <JobStatusDisplay job={job} />
                            {/* Actions */}
                            <td className="px-4 py-4 whitespace-nowrap text-sm">
                                <div className="flex space-x-2">
                                    <button
                                        onClick={() => onViewDetails(job)}
                                        className="btn btn-secondary py-1 px-2 text-xs" // Use global style
                                        aria-label={`View details for job ${job.id}`}
                                    > View </button>
                                    
                                    {/* Download Dropdown */}
                                    <div className="relative">
                                        <button
                                            onClick={() => toggleDropdown(job.id)}
                                            disabled={job.status === 'pending' || job.status === 'processing'}
                                            className="btn btn-secondary py-1 px-2 text-xs text-green-600 border-green-200 hover:bg-green-50 disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
                                            aria-label={`Download options for job ${job.id}`}
                                            aria-expanded={openDropdown === job.id}
                                            aria-haspopup="true"
                                        >
                                            Download
                                            <svg className="ml-1 -mr-1 h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                                <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a 1 1 0 010-1.414z" clipRule="evenodd" />
                                            </svg>
                                        </button>
                                        
                                        {/* Dropdown Menu - Increased width from w-48 to w-64 (33% wider) */}
                                        {openDropdown === job.id && (
                                            <div 
                                                className="origin-top-right absolute right-0 mt-2 w-64 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 divide-y divide-gray-100 focus:outline-none z-10"
                                                role="menu"
                                                aria-orientation="vertical"
                                                aria-labelledby="download-options-menu"
                                            >
                                                <div className="py-1" role="none">
                                                    <button
                                                        onClick={() => handleDownload(job, 'simple')}
                                                        className="text-gray-700 block w-full text-left px-4 py-2 text-sm hover:bg-gray-100"
                                                        role="menuitem"
                                                    >
                                                        Basic (without LLM responses)
                                                    </button>
                                                    <button
                                                        onClick={() => handleDownload(job, 'full')}
                                                        className="text-gray-700 block w-full text-left px-4 py-2 text-sm hover:bg-gray-100"
                                                        role="menuitem"
                                                    >
                                                        Complete (with LLM responses)
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

File: src/components/BatchJobsTab/components/BatchJobsFilters.tsx
// src/components/BatchJobsTab/components/BatchJobsFilters.tsx
import React from 'react';
import { ExecutionStatusFilterType, ResultStatusFilterType } from '../utils/batchJobUtils';

interface BatchJobsFiltersProps {
    selectedExecutionStatus: ExecutionStatusFilterType;
    selectedResultStatus: ResultStatusFilterType;
    startDate: string;
    endDate: string;
    onExecutionStatusChange: (status: ExecutionStatusFilterType) => void;
    onResultStatusChange: (status: ResultStatusFilterType) => void;
    onStartDateChange: (date: string) => void;
    onEndDateChange: (date: string) => void;
    loading: boolean;
}

export const BatchJobsFilters: React.FC<BatchJobsFiltersProps> = ({
    selectedExecutionStatus,
    selectedResultStatus,
    startDate,
    endDate,
    onExecutionStatusChange,
    onResultStatusChange,
    onStartDateChange,
    onEndDateChange,
    loading
}) => {
    return (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            {/* Execution Status Filter */}
            <div>
                <label htmlFor="execStatusFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    Exec. Status
                </label>
                <select
                    id="execStatusFilter"
                    className="input"
                    value={selectedExecutionStatus}
                    onChange={(e) => onExecutionStatusChange(e.target.value as ExecutionStatusFilterType)}
                    disabled={loading}
                >
                    <option value="all">All Execution</option>
                    <option value="pending">Pending</option>
                    <option value="processing">Processing</option>
                    <option value="completed">Completed</option>
                    <option value="error">Error</option>
                </select>
            </div>

            {/* Result Status Filter */}
            <div>
                <label htmlFor="resultStatusFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    Result Status
                </label>
                <select
                    id="resultStatusFilter"
                    className="input"
                    value={selectedResultStatus}
                    onChange={(e) => onResultStatusChange(e.target.value as ResultStatusFilterType)}
                    disabled={loading || selectedExecutionStatus === 'pending' || selectedExecutionStatus === 'processing'}
                >
                    <option value="all">All Results</option>
                    <option value="successful">Successful</option>
                    <option value="partial">Partial</option>
                    <option value="failed">Failed</option>
                </select>
            </div>

            {/* Start Date Filter */}
            <div>
                <label htmlFor="startDateFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    Start Date
                </label>
                <input
                    type="date"
                    id="startDateFilter"
                    className="input"
                    value={startDate}
                    onChange={(e) => onStartDateChange(e.target.value)}
                    max={endDate}
                    disabled={loading}
                />
            </div>

            {/* End Date Filter */}
            <div>
                <label htmlFor="endDateFilter" className="block text-sm font-medium text-secondary-700 mb-1">
                    End Date
                </label>
                <input
                    type="date"
                    id="endDateFilter"
                    className="input"
                    value={endDate}
                    onChange={(e) => onEndDateChange(e.target.value)}
                    min={startDate}
                    disabled={loading}
                />
            </div>
        </div>
    );
};

File: src/components/BatchJobsTab/utils/batchJobUtils.ts
// src/components/BatchJobsTab/utils/batchJobUtils.ts
import { BatchClassificationResult, BatchItemResult, CategoryLevel, ClassificationError } from '../../../api/types';

// Define types for execution and result statuses
export type ExecutionStatusType = 'pending' | 'processing' | 'completed' | 'error';
export type ResultStatusType = 'successful' | 'partial' | 'failed' | 'N/A';
export type ExecutionStatusFilterType = 'all' | ExecutionStatusType;
export type ResultStatusFilterType = 'all' | Exclude<ResultStatusType, 'N/A'>;

// Function to check if a single classification level is valid (has code and name)
const isValidLevel = (level: CategoryLevel | undefined | null): boolean => {
    // Check if level exists, is an object, and has non-empty code and name strings
    return !!level &&
           typeof level === 'object' &&
           typeof level.code === 'string' && level.code.length > 0 &&
           typeof level.name === 'string' && level.name.length > 0;
};

// Function to check if an item has been processed (has either a result or error)
export const isProcessedItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item) return false;
    return (!!item.result || !!item.error);
};

// Function to ensure a key preserves decimal format (if it exists in original form)
export const preserveDecimalInKey = (key: string | undefined | null): string => {
    if (!key) return '';
    
    // If the key already ends with '.0', return it as is
    if (key.endsWith('.0')) return key;
    
    // Check if the key might be a normalized version of a decimal key (missing the .0)
    // Multi-part keys are typically delimited by pipe (|) character
    if (key.includes('|')) {
        const parts = key.split('|');
        // If the last part is a number without decimal, add .0 to restore original format
        const lastPart = parts[parts.length - 1];
        if (/^\d+$/.test(lastPart)) {
            parts[parts.length - 1] = `${lastPart}.0`;
            return parts.join('|');
        }
    }
    return key;
};

// Function to check if a result item represents a fully successful classification
export const isSuccessfulItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item || !item.result || item.error) {
        return false; // Explicit error or no result means not successful
    }
    // Check the explicit status from the backend result if available
    if (item.result.status === 'failed' || item.result.status === 'partial') {
        return false;
    }
    // Check if it has levels and at least one level is valid
    // A successful item should ideally have *all* expected levels, but for robustness,
    // let's stick to the backend 'success' status or having at least one valid level if status is missing.
    if (item.result.status === 'success') {
        return true;
    }
    // Fallback: If status is missing, consider successful if it has levels and at least one is valid
    return !!item.result.levels && Object.values(item.result.levels).some(isValidLevel);
};

// Function to check if a result item represents a failed classification attempt
export const isFailedItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item) return false; // If item doesn't exist, don't count as failed from this perspective
    if (item.error) return true; // Explicit top-level error means failure
    if (item.result && item.result.status === 'failed') {
        return true; // Explicit 'failed' status from backend result
    }
    // If there's a result object, but it contains no valid levels at all, treat as failure
    if (item.result && (!item.result.levels || Object.values(item.result.levels).length === 0 || Object.values(item.result.levels).every(level => !isValidLevel(level)))) {
         // Consider logging this case: console.warn('Treating item as failed due to no valid levels:', item);
        return true;
    }
    return false; // Otherwise, it's not considered a failure (could be success or partial)
};

// Function to check if a result item is partial
export const isPartialItem = (item: BatchItemResult | undefined | null): boolean => {
    if (!item || item.error) return false; // Cannot be partial if errored or non-existent
    if (!item.result) return false; // Cannot be partial without a result object

    // Explicit 'partial' status from backend is the clearest indicator
    if (item.result.status === 'partial') {
        return true;
    }

    // Implicit partial: If status isn't explicitly 'success' or 'failed',
    // and it's not considered a full failure (has *some* valid level),
    // but also not considered fully successful (e.g., missing some levels or backend didn't mark as 'success')
    // This relies heavily on the backend providing the status correctly.
    // For now, let's primarily rely on the explicit status or the derivation below.

    // Derive partial status if not explicitly set: Not fully successful AND not fully failed
    return !isSuccessfulItem(item) && !isFailedItem(item);
};


/**
 * Determines the Execution Status based on the job's top-level status field
 */
export const getExecutionStatus = (job: BatchClassificationResult): ExecutionStatusType => {
    // Handle potential case difference from backend ('Results' vs 'results')
    const resultsArray = job.results || job.Results || [];
    // Trust the totalItems from the backend, only add nullish coalescing for TypeScript safety
    const totalItems = job.totalItems ?? 0;
    const processedCount = resultsArray.filter(r => r.result || r.error).length;

    // Prioritize job-level status if available and valid
    if (job.status && ['pending', 'processing', 'completed', 'error'].includes(job.status)) {
        // Trust the server's status - don't override it
        return job.status as ExecutionStatusType;
    }

    // Infer status if job.status is missing or invalid
    if (totalItems === 0) return 'completed'; // Or 'error' if empty is unexpected
    if (processedCount === 0) return 'pending';
    if (processedCount < totalItems) return 'processing';
    return 'completed'; // All items have some result/error entry
};

/**
 * Calculates the Result Status based on the content of the results array for a finished job
 * Returns 'N/A' if the job execution is not finished
 */
export const calculateResultStatus = (job: BatchClassificationResult): ResultStatusType => {
    const executionStatus = getExecutionStatus(job);

    // Only return N/A for pending jobs - allow processing jobs to show interim result status
    if (executionStatus === 'pending') {
        return 'N/A';
    }

    const resultsArray = job.results || job.Results || [];
    
    // Take totalItems from backend if present, otherwise use array length
    // Use type assertion to handle the case where the server returns 'total_items'
    const serverTotalItems = job.totalItems ?? (job as any).total_items;
    const totalItems = serverTotalItems ?? resultsArray.length;

    // Handle empty results case
    if (resultsArray.length === 0) {
        return executionStatus === 'error' ? 'failed' : 'N/A';
    }

    // Count different result types
    let successCount = 0;
    let partialCount = 0;
    let failedCount = 0;

    for (const item of resultsArray) {
        if (isSuccessfulItem(item)) {
            successCount++;
        } else if (isFailedItem(item)) {
            failedCount++;
        } else {
            partialCount++;
        }
    }
    
    console.log(`Job ${job.id} status counts: S=${successCount}, F=${failedCount}, P=${partialCount}, Total=${totalItems}`);

    // Determine overall status based on processed items
    if (successCount === totalItems) {
        return 'successful';
    } else if (failedCount === totalItems) {
        return 'failed';
    } else if (successCount > 0 || partialCount > 0) {
        // If there's any success or partial success, it's partial overall
        return 'partial';
    } else {
        // If we have results but couldn't categorize them, default to failed
        return 'failed';
    }
};

// Helper function to get error message
export const getFormattedErrorMessage = (error: string | ClassificationError | undefined): string => {
    if (!error) return '';
    if (typeof error === 'string') return error;
    if (typeof error === 'object' && error !== null) {
        // Check for common error message structures
        if ('message' in error && typeof error.message === 'string') {
            return error.message;
        }
        if ('error' in error && typeof error.error === 'string') {
             return error.error;
        }
        // Attempt to stringify if specific fields aren't found
        try { return JSON.stringify(error); } catch { /* ignore stringify error */ }
    }
    return 'Unknown error format';
};

File: src/components/BatchJobsTab/utils/csvGenerator.ts
// src/components/BatchJobsTab/utils/csvGenerator.ts
import { saveAs } from 'file-saver';
import { BatchClassificationResult, BatchItemResult, ClassificationError } from '../../../api/types';

// Helper function to escape CSV values
const escapeCsvValue = (value: any): string => {
  if (value === null || value === undefined) return '';
  const stringValue = String(value);
  // More comprehensive check for characters requiring quoting
  const needsQuoting = stringValue.includes(',') ||
                       stringValue.includes('"') ||
                       stringValue.includes('\n') ||
                       stringValue.includes('\r') ||
                       stringValue.includes(';') ||
                       stringValue.includes('\t');
  if (!needsQuoting) return stringValue;
  return `"${stringValue.replace(/"/g, '""')}"`;
};

export type DownloadFormat = 'simple' | 'full';

const splitMultiKey = (key: string = ''): string[] => {
    if (!key) return [''];
    return key.split('|').map(k => k.trim());
};

const getMaxKeyParts = (results: BatchItemResult[]): number => {
    let maxParts = 0;
    if (!results || results.length === 0) return 0;
    for (const item of results) {
        if (item.key) {
            const keyParts = splitMultiKey(item.key);
            maxParts = Math.max(maxParts, keyParts.length);
        }
    }
    return maxParts === 0 && results.some(r => r.key !== undefined && r.key !== null && r.key !== '') ? 1 : maxParts; // If keys exist but are single, still have 1 key column
};

const getKeyHeaders = (job: BatchClassificationResult): string[] => {
    const columnNames = job.keyColumnNames || (job as any).key_column_names;
    if (columnNames && Array.isArray(columnNames) && columnNames.length > 0) {
        return columnNames;
    }
    const resultsArray = job.results || [];
    const maxParts = getMaxKeyParts(resultsArray);
    if (maxParts === 0 && resultsArray.some(item => item.key !== undefined && item.key !== null && item.key !== '')) {
        return ["Key"]; // Fallback for single key column if names not provided
    }
    if (maxParts === 0) return []; // No key columns if no keys
    return Array.from({ length: maxParts }, (_, i) => `Key_${i + 1}`);
};

export const downloadJobReport = (job: BatchClassificationResult, format: DownloadFormat = 'full') => {
    const resultsArray = job.results || [];
    if (resultsArray.length === 0) { alert('No results to download for this job.'); return; }

    try {
        const keyHeaders = getKeyHeaders(job);
        const numKeyColumns = keyHeaders.length;

        const allLevels = new Set<string>();
        resultsArray.forEach(item => { if (item.result?.levels) Object.keys(item.result.levels).forEach(level => allLevels.add(level)); });
        
        const levelOrder: Record<string, number> = {
            'segment': 1, 'family': 2, 'class': 3, 'commodity': 4,
            'subcat1': 1, 'subcat2': 2 // Ensure robust matching for common cats too
        };
        const sortedLevels = Array.from(allLevels).sort((a, b) => 
            ((levelOrder[a.toLowerCase()] ?? 999) - (levelOrder[b.toLowerCase()] ?? 999)) || a.localeCompare(b) // Use toLowerCase for robust key matching
        );

        let headers: string[] = [];
        if (numKeyColumns > 0) { // Only add key headers if there are key columns
            headers.push(...keyHeaders.map(header => escapeCsvValue(header)));
        }
        headers.push(escapeCsvValue('Description'));
        headers.push(escapeCsvValue('Additional_Context'));

        for (const level of sortedLevels) {
            headers.push(escapeCsvValue(`${level}_Code`));
            headers.push(escapeCsvValue(`${level}_Name`));
        }
        
        headers.push(escapeCsvValue('Item_Classification_Status')); // Moved here: Add status for both simple and full

        if (format === 'full') {
            headers.push(escapeCsvValue('RAG_Context_Used'));
            headers.push(escapeCsvValue('RAG_Context_Content'));
            for (const level of sortedLevels) {
                headers.push(escapeCsvValue(`LLM_Response_${level}`));
            }
            headers.push(escapeCsvValue('First_Level_Prompt'));
            headers.push(escapeCsvValue('All_Prompts_Detail_JSON'));
        }
        headers.push(escapeCsvValue('Item_Error_Message'));

        const csvRows = [headers.join(',')];

        resultsArray.forEach(item => {
            const row: string[] = [];
            
            if (numKeyColumns > 0) {
                const keyParts = splitMultiKey(item.key || '');
                for (let i = 0; i < numKeyColumns; i++) {
                    row.push(escapeCsvValue(keyParts[i] || ''));
                }
            }
            
            row.push(escapeCsvValue(item.description));
            row.push(escapeCsvValue(item.additional_context || '')); 

            let itemStatusValue = 'Failed'; 
            if (item.error) { itemStatusValue = 'Failed'; } 
            else if (item.result) { itemStatusValue = item.result.status; }

            for (const level of sortedLevels) {
                const category = item.result?.levels?.[level];
                row.push(escapeCsvValue(category?.code || ''));
                row.push(escapeCsvValue(category?.name || ''));
            }
            
            row.push(escapeCsvValue(itemStatusValue)); // Moved here: Add status value for both simple and full
            
            if (format === 'full') {
                row.push(escapeCsvValue(item.result?.ragContextUsed ? 'Yes' : 'No'));
                row.push(escapeCsvValue(item.result?.ragContext || ''));
                
                const llmReplies = sortedLevels.map(levelCode => 
                    escapeCsvValue(item.result?.levelResponses?.[levelCode] || '')
                );
                row.push(...llmReplies);

                row.push(escapeCsvValue(item.result?.firstLevelPrompt || '')); 
                row.push(escapeCsvValue(item.result?.allPromptsDetail || ''));
            }

            let errorMessage = '';
            if (item.error) {
                errorMessage = typeof item.error === 'string' ? item.error : (item.error as ClassificationError).message || JSON.stringify(item.error);
            } else if (item.result?.error) {
                errorMessage = item.result.error;
            }
            row.push(escapeCsvValue(errorMessage));
            
            csvRows.push(row.join(','));
        });

        const csvContent = csvRows.join('\r\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const formatSuffix = format === 'simple' ? 'simple' : 'full';
        saveAs(blob, `batch_job_${job.id}_${formatSuffix}_report.csv`);

    } catch(error) {
         console.error('[CSV Generator] Error creating download:', error);
         alert(`Failed to generate download file: ${error instanceof Error ? error.message : String(error)}`);
    }
};

File: src/test-data/sample_products.csv
Product Description,Additional Context,Expected Category
"Blue ballpoint pens with medium point","Office supplies for front desk","Office supplies"
"HP LaserJet Pro color printer with wireless","IT department equipment","Computer printers"
"Ergonomic mesh office chair with lumbar support","Furniture for new hires","Office furniture"
"LED desk lamp with adjustable brightness","Workspace accessories","Office lighting"
"Microsoft Windows 11 Professional license key","Software licenses","Operating systems"
"First aid kit with 100 pieces","Safety equipment","Medical supplies"
"55-inch 4K smart TV for conference room","Meeting room equipment","Display devices"
"Wireless keyboard and mouse combo","Computer peripherals","Input devices"
"Industrial paper shredder cross-cut","Document security","Office machines"
"Cloud-based accounting software subscription","Finance department tools","Business software"

File: src/components/BatchJobsTab/components/BatchSummary.tsx
// src/components/BatchJobsTab/components/BatchSummary.tsx
import React, { useMemo } from 'react';
import { Button } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';
import { BatchClassificationResult } from '../../../api/types';
import { isSuccessfulItem, isFailedItem, isPartialItem } from '../utils/batchJobUtils';

interface BatchSummaryProps {
  batchJob: BatchClassificationResult;
  onViewDetails: () => void;
}

export const BatchSummary: React.FC<BatchSummaryProps> = ({ batchJob, onViewDetails }) => {
  const resultsArray = batchJob.results || [];
  const totalItems = resultsArray.length;

  // Calculate counts using our utility functions
  const successCount = useMemo(() => resultsArray.filter(isSuccessfulItem).length, [resultsArray]);
  const partialCount = useMemo(() => resultsArray.filter(isPartialItem).length, [resultsArray]);
  const failedCount = useMemo(() => resultsArray.filter(isFailedItem).length, [resultsArray]);

  // Calculate success and failure rates
  const successRate = totalItems > 0 ? Math.round((successCount / totalItems) * 100) : 0;
  const partialRate = totalItems > 0 ? Math.round((partialCount / totalItems) * 100) : 0;
  const failedRate = totalItems > 0 ? Math.round((failedCount / totalItems) * 100) : 0;

  // Function to split multi-keys into array (separated by |)
  const splitMultiKey = (key: string = ''): string[] => {
    if (!key) return [''];
    return key.split('|').map(k => k.trim());
  };

  // Determines the maximum number of key parts across all items
  const getMaxKeyParts = (results: any[]): number => {
    let maxParts = 1; // Default to at least one key column
    
    for (const item of results) {
      if (item.key) {
        const keyParts = splitMultiKey(item.key);
        maxParts = Math.max(maxParts, keyParts.length);
      }
    }
    
    return maxParts;
  };

  const handleExportCSV = () => {
    // Prepare the CSV data
    let headers = ['Item Number', 'Description', 'Additional Context', 'Status', 'Error'];
    
    // Check if keys exist in the data
    const hasKeys = resultsArray.some(r => r.key);
    const maxKeyParts = hasKeys ? getMaxKeyParts(resultsArray) : 0;
    
    // Add key columns if needed
    if (hasKeys && maxKeyParts > 0) {
      const keyHeaders = Array.from({ length: maxKeyParts }, (_, i) => `Key_${i+1}`);
      headers = [...keyHeaders, ...headers];
    }
    
    // Add category levels for UNSPSC or Common Categories
    const systemCode = batchJob.system_code || '';
    if (systemCode.toUpperCase().includes('UNSPSC')) {
      headers = [...headers, 'Segment Code', 'Segment Name', 'Family Code', 'Family Name', 
                 'Class Code', 'Class Name', 'Commodity Code', 'Commodity Name'];
    } else {
      headers = [...headers, 'SUBCAT1 Code', 'SUBCAT1 Name', 'SUBCAT2 Code', 'SUBCAT2 Name'];
    }
    
    // Convert data to CSV format
    const csvContent = [
      headers.join(','),
      ...resultsArray.map((item, index) => {
        // Determine item status
        let status = 'Failed';
        if (isSuccessfulItem(item)) {
          status = 'Success';
        } else if (isPartialItem(item)) {
          status = 'Partial';
        }
        
        // Get level data if available
        const levels = item.result?.levels || {};
        
        // Format description and context - escape quotes and commas
        const escapedDescription = item.description ? `"${item.description.replace(/"/g, '""')}"` : '';
        const escapedContext = item.additional_context ? `"${item.additional_context.replace(/"/g, '""')}"` : '';
        
        // Format error - escape quotes and commas
        const error = item.error || item.result?.error || '';
        const errorText = typeof error === 'string' ? error : (error?.message || '');
        const escapedError = errorText ? `"${errorText.replace(/"/g, '""')}"` : '';
        
        const row = [];
        
        // Add key parts if needed
        if (hasKeys && maxKeyParts > 0) {
          const keyParts = splitMultiKey(item.key || '');
          // Fill in key columns - add empty strings for missing parts
          for (let i = 0; i < maxKeyParts; i++) {
            row.push(keyParts[i] || '');
          }
        }
        
        // Add standard fields
        row.push(index + 1);
        row.push(escapedDescription);
        row.push(escapedContext);
        row.push(status);
        row.push(escapedError);
        
        // Extract level data based on system
        if (systemCode.toUpperCase().includes('UNSPSC')) {
          // UNSPSC system
          const segment = levels.segment || {};
          const family = levels.family || {};
          const classLevel = levels.class || {};
          const commodity = levels.commodity || {};
          
          row.push(segment.code || '');
          row.push(`"${(segment.name || '').replace(/"/g, '""')}"`);
          row.push(family.code || '');
          row.push(`"${(family.name || '').replace(/"/g, '""')}"`);
          row.push(classLevel.code || '');
          row.push(`"${(classLevel.name || '').replace(/"/g, '""')}"`);
          row.push(commodity.code || '');
          row.push(`"${(commodity.name || '').replace(/"/g, '""')}"`);
        } else {
          // Common Categories system
          const subcat1 = levels.SUBCAT1 || {};
          const subcat2 = levels.SUBCAT2 || {};
          
          row.push(subcat1.code || '');
          row.push(`"${(subcat1.name || '').replace(/"/g, '""')}"`);
          row.push(subcat2.code || '');
          row.push(`"${(subcat2.name || '').replace(/"/g, '""')}"`);
        }
        
        return row.join(',');
      })
    ].join('\n');
    
    // Create and trigger download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `batch-results-${batchJob.id}-${new Date().toISOString().slice(0, 10)}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="bg-white rounded-md border border-secondary-200 shadow-card p-6">
      <div className="flex justify-between mb-6">
        <h3 className="text-lg font-semibold text-secondary-900">Batch Results</h3>
        <div className="flex gap-3">
          <Button
            icon={<DownloadOutlined />}
            onClick={handleExportCSV}
          >
            Export CSV
          </Button>
          <Button type="primary" onClick={onViewDetails}>
            View Details
          </Button>
        </div>
      </div>
      
      <div className="mb-6">
        <div className="h-3 w-full rounded-full bg-secondary-100 overflow-hidden">
          <div className="h-full bg-green-500" style={{ width: `${successRate}%`, float: 'left' }}></div>
          <div className="h-full bg-yellow-500" style={{ width: `${partialRate}%`, float: 'left' }}></div>
          <div className="h-full bg-red-500" style={{ width: `${failedRate}%`, float: 'left' }}></div>
        </div>
        <div className="flex justify-between mt-1 text-sm">
          <span className="text-green-600 font-medium">{successCount} successful ({successRate}%)</span>
          {partialCount > 0 && (
            <span className="text-yellow-600 font-medium">{partialCount} partial ({partialRate}%)</span>
          )}
          <span className="text-red-600 font-medium">{failedCount} failed ({failedRate}%)</span>
        </div>
      </div>
      
      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
        {/* Successful Items */}
        <div className="rounded-md bg-green-50 p-4">
          <div className="text-sm font-medium text-green-700 mb-1">Successful</div>
          <div className="text-2xl font-semibold text-green-600">{successCount}</div>
          <div className="text-xs text-green-600 mt-1">Items classified with all levels</div>
        </div>
        
        {/* Partial Items */}
        <div className="rounded-md bg-yellow-50 p-4">
          <div className="text-sm font-medium text-yellow-700 mb-1">Partial</div>
          <div className="text-2xl font-semibold text-yellow-600">{partialCount}</div>
          <div className="text-xs text-yellow-600 mt-1">Items classified with some levels</div>
        </div>
        
        {/* Failed Items */}
        <div className="rounded-md bg-red-50 p-4">
          <div className="text-sm font-medium text-red-700 mb-1">Failed</div>
          <div className="text-2xl font-semibold text-red-600">{failedCount}</div>
          <div className="text-xs text-red-600 mt-1">Items that could not be classified</div>
        </div>
      </div>
    </div>
  );
};

File: src/api/classification.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { 
  ClassificationResult, 
  ManualClassificationRequest, 
  ClassificationHistoryRequest,
  ClassificationHistoryPage,
  ClassificationHistory
} from './types';

export class ClassificationService {
  constructor(private core: ApiClientCore) {}

  async classify(description: string, systemCode: string = 'UNSPSC', additionalContext?: string, modelOverride?: string): Promise<ClassificationResult> {
    const requestId = Math.random().toString(36).substring(7);
    console.log("[ApiClient] classify Request ID:", requestId);
    try {
      const response = await this.core.fetchWithTimeout(formatEndpoint('/classify'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          description,
          system_code: systemCode,
          additional_context: additionalContext,
          save_failed: true,
          model_override: modelOverride,
        }),
      });
      const result = await response.json();
      if (!response.ok) {
        const errorMessage = result.error || response.statusText || 'Classification failed';
        const fullError = result.details ? `${errorMessage}: ${result.details}` : errorMessage;
        throw new Error(fullError);
      }
      let status: 'success' | 'partial' | 'failed' = 'success';
      if (result.error) {
        status = Object.keys(result.levels || {}).length > 0 ? 'partial' : 'failed';
      }      return {
        ...result,
        description,
        status: result.status || status,
        timestamp: this.core.formatDate(result.timestamp),
        firstLevelPrompt: result.first_level_prompt || result.firstLevelPrompt,
        allPromptsDetail: result.all_prompts_detail || result.allPromptsDetail
      };
    } catch (error) {
      console.error(`[${requestId}] Classification error:`, error);
      throw error;
    }
  }

  async classifyManually(request: ManualClassificationRequest): Promise<ClassificationResult> {
     const requestId = Math.random().toString(36).substring(7);
      console.log("[ApiClient] classifyManually Request ID:", requestId);
     try {
        const response = await this.core.fetchWithTimeout(formatEndpoint('/classify/manual'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                description: request.description,
                systemCode: request.systemCode, // Ensure backend expects camelCase or adjust here
                levels: request.levels,
                model_override: request.modelOverride, // Pass selected model if available
            }),
        });
        if (!response.ok) {
            const error = await response.json().catch(() => ({ error: response.statusText }));
            throw new Error(error.error || 'Manual classification failed');
        }        const result = await response.json();
        return {
            ...result,
            description: request.description,
            status: result.status || 'success',
            timestamp: this.core.formatDate(result.timestamp),
            firstLevelPrompt: result.first_level_prompt || result.firstLevelPrompt,
            allPromptsDetail: result.all_prompts_detail || result.allPromptsDetail
        };
     } catch (error) {
        console.error(`[${requestId}] Manual classification error:`, error);
        throw error;
     }
  }
  async rerunClassification(id: string): Promise<ClassificationResult> {
    const requestId = Math.random().toString(36).substring(7);
    try {
        const response = await this.core.fetchWithTimeout(formatEndpoint(`/history/${id}/rerun`), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        });
        if (!response.ok) {
            throw new Error(`Rerun classification failed: ${response.statusText}`);
        }
        const result = await response.json();
        
        // Map backend field names to frontend field names
        return {
            ...result,
            firstLevelPrompt: result.first_level_prompt || result.firstLevelPrompt,
            allPromptsDetail: result.all_prompts_detail || result.allPromptsDetail,
            timestamp: this.core.formatDate(result.timestamp)
        };
    } catch (error) {
        console.error(`[${requestId}] Error rerunning classification:`, error);
        throw error;
    }
  }

  async deleteClassification(id: string): Promise<void> {
    const requestId = Math.random().toString(36).substring(7);
    try {
        const response = await this.core.fetchWithTimeout(formatEndpoint(`/history/${id}`), {
            method: 'DELETE',
        });
        if (!response.ok) {
            throw new Error(`Delete classification failed: ${response.statusText}`);
        }
    } catch (error) {
        console.error(`[${requestId}] Error deleting classification:`, error);
        throw error;
    }
  }

  async getClassificationHistory(req: ClassificationHistoryRequest): Promise<ClassificationHistoryPage> {
    const params = new URLSearchParams();
    params.append('limit', (req.limit ?? 10).toString());
    if (req.cursor) params.append('cursor', req.cursor);
    if (req.status) params.append('status', req.status);
    if (req.startDate) params.append('start_date', req.startDate);
    if (req.endDate) params.append('end_date', req.endDate);
    if (req.search) params.append('search', req.search);
    if (req.sourceType) params.append('source_type', req.sourceType);
    if (req.createdBy) params.append('created_by', req.createdBy);

    const endpointPath = req.systemCode ? `/systems/${req.systemCode}/history` : '/history';
    const url = `${formatEndpoint(endpointPath)}?${params.toString()}`;
    const requestId = Math.random().toString(36).substring(7);

    try {
      const response = await this.core.fetchWithTimeout(url);
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: response.statusText }));
        throw new Error(error.error || 'Failed to get classification history');
      }
      const data = await response.json();

      // Map backend snake_case to frontend camelCase
      const items: ClassificationHistory[] = (data.items || []).map((item: any) => ({
        id: item.id,
        description: item.description,
        systemCode: item.system_code ?? item.systemCode,
        additionalContext: item.additional_context ?? item.additionalContext,
        levels: item.levels,
        createdAt: this.core.formatDate(item.created_at ?? item.createdAt),
        status: item.status,
        createdBy: item.created_by ?? item.createdBy,
        sourceType: item.source_type ?? item.sourceType,        ragContextUsed: item.rag_context_used ?? item.ragContextUsed,
        ragContext: item.rag_context ?? item.ragContext,
        levelResponses: item.level_responses ?? item.levelResponses,
        error: item.error,
        firstLevelPrompt: item.first_level_prompt ?? item.firstLevelPrompt,
        allPromptsDetail: item.all_prompts_detail ?? item.allPromptsDetail,
        modelUsed: item.model_used ?? item.modelUsed,
      }));

      return {
        items: items,
        totalCount: data.total_count,
        nextCursor: data.next_cursor,
      };
    } catch (error) {
        console.error(`[${requestId}] Get classification history error:`, error);
        if (error instanceof Error) {
            throw new Error(`Failed to load history: ${error.message}`);
        } else {
            throw new Error('Failed to load history due to an unknown error.');
        }
    }
  }

  async deleteClassificationHistory(id: string): Promise<void> {
    const response = await this.core.fetchWithTimeout(formatEndpoint(`/history/${id}`), {
      method: 'DELETE',
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to delete classification history: ${errorText}`);
    }
  }
}

File: src/api/batch-classification.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import {
  BatchClassificationRequest,
  BatchClassificationResult,
  BatchJobsPage,
  BatchJobParams
} from './types';

export class BatchClassificationService {
    constructor(private core: ApiClientCore) {}

    async classifyBatch(request: BatchClassificationRequest): Promise<BatchClassificationResult> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const requestBody: any = {
                items: request.items.map(item => ({
                    description: item.description,
                    additional_context: item.additionalContext,
                    key: item.key
                })),
                system_code: request.systemCode,
            };
            if (Array.isArray(request.key_column_names) && request.key_column_names.length > 0) {
                requestBody.key_column_names = request.key_column_names;
            }

            const response = await this.core.fetchWithTimeout(formatEndpoint('/classify/batch'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Batch classification failed');
            }
            const result = await response.json();
            return {
                ...result,
                timestamp: this.core.formatDate(result.timestamp),
                // Ensure systemCode is correctly propagated or derived
                systemCode: result.system_code || request.systemCode || result.results?.[0]?.result?.system_code
            };
        } catch (error) {
            console.error(`[${requestId}] Batch classification error:`, error);
            throw error;
        }
    }

    async getBatchStatus(batchId: string): Promise<BatchClassificationResult> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            // Corrected endpoint:
            const response = await this.core.fetchWithTimeout(formatEndpoint(`/batch/jobs/${batchId}`));
            if (!response.ok) {
                // Try to parse error from backend, otherwise use statusText
                let errorPayload;
                try {
                    errorPayload = await response.json();
                } catch (e) {
                    // Ignore parsing error if body is not JSON or empty
                }
                const errorMessage = errorPayload?.error || response.statusText || `Failed to get batch status (${response.status})`;
                console.error(`[${requestId}] Get batch status error (${response.status}):`, errorMessage, errorPayload);
                throw new Error(errorMessage);
            }
            const result = await response.json();
            // Ensure systemCode is correctly propagated or derived for consistency
            const systemCode = result.system_code || result.results?.[0]?.result?.system_code;
            return {
                ...result,
                timestamp: this.core.formatDate(result.timestamp),
                updated_at: result.updated_at ? this.core.formatDate(result.updated_at) : undefined,
                systemCode // Keep consistent casing
            };
        } catch (error) {
            // Log already happened or will be handled by the caller
            // console.error(`[${requestId}] Get batch status error (outer):`, error);
            throw error;
        }
    }

    async getBatchJobs(params: BatchJobParams): Promise<BatchJobsPage> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const searchParams = new URLSearchParams();
            if (params.limit) searchParams.append('limit', params.limit.toString());
            if (params.cursor) searchParams.append('cursor', params.cursor);
            if (params.status && params.status !== 'all') searchParams.append('status', params.status); // Only add if not 'all'
            if (params.startDate) searchParams.append('start_date', params.startDate);
            if (params.endDate) searchParams.append('end_date', params.endDate);

            const url = `${formatEndpoint('/batch/jobs')}${searchParams.toString() ? '?' + searchParams.toString() : ''}`;
            const response = await this.core.fetchWithTimeout(url, { method: 'GET' });

            if (!response.ok) {
                const errorText = await response.text(); // Get raw text for debugging
                console.error(`[${requestId}] Failed to fetch batch jobs (${response.status}): ${errorText}`);
                throw new Error(`Failed to fetch batch jobs: ${response.statusText} - ${errorText}`);
            }
            const data = await response.json();
            // Ensure consistent casing and data transformation
            const items = (data.items || []).map((job: any) => ({
                ...job,
                id: job.id,
                status: job.status,
                system_code: job.system_code, // Keep snake_case from backend if that's what it sends
                systemCode: job.system_code,  // Add camelCase for frontend consistency
                timestamp: this.core.formatDate(job.timestamp),
                updated_at: job.updated_at ? this.core.formatDate(job.updated_at) : undefined,
                totalItems: job.total_items,
                processedItems: job.processed_items,
                keyColumnNames: job.key_column_names,
                results: job.results || [], // Ensure results is always an array
            }));
            return {
                items,
                totalCount: data.total_count,
                nextCursor: data.next_cursor,
            };
        } catch (error) {
            console.error(`[${requestId}] Error fetching batch jobs:`, error);
            throw error;
        }
    }
}

File: src/components/BatchJobsTab/components/JobStatusDisplay.tsx
// src/components/BatchJobsTab/components/JobStatusDisplay.tsx
import React from 'react';
import { BatchClassificationResult } from '../../../api/types';
import { getExecutionStatus, calculateResultStatus, isSuccessfulItem, isFailedItem, isPartialItem } from '../utils/batchJobUtils';
import { ExecutionStatusType, ResultStatusType } from '../utils/batchJobUtils';
import { formatDate } from '../../../utils/dateFormat';

interface JobStatusDisplayProps { job: BatchClassificationResult; }

// Execution Status Badge Component
export const ExecutionStatusBadge: React.FC<{ status: ExecutionStatusType }> = ({ status }) => {
    const styles: Record<ExecutionStatusType, string> = {
        pending: "bg-blue-100 text-blue-800 border-blue-200",
        processing: "bg-yellow-100 text-yellow-800 border-yellow-200 animate-pulse",
        completed: "bg-green-100 text-green-800 border-green-200",
        error: "bg-red-100 text-red-800 border-red-200"
    };
    const labels: Record<ExecutionStatusType, string> = {
        pending: "Pending",
        processing: "Processing",
        completed: "Completed",
        error: "Error"
    };
    const style = styles[status];
    const label = labels[status];
    return <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${style}`}>{label}</span>;
};

// Result Status Badge Component
export const ResultStatusBadge: React.FC<{ status: ResultStatusType }> = ({ status }) => {
    if (status === 'N/A') {
        return <span className="text-xs text-gray-400 italic">N/A</span>;
    }
    const styles: Record<Exclude<ResultStatusType, 'N/A'>, string> = {
        successful: "bg-green-100 text-green-800 border-green-200",
        partial: "bg-orange-100 text-orange-800 border-orange-200",
        failed: "bg-red-100 text-red-800 border-red-200"
    };
    const labels: Record<Exclude<ResultStatusType, 'N/A'>, string> = {
        successful: "Successful",
        partial: "Partial",
        failed: "Failed"
    };
    const style = styles[status];
    const label = labels[status];
    return <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${style}`}>{label}</span>;
};

// Renders the progress bar and text
const ProgressInfo: React.FC<{ job: BatchClassificationResult }> = ({ job }) => {
    const resultsArray = job.results || job.Results || [];
    
    // Access the totalItems property from the API response
    const totalItems = job.totalItems ?? 0;
    
    // Access processedItems from the API response, fall back to counting if not available
    const processedItems = job.processedItems ?? resultsArray.filter(r => r.result || r.error).length;
    
    console.log('Job object in ProgressInfo:', job);
    console.log('Total items detected:', totalItems);
    console.log('Processed items detected:', processedItems);
    
    // Use totalItems, or fall back to array length if not available
    const total = totalItems > 0 ? totalItems : resultsArray.length;
    
    if (total === 0) return <div className="text-xs text-secondary-500">No items</div>;
    
    // Use the processed items count from the API if available
    const processed = processedItems;
    const success = resultsArray.filter(isSuccessfulItem).length;
    const partial = resultsArray.filter(isPartialItem).length;
    const failed = processed - success - partial;

    // Calculate success rate based on fully successful items
    const successRate = processed > 0 ? Math.round((success / processed) * 100) : 0;

    // Calculate partial success rate
    const partialRate = processed > 0 ? Math.round((partial / processed) * 100) : 0;

    // Determine overall success rate description
    const successRateDescription = () => {
        const combinedSuccessRate = successRate + (partialRate / 2); // Count partials as half successful for color determination
        if (combinedSuccessRate >= 80) return 'text-green-600';
        if (combinedSuccessRate >= 50) return 'text-orange-600';
        return 'text-red-600';
    };

    const executionStatus = getExecutionStatus(job);

    if (executionStatus === 'pending') {
        return (
            <div className="space-y-1">
                <div className="flex justify-between mb-1 text-xs">
                    <span>0/{total} items</span>
                    <span className="text-secondary-500">0% success</span>
                </div>
                <div className="w-full bg-secondary-200 rounded-full h-2">
                    <div className="bg-blue-500 h-full" style={{ width: '0%' }} />
                </div>
                <div className="text-xs text-blue-600 text-right">Waiting...</div>
            </div>
        );
    }

    // Calculate width percentages for the progress bar
    const successWidth = (success / total) * 100;
    const partialWidth = (partial / total) * 100;
    const failedWidth = (failed / total) * 100;
    const pendingWidth = ((total - processed) / total) * 100;

    return (
        <div className="space-y-1">
            <div className="flex justify-between mb-1 text-xs">
                <span>{processed}/{total} processed</span>
                {processed > 0 && (
                    <span className={successRateDescription()}>
                        {successRate}% success {partial > 0 ? `(+${partialRate}% partial)` : ''}
                    </span>
                )}
            </div>
            <div className="w-full bg-secondary-200 rounded-full h-2 relative overflow-hidden">
                {/* Success segment (green) */}
                {success > 0 && (
                    <div 
                        className="absolute top-0 left-0 bg-green-500 h-full transition-width duration-500 ease-out" 
                        style={{ width: `${successWidth}%` }} 
                    />
                )}
                
                {/* Partial segment (orange) */}
                {partial > 0 && (
                    <div 
                        className="absolute top-0 bg-orange-500 h-full transition-width duration-500 ease-out" 
                        style={{ left: `${successWidth}%`, width: `${partialWidth}%` }} 
                    />
                )}
                
                {/* Failed segment (red) */}
                {failed > 0 && (
                    <div 
                        className="absolute top-0 bg-red-500 h-full transition-width duration-500 ease-out" 
                        style={{ left: `${successWidth + partialWidth}%`, width: `${failedWidth}%` }} 
                    />
                )}
                
                {/* Processing segment (yellow pulse) */}
                {executionStatus === 'processing' && processed < total && (
                    <div 
                        className="absolute top-0 bg-yellow-400 h-full animate-pulse" 
                        style={{ left: `${(processed / total) * 100}%`, width: `${pendingWidth}%` }} 
                    />
                )}
            </div>
            {executionStatus === 'processing' && <div className="text-xs text-yellow-600 text-right">Processing...</div>}
            {executionStatus === 'completed' && calculateResultStatus(job) === 'successful' && 
                <div className="text-xs text-green-600 text-right">Successfully Completed</div>}
            {executionStatus === 'completed' && calculateResultStatus(job) === 'partial' && 
                <div className="text-xs text-orange-600 text-right">Partially Successful</div>}
            {executionStatus === 'completed' && calculateResultStatus(job) === 'failed' && 
                <div className="text-xs text-red-600 text-right">Failed</div>}
        </div>
    );
};

// Renders a summary of counts
const JobSummary: React.FC<{ job: BatchClassificationResult }> = ({ job }) => {
    const resultsArray = job.results || job.Results || [];
    
    // Access the totalItems property, but handle the case where the server sends it as total_items
    const totalItems = job.totalItems ?? (job as any).total_items;
    
    console.log('Job object in JobSummary:', job);
    console.log('Total items detected in summary:', totalItems);
    
    // Use totalItems, or fall back to array length if not available
    const total = totalItems ?? resultsArray.length;
    
    if (total === 0) return <div className="text-xs text-secondary-500">No items</div>;
    
    const success = resultsArray.filter(isSuccessfulItem).length;
    const partial = resultsArray.filter(isPartialItem).length;
    const failed = resultsArray.filter(isFailedItem).length;
    const processed = resultsArray.filter(r => r.result || r.error).length;
    const pending = total - processed;
    
    const executionStatus = getExecutionStatus(job);

    return (
        <div className="text-xs text-secondary-600 space-y-0.5">
            <div>Total: <span className="font-medium">{total}</span></div>
            <div className="text-green-600">Success: <span className="font-medium">{success}</span></div>
            {partial > 0 && (
                <div className="text-orange-600">Partial: <span className="font-medium">{partial}</span></div>
            )}
            <div className="text-red-600">Failed: <span className="font-medium">{failed}</span></div>
            {(executionStatus === 'pending' || executionStatus === 'processing') && pending > 0 && 
                <div className="text-yellow-600">Pending: <span className="font-medium">{pending}</span></div>}
            {processed > 0 && (
                <div className="text-secondary-500 pt-1">
                    Success Rate: <span className="font-medium">{Math.round((success / processed) * 100)}%</span>
                    {partial > 0 && (
                        <> (+<span className="font-medium">{Math.round((partial / processed) * 100)}%</span> partial)</>
                    )}
                </div>
            )}
        </div>
    );
};

// Combined component to render multiple cells related to status/progress
export const JobStatusDisplay: React.FC<JobStatusDisplayProps> = ({ job }) => {
    const executionStatus = getExecutionStatus(job);
    const resultStatus = calculateResultStatus(job);

    return (
        <>
            {/* Execution Status Cell */}
            <td className="px-4 py-4 whitespace-nowrap text-sm">
                <ExecutionStatusBadge status={executionStatus} />
            </td>
            {/* Result Status Cell */}
            <td className="px-4 py-4 whitespace-nowrap text-sm">
                <ResultStatusBadge status={resultStatus} />
            </td>
            {/* Created Date Cell */}
            <td className="px-4 py-4 whitespace-nowrap text-sm text-secondary-600">
                <span title={formatDate(job.timestamp).fullText}>
                    {formatDate(job.timestamp).displayText}
                </span>
            </td>
            {/* Progress Info Cell */}
            <td className="px-4 py-4 text-sm w-52">
                <ProgressInfo job={job} />
            </td>
            {/* Summary Info Cell */}
            <td className="px-4 py-4 text-sm">
                <JobSummary job={job} />
            </td>
        </>
    );
};

File: src/api/core-client.ts
import { formatEndpoint } from '../config/api';

// Constants for local storage keys
export const AUTH_TOKEN_KEY = 'authToken';
export const USER_INFO_KEY = 'userInfo';

export class ApiClientCore {
  readonly timeoutDuration: number = 6000000; // 600 second timeout
  authEnabled: boolean | null = null; // Track if auth is enabled

  formatDate(dateStr: string | undefined | null): string {
    if (!dateStr) {
      return new Date().toISOString();
    }
    try {
      return new Date(dateStr).toISOString();
    } catch (e) {
      console.error('Error formatting date:', dateStr, e);
      return new Date().toISOString();
    }
  }

  getAuthHeader(): HeadersInit {
    const token = localStorage.getItem(AUTH_TOKEN_KEY);
    return token ? { 'Authorization': `Bearer ${token}` } : {};
  }

  async fetchWithTimeout(url: string, options: RequestInit = {}): Promise<Response> {
    const controller = new AbortController();
    const id = Math.random().toString(36).substring(7);

    const timeout = setTimeout(() => {
      controller.abort();
      console.error(`Request ${id} timed out:`, url);
    }, this.timeoutDuration);

    const authHeaders = this.getAuthHeader();
    const headers = {
      ...options.headers,
      ...authHeaders
    };

    console.log(`[${id}] Starting request:`, url);

    try {
      const response = await fetch(url, {
        ...options,
        headers,
        signal: controller.signal
      });

      console.log(`[${id}] Response received:`, {
        url,
        status: response.status,
        ok: response.ok
      });

      // Handle potential 401 Unauthorized specifically
      if (response.status === 401) {
          console.warn(`[${id}] Unauthorized request to ${url}. Clearing token.`);
          localStorage.removeItem(AUTH_TOKEN_KEY);
          localStorage.removeItem(USER_INFO_KEY);
          // Optionally redirect to login or notify the user
          // window.location.href = '/login'; // Example redirect
      }

      return response;
    } catch (error) {
      console.error(`[${id}] Request failed:`, {
        url,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    } finally {
      clearTimeout(timeout);
    }  }

  // --- Add generic HTTP methods ---
  async get<T = any>(path: string, params?: Record<string, any>, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    let urlString = endpoint;
    
    // Add query parameters to the URL
    if (params && Object.keys(params).length > 0) {
      const queryParams = new URLSearchParams();
      Object.keys(params).forEach(key => {
        if (params[key] !== undefined && params[key] !== null) {
          queryParams.append(key, String(params[key]));
        }
      });
      const queryString = queryParams.toString();
      urlString = queryString ? `${endpoint}${endpoint.includes('?') ? '&' : '?'}${queryString}` : endpoint;
    }
    
    const response = await this.fetchWithTimeout(urlString, { method: 'GET', ...config });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    return response.json() as Promise<T>;
  }

  async post<T = any>(path: string, data?: any, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    const response = await this.fetchWithTimeout(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...config?.headers },
      body: data ? JSON.stringify(data) : null,
      ...config,
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    // Handle cases where response might be empty (e.g., 204 No Content)
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      return response.json() as Promise<T>;
    }
    return response.text() as unknown as Promise<T>; // Or handle as appropriate
  }

  async put<T = any>(path: string, data?: any, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    const response = await this.fetchWithTimeout(endpoint, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...config?.headers },
      body: data ? JSON.stringify(data) : null,
      ...config,
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      return response.json() as Promise<T>;
    }
    return response.text() as unknown as Promise<T>;
  }

  async delete<T = any>(path: string, config?: RequestInit): Promise<T> {
    const endpoint = formatEndpoint(path);
    const response = await this.fetchWithTimeout(endpoint, {
      method: 'DELETE',
      ...config,
    });
    if (!response.ok) {
      const errorData = await response.text();
      throw new Error(`HTTP error! status: ${response.status}, path: ${path}, details: ${errorData}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      return response.json() as Promise<T>;
    }
    return response.text() as unknown as Promise<T>;
  }
  // --- End of new methods ---

  getCurrentUserInfo(): any | null {
    const stored = localStorage.getItem(USER_INFO_KEY);
    try {
      return stored ? JSON.parse(stored) : null;
    } catch (e) {
      console.error("Error parsing stored user info:", e);
      localStorage.removeItem(USER_INFO_KEY); // Clear invalid data
      return null;
    }
  }
  async fetchAuthConfig(): Promise<void> {
    try {
      const requestId = Math.random().toString(36).substring(7);
      console.log(`[${requestId}] Fetching auth configuration`);

      // Use auth config endpoint with v1 prefix
      const response = await fetch(formatEndpoint('/auth/config'));

      if (!response.ok) {
        console.warn(`[${requestId}] Failed to fetch auth config, assuming auth is disabled`);
        this.authEnabled = false;
        return;
      }

      const data = await response.json();
      this.authEnabled = data.enabled === true;
      console.log(`[${requestId}] Auth configuration fetched, auth is ${this.authEnabled ? 'enabled' : 'disabled'}`);
    } catch (error) {
      console.error('Error fetching auth config:', error);
      this.authEnabled = false; // Default to disabled on error
    }
  }
}

File: src/api/role.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { RoleListResponse, CreateRoleRequest, UpdateRoleRequest, Role } from './types';

export class RoleService {
    constructor(private core: ApiClientCore) {}

    async getRoles(params?: { limit?: number; offset?: number }): Promise<RoleListResponse> {
        const urlParams = new URLSearchParams();
        if (params?.limit) urlParams.append('limit', params.limit.toString());
        if (params?.offset) urlParams.append('offset', params.offset.toString());
        const url = `${formatEndpoint('/roles')}${urlParams.toString() ? '?' + urlParams.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to get roles");
            }
            return await response.json();
        } catch (error) {
            console.error(`Get roles error:`, error);
            throw error;
        }
    }

    async createRole(data: CreateRoleRequest): Promise<Role> {
        const url = formatEndpoint('/roles');
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to create role");
            }
            return await response.json();
        } catch (error) {
            console.error(`Create role error:`, error);
            throw error;
        }
    }

    async updateRole(id: number, data: UpdateRoleRequest): Promise<Role> {
        const url = formatEndpoint(`/roles/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to update role");
            }
            return await response.json();
        } catch (error) {
            console.error(`Update role error:`, error);
            throw error;
        }
    }

    async deleteRole(id: number): Promise<void> {
        const url = formatEndpoint(`/roles/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to delete role");
            }
        } catch (error) {
            console.error(`Delete role error:`, error);
            throw error;
        }
    }
}

File: src/api/auth.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore, AUTH_TOKEN_KEY, USER_INFO_KEY } from './core-client';
import { LoginResponse, User } from './types';

export class AuthService {
  constructor(private core: ApiClientCore) {}

  isLoggedIn(): boolean {
    const token = localStorage.getItem(AUTH_TOKEN_KEY);
    return !!token;
  }

  isAuthEnabled(): boolean | null {
    return this.core.authEnabled;
  }

  async login(username: string, password: string): Promise<LoginResponse> {
    const requestId = Math.random().toString(36).substring(7);
    console.log(`[${requestId}] Logging in user: ${username}`);
    try {
      const response = await this.core.fetchWithTimeout(formatEndpoint('/auth/login'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      });
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: response.statusText || 'Login failed' }));
        throw new Error(error.error || 'Authentication failed');
      }
      const result = await response.json();
      if (result.token) {
        localStorage.setItem(AUTH_TOKEN_KEY, result.token);
        if (result.user) {
          localStorage.setItem(USER_INFO_KEY, JSON.stringify(result.user));
        }
      } else {
        throw new Error('Authentication response missing token');
      }
      return result;
    } catch (error) {
      console.error(`[${requestId}] Login error:`, error);
      throw error;
    }
  }

  clearToken(): void {
    localStorage.removeItem(AUTH_TOKEN_KEY);
    localStorage.removeItem(USER_INFO_KEY);
    console.log('User logged out, token and user info cleared');
  }

  async getCurrentUser(): Promise<User> {
    const cachedUser = this.core.getCurrentUserInfo();
    if (cachedUser && cachedUser.permissions) {
      return cachedUser;
    }
    const url = formatEndpoint('/auth/me');
    try {
      const response = await this.core.fetchWithTimeout(url);
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: response.statusText }));
        throw new Error(error.error || "Failed to get current user information");
      }
      const user = await response.json();
      localStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
      return user;
    } catch (error) {
      console.error("Error fetching current user:", error);
      throw error;
    }
  }
}

File: src/api/permission.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { PermissionListResponse } from './types';

export class PermissionService {
    constructor(private core: ApiClientCore) {}

    async getPermissions(): Promise<PermissionListResponse> {
        const url = formatEndpoint('/permissions');
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to get permissions");
            }
            return await response.json();
        } catch (error) {
            console.error(`Get permissions error:`, error);
            throw error;
        }
    }
}

File: src/components/Sidebar/left-sidebar.css
/* Make sure this is in your left-sidebar.css */
.left-sidebar-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 70px;
    border-radius: 0;
    border-right: 1px solid #e8e8e8;
    background: white;
    transition: width 0.3s cubic-bezier(0.2, 0, 0, 1) 0s !important;
    overflow: hidden;
    height: 100%;
  }
  
  .sidebar-open {
    width: 180px !important;
  }

  /* --- Antd Menu Item Styling --- */
  .left-sidebar-menu .ant-menu-item,
  .left-sidebar-menu .ant-menu-submenu-title {
    display: flex !important;
    align-items: center !important;
    /* Use min-height instead of fixed height for flexibility, adjust value as needed */
    min-height: 40px !important;
    height: auto !important; /* Allow height to adjust naturally if content wraps, used with min-height */
    padding-top: 8px !important;
    padding-bottom: 8px !important;
    line-height: normal !important;
    padding-left: 20px !important;
  }
  
  /* --- Icon Styling (Ensure Consistent Size) --- */
  /* Target the container AND the SVG for robustness */
  .left-sidebar-menu .ant-menu-item-icon,
  .left-sidebar-menu .ant-menu-submenu-title .ant-menu-item-icon {
    /* Ensure container doesn't shrink and centers icon */
    flex-shrink: 0;
    display: inline-flex !important; /* Use inline-flex for better alignment control */
    align-items: center;
    justify-content: center;
    /* Define container size slightly larger than icon if needed */
    /* width: 24px !important; */
    /* height: 24px !important; */
    line-height: 1 !important; /* Crucial */
    margin-right: 10px !important; /* Ensure consistent space */
  }
  
  .left-sidebar-menu .ant-menu-item-icon svg, /* Target SVG directly */
  .left-sidebar-menu .ant-menu-submenu-title .ant-menu-item-icon svg { /* Target SVG in submenu title */
    width: 20px !important;  /* <<< SET YOUR DESIRED ICON WIDTH */
    height: 20px !important; /* <<< SET YOUR DESIRED ICON HEIGHT */
    /* font-size: 20px !important; */ /* Font-size less reliable for SVG */
    display: block !important; /* Helps prevent extra space */
    flex-shrink: 0; /* Prevent shrinking */
    transition: none !important; /* No size transitions */
    vertical-align: middle; /* Align vertically */
  }

  /* Style Antd Label Container (.ant-menu-title-content contains our LeftSidebarItem output) */
  .left-sidebar-menu .ant-menu-item-icon + .ant-menu-title-content {
    /* margin-left: 10px !important; */ /* Space now handled by icon container's margin-right */
    flex-grow: 1;
    overflow: hidden;
    display: flex;
    align-items: center;
    line-height: normal !important; /* Ensure consistency */
    vertical-align: middle; /* Align vertically */
  }

  /* --- Label Styling (Focus on visibility/opacity) --- */
  .left-panel-label {
    display: inline-block; /* Keep it in the flow */
    white-space: nowrap;
    vertical-align: middle; /* Align with icon */
    /* Control visibility via opacity and visibility */
    visibility: hidden;
    opacity: 0;
    /* Adjust transition for smoothness */
    transition: opacity 0.2s 0.1s ease-in-out !important; /* Added slight delay back */
  }

  .sidebar-open .left-panel-label {
    visibility: visible;
    opacity: 1;
    /* transition-delay: 0.1s !important; */ /* Delay now in main transition */
  }

  /* --- Bottom Menu Specific --- */
  .left-sidebar-menu.bottom-menu.ant-menu-light.ant-menu-root.ant-menu-inline {
    border-top: none !important;
    box-shadow: none !important;
  }
  .left-sidebar-menu.bottom-menu .ant-menu-item:first-child {
     border-top: none !important;
     margin-top: 0 !important;
  }
  .left-sidebar-menu.bottom-menu .ant-menu-item {
      border-top: none !important;
  }
  .left-sidebar-container > .ant-row:last-child {
       border-top: none !important;
  }

  .custom-menu.ant-menu-root.ant-menu-inline {
    background: white;
    border: 0px;
  
    .ant-menu-item::after {
      left: 0;
      right: unset;
    }
  
    .ant-menu-item-group-title {
      font-size: 12px;
      padding: 12px 16px;
      color: grey;
    }
  
    .ant-menu-item-icon + span {
      margin-left: 8px;
    }
  
    .ant-menu-item {
      height: 30px;
      line-height: 30px;
      margin-top: 2px;
      padding: 0 16px !important;
    }
  
    .ant-menu-item:hover,
    .ant-menu-item-selected {
      .side-panel-icons {
        color: black;
      }
    }
  
    .ant-menu-item-selected {
      .ant-menu-title-content {
        font-weight: 600;
  
        .ant-badge {
          color: black;
        }
      }
    }
  
    .ant-menu-item-active {
      .ant-menu-title-content {
        .ant-badge {
          color: black;
        }
      }
    }
  
    .ant-menu-item:not(:last-child) {
      margin-bottom: 0px;
    }
  
    .ant-menu:not(.ant-menu-horizontal) .ant-menu-item-selected {
      border-right: 1px solid transparent;
    }
  }
  
  .custom-menu-with-description {
    &.custom-menu.ant-menu-root.ant-menu-inline .ant-menu-item {
      height: 50px;
      margin-top: 4px;
    }
  
    &.custom-menu.ant-menu-root.ant-menu-inline
      .ant-menu-item-selected
      .ant-menu-title-content {
      font-weight: 400;
    }
  }

  /* Add consistent transitions for all menu items */
  .left-sidebar-menu .ant-menu-item,
  .left-sidebar-menu .ant-menu-item-only-child,
  .left-sidebar-menu .ant-menu-item-group-title,
  .left-sidebar-menu .ant-menu-item-group-list,
  .left-sidebar-menu .ant-menu-sub,
  .left-sidebar-menu .ant-menu-inline,
  .left-sidebar-menu .ant-menu-title-content,
  .left-sidebar-menu .ant-menu-submenu,
  .left-sidebar-menu .ant-menu-submenu-inline,
  .left-sidebar-menu .ant-menu-submenu-title {
    transition: all 0.3s cubic-bezier(0.2, 0, 0, 1) 0s !important;
  }

  /* Ensure consistent hover behavior */
  .left-sidebar-menu .ant-menu-item:hover,
  .left-sidebar-menu .ant-menu-submenu:hover {
    background-color: rgba(0, 0, 0, 0.025) !important;
  }

  /* Fix the hover-out behavior */
  .left-sidebar-container:not(.sidebar-open) .ant-menu-submenu-inline:hover,
  .left-sidebar-container:not(.sidebar-open) .ant-menu-item:hover {
    width: auto !important;
    opacity: 1 !important;
    visibility: visible !important;
  }

  /* Ensure submenu items collapse instead of disappearing */
  .left-sidebar-container:not(.sidebar-open) .ant-menu-submenu-arrow {
    opacity: 0 !important;
    transition: all 0.3s cubic-bezier(0.2, 0, 0, 1) 0s !important;
  }

  /* For submenu when sidebar IS open */
  .sidebar-open .ant-menu-submenu-inline {
    visibility: visible !important;
    opacity: 1 !important;
    width: 180px !important; /* Maintain consistent width when expanded */
  }

  /* Make sure submenu arrows are visible when sidebar is open */
  .sidebar-open .ant-menu-submenu-arrow {
    visibility: visible !important;
    opacity: 1 !important;
    display: inline-block !important;
  }

  /* For submenu when sidebar is NOT open */
  .left-sidebar-container:not(.sidebar-open) .ant-menu-submenu-inline {
    visibility: hidden !important;
    opacity: 1 !important; /* Change to 0 to truly hide */
    width: 90px !important;
  }

  /* For menu title content when sidebar is open */
  .sidebar-open .ant-menu-title-content {
    visibility: visible !important;
    opacity: 1 !important;
    display: inline-block !important;
  }



File: src/api/rag.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { 
    RagInfoItem, 
    RagInfoPage, 
    RagInfoRequestParams, 
    CreateRagInfoRequest, 
    UpdateRagInfoRequest 
} from './types';

export class RagService {
    constructor(private core: ApiClientCore) {}

    async getRagInfoList(params: RagInfoRequestParams): Promise<RagInfoPage> {
        const requestId = Math.random().toString(36).substring(7);
        const searchParams = new URLSearchParams();
        if (params.page) searchParams.append('page', params.page.toString());
        if (params.limit) searchParams.append('limit', params.limit.toString());
        if (params.search) searchParams.append('search', params.search);
        const url = `${formatEndpoint('/rag-info')}${searchParams.toString() ? '?' + searchParams.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get RAG info list');
            }
            const result = await response.json();
            return {
                items: (result.items || []).map((item: any) => ({
                    ...item,
                    createdAt: this.core.formatDate(item.createdAt),
                    updatedAt: this.core.formatDate(item.updatedAt)
                })),
                totalCount: result.totalCount || 0,
                totalPages: result.totalPages || 1,
                currentPage: result.currentPage || 1,
            };
        } catch (error) {
            console.error(`[${requestId}] Get RAG info list error:`, error);
            throw error;
        }
    }

    async createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint('/rag-info');
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to create RAG info');
            }
            const result = await response.json();
            return {
                ...result,
                createdAt: this.core.formatDate(result.createdAt),
                updatedAt: this.core.formatDate(result.updatedAt)
            };
        } catch (error) {
            console.error(`[${requestId}] Create RAG info error:`, error);
            throw error;
        }
    }

    async getRagInfoItem(id: string): Promise<RagInfoItem> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint(`/rag-info/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || `Failed to get RAG info item ${id}`);
            }
            const result = await response.json();
            return {
                ...result,
                createdAt: this.core.formatDate(result.createdAt),
                updatedAt: this.core.formatDate(result.updatedAt)
            };
        } catch (error) {
            console.error(`[${requestId}] Get RAG info item error:`, error);
            throw error;
        }
    }

    async updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint(`/rag-info/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || `Failed to update RAG info ${id}`);
            }
            const result = await response.json();
            return {
                ...result,
                createdAt: this.core.formatDate(result.createdAt),
                updatedAt: this.core.formatDate(result.updatedAt)
            };
        } catch (error) {
            console.error(`[${requestId}] Update RAG info error:`, error);
            throw error;
        }
    }

    async deleteRagInfo(id: string): Promise<void> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint(`/rag-info/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || `Failed to delete RAG info ${id}`);
            }
        } catch (error) {
            console.error(`[${requestId}] Delete RAG info error:`, error);
            throw error;
        }
    }

    // Keep the duplicate getRagInfo for compatibility if needed
    async getRagInfo(id: string): Promise<RagInfoItem> {
        return this.getRagInfoItem(id);
    }

    async queryRag(question: string): Promise<any> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const url = formatEndpoint('/rag/query');
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question }),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'RAG query failed');
            }
            return await response.json();
        } catch (error) {
            console.error(`[${requestId}] RAG query error:`, error);
            throw error;
        }
    }
}

File: src/components/BatchJobsTab/BatchJobDetailsModal.css
/* Custom scrollbar for the modal */
.batch-details-modal .ant-modal-body {
  scrollbar-width: thin;
  scrollbar-color: #d1d5db transparent;
}

.batch-details-modal .ant-modal-body::-webkit-scrollbar {
  width: 6px;
}

.batch-details-modal .ant-modal-body::-webkit-scrollbar-track {
  background: transparent;
}

.batch-details-modal .ant-modal-body::-webkit-scrollbar-thumb {
  background-color: #d1d5db;
  border-radius: 3px;
}

/* Focus styles */
.batch-details-modal *:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
}

.batch-details-modal .ant-modal-close:focus {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  border-radius: 9999px;
}

/* Processing overlay animation */
@keyframes pulse {
  0% {
    opacity: 0.5;
  }
  50% {
    opacity: 0.7;
  }
  100% {
    opacity: 0.5;
  }
}

.batch-details-modal .processing-overlay {
  animation: pulse 2s ease-in-out infinite;
  background-color: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(1px);
  border-radius: 0.25rem;
  padding: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Better table focus styles */
.batch-details-modal tr:focus-within {
  background-color: rgba(59, 130, 246, 0.05);
  outline: 2px solid rgba(59, 130, 246, 0.5);
  outline-offset: -2px;
}

/* Sticky header shadow */
.batch-details-modal thead {
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

/* Better modal transitions */
.batch-details-modal.ant-modal-wrap {
  transition: opacity 0.2s ease-out;
}

.batch-details-modal .ant-modal {
  transition: transform 0.2s ease-out;
}

.batch-details-modal .ant-modal-mask {
  transition: opacity 0.2s ease-out;
}

/* Improve result display */
.batch-details-modal pre {
  background-color: rgba(255, 255, 255, 0.5);
  border-radius: 0.375rem;
  padding: 0.5rem;
}

/* Better focus indication for interactive elements */
.batch-details-modal button:focus-visible,
.batch-details-modal [role="button"]:focus-visible {
  outline: 2px solid rgba(59, 130, 246, 0.5);
  outline-offset: 2px;
}

/* Screen reader only text */
.batch-details-modal .sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* ARIA keyboard navigation styles */
.batch-details-modal [tabindex="0"]:not(:focus-visible):focus {
  outline: none;
  box-shadow: none;
}

/* Improved status badges */
.batch-details-modal [role="status"] {
  transition: all 0.2s ease-out;
}

/* Loading state transitions */
.batch-details-modal .ant-spin {
  transition: opacity 0.2s ease-out;
}

/* Focus order improvements */
.batch-details-modal [tabindex]:not([tabindex="-1"]) {
  transition: box-shadow 0.2s ease-out;
}


File: src/assets/icons/history.svg

<svg  viewBox="0 0 12 2" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.25 2H0.75C0.3 2 0 1.6 0 1C0 0.4 0.3 0 0.75 0H11.25C11.7 0 12 0.4 12 1C12 1.6 11.7 2 11.25 2Z" fill="#F41111"/>
</svg>


File: src/api/client.ts
import {
  ApiClient,
  ClassificationResult,
  LlmConfig,
  UpdateConfigRequest, 
  ClassificationSystem,
  ClassificationLevel,
  Category,
  SystemCategoriesRequest,
  ClassificationHistoryRequest,
  ClassificationHistoryPage,
  BatchClassificationRequest,
  BatchClassificationResult,
  ManualClassificationRequest,
  BatchJobsPage,
  BatchJobParams,
  RagInfoItem,
  RagInfoPage,
  RagInfoRequestParams,
  CreateRagInfoRequest,
  UpdateRagInfoRequest,
  LoginResponse,
  User,
  UserListResponse,
  CreateUserRequest,
  UpdateUserRequest,
  RoleListResponse,
  CreateRoleRequest,
  UpdateRoleRequest,
  Role,
  PermissionListResponse,
} from './types';

import { ApiClientCore } from './core-client';
import { AuthService } from './auth.service';
import { UserService } from './user.service';
import { RoleService } from './role.service';
import { PermissionService } from './permission.service';
import { ClassificationService } from './classification.service';
import { BatchClassificationService } from './batch-classification.service';
import { SystemService } from './system.service';
import { ConfigService } from './config.service';
import { RagService } from './rag.service';
import { SnowService } from './snow.service'; // Import the new SnowService
import {
  SnowAnalyzeRequestFE,
  SnowAnalyzeResponseFE,
  SnowHistoryRequestParamsFE,
  SnowHistoryPageFE,
} from '../snow/types/snow.types'; // Import SNOW types

export class WebApiClient implements ApiClient {
  private core: ApiClientCore;
  private authService: AuthService;
  private userService: UserService;
  private roleService: RoleService;
  private permissionService: PermissionService;
  private classificationService: ClassificationService;
  private batchClassificationService: BatchClassificationService;
  private systemService: SystemService;
  private configService: ConfigService;
  private ragService: RagService;
  private snowService: SnowService; // Add SnowService instance

  constructor() {
    this.core = new ApiClientCore();
    this.authService = new AuthService(this.core);
    this.userService = new UserService(this.core);
    this.roleService = new RoleService(this.core);
    this.permissionService = new PermissionService(this.core);
    this.classificationService = new ClassificationService(this.core);
    this.batchClassificationService = new BatchClassificationService(this.core);
    this.systemService = new SystemService(this.core);
    this.configService = new ConfigService(this.core);
    this.ragService = new RagService(this.core);
    this.snowService = new SnowService(this.core); // Initialize SnowService
  }

  // Add generic HTTP methods delegating to ApiClientCore
  async get<T = any>(path: string, params?: Record<string, any>, config?: any): Promise<T> {
    return this.core.get<T>(path, params, config);
  }

  async post<T = any>(path: string, data?: any, config?: any): Promise<T> {
    return this.core.post<T>(path, data, config);
  }

  async put<T = any>(path: string, data?: any, config?: any): Promise<T> {
    return this.core.put<T>(path, data, config);
  }

  async delete<T = any>(path: string, config?: any): Promise<T> {
    return this.core.delete<T>(path, config);
  }

  // Initialize method now fetches auth config
  async initialize(): Promise<void> {
    await this.core.fetchAuthConfig();
  }

  // --- Delegate methods to services ---

  // Auth
  isLoggedIn(): boolean { return this.authService.isLoggedIn(); }
  isAuthEnabled(): boolean | null { return this.authService.isAuthEnabled(); }
  async login(username: string, password: string): Promise<LoginResponse> { return this.authService.login(username, password); }
  clearToken(): void { this.authService.clearToken(); }
  async getCurrentUser(): Promise<User> { return this.authService.getCurrentUser(); }

  // User Management
  async getUsers(params?: { limit?: number; offset?: number; search?: string }): Promise<UserListResponse> { return this.userService.getUsers(params); }
  async createUser(data: CreateUserRequest): Promise<User> { return this.userService.createUser(data); }
  async updateUser(id: number, data: UpdateUserRequest): Promise<User> { return this.userService.updateUser(id, data); }
  async deleteUser(id: number): Promise<void> { return this.userService.deleteUser(id); }
  async assignRolesToUser(userId: number, roleNames: string[]): Promise<void> { return this.userService.assignRolesToUser(userId, roleNames); }

  // Role Management
  async getRoles(params?: { limit?: number; offset?: number }): Promise<RoleListResponse> { return this.roleService.getRoles(params); }
  async createRole(data: CreateRoleRequest): Promise<Role> { return this.roleService.createRole(data); }
  async updateRole(id: number, data: UpdateRoleRequest): Promise<Role> { return this.roleService.updateRole(id, data); }
  async deleteRole(id: number): Promise<void> { return this.roleService.deleteRole(id); }

  // Permission Management
  async getPermissions(): Promise<PermissionListResponse> { return this.permissionService.getPermissions(); }

  // Classification
  async classify(description: string, systemCode?: string, additionalContext?: string, modelOverride?: string): Promise<ClassificationResult> { return this.classificationService.classify(description, systemCode, additionalContext, modelOverride); }
  async classifyManually(request: ManualClassificationRequest): Promise<ClassificationResult> { return this.classificationService.classifyManually(request); }
  async rerunClassification(id: string): Promise<ClassificationResult> { return this.classificationService.rerunClassification(id); }
  async deleteClassification(id: string): Promise<void> { return this.classificationService.deleteClassification(id); }
  async getClassificationHistory(req: ClassificationHistoryRequest): Promise<ClassificationHistoryPage> { return this.classificationService.getClassificationHistory(req); }
  async deleteClassificationHistory(id: string): Promise<void> { return this.classificationService.deleteClassificationHistory(id); }

  // Batch Classification
  async classifyBatch(request: BatchClassificationRequest): Promise<BatchClassificationResult> { return this.batchClassificationService.classifyBatch(request); }
  async getBatchStatus(batchId: string): Promise<BatchClassificationResult> { return this.batchClassificationService.getBatchStatus(batchId); }
  async getBatchJobs(params: BatchJobParams): Promise<BatchJobsPage> { return this.batchClassificationService.getBatchJobs(params); }

  // System
  async getClassificationSystems(): Promise<ClassificationSystem[]> { return this.systemService.getClassificationSystems(); }
  async getClassificationSystem(code: string): Promise<{ system: ClassificationSystem; levels: ClassificationLevel[] }> { return this.systemService.getClassificationSystem(code); }
  async getSystemCategories(req: SystemCategoriesRequest): Promise<Category[]> { return this.systemService.getSystemCategories(req); }

  // Config
  async getConfig(): Promise<LlmConfig & { ragEnabled?: boolean }> { return this.configService.getConfig(); }
  async updateConfig(configUpdate: UpdateConfigRequest): Promise<void> { 
    return this.configService.updateConfig(configUpdate); 
  }

  // RAG
  async getRagInfoList(params: RagInfoRequestParams): Promise<RagInfoPage> { return this.ragService.getRagInfoList(params); }
  async createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem> { return this.ragService.createRagInfo(data); }
  async getRagInfoItem(id: string): Promise<RagInfoItem> { return this.ragService.getRagInfoItem(id); }
  async updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem> { return this.ragService.updateRagInfo(id, data); }
  async deleteRagInfo(id: string): Promise<void> { return this.ragService.deleteRagInfo(id); }
  async getRagInfo(id: string): Promise<RagInfoItem> { return this.ragService.getRagInfo(id); } // Keep for compatibility
  async queryRag(question: string): Promise<any> { return this.ragService.queryRag(question); }

  // --- ServiceNow (SNOW) Analysis Methods ---
  async analyzeSnowTicket(ticketData: SnowAnalyzeRequestFE): Promise<SnowAnalyzeResponseFE> {
    return this.snowService.analyzeTicket(ticketData);
  }

  async getSnowHistory(params: SnowHistoryRequestParamsFE): Promise<SnowHistoryPageFE> {
    return this.snowService.getHistory(params);
  }

  async deleteSnowHistory(id: string): Promise<void> {
    return this.snowService.deleteHistory(id);
  }

  // For backward compatibility - fetch auth config (will eventually be removed)
  async fetchAuthConfig(): Promise<void> {
    return this.core.fetchAuthConfig();
  }
}


File: src/api/snow.service.ts
// src/api/snow.service.ts
import { API_ENDPOINTS } from '../config/api'; // Ensure API_ENDPOINTS is imported
import { ApiClientCore } from './core-client';
import {
  SnowAnalyzeRequestFE,
  SnowAnalyzeResponseFE,
  SnowHistoryRequestParamsFE,
  SnowHistoryPageFE,
} from '../snow/types/snow.types';

export class SnowService {
  constructor(private core: ApiClientCore) {}

  async analyzeTicket(ticketData: SnowAnalyzeRequestFE): Promise<SnowAnalyzeResponseFE> {
    const requestId = `snow-analyze-${Math.random().toString(36).substring(7)}`;
    console.log(`[${requestId}] SNOW: Analyzing ticket`);
    try {
      // Pass the base endpoint path from API_ENDPOINTS directly
      const response = await this.core.post<SnowAnalyzeResponseFE>(
        API_ENDPOINTS.snow.analyze, 
        ticketData
      );
      return response;
    } catch (error) {
      console.error(`[${requestId}] SNOW: Analyze ticket error:`, error);
      throw error;
    }
  }

  async getHistory(params: SnowHistoryRequestParamsFE): Promise<SnowHistoryPageFE> {
    const requestId = `snow-history-list-${Math.random().toString(36).substring(7)}`;
    console.log(`[${requestId}] SNOW: Fetching analysis history with params:`, params);
    
    try {
      // Pass the base endpoint path and params object directly to core.get
      // ApiClientCore's get method will handle calling formatEndpoint and appending query params.
      const response = await this.core.get<SnowHistoryPageFE>(API_ENDPOINTS.snow.history, params);
      
      const itemsWithFormattedDates = response.items.map(item => ({
        ...item,
        created_at: this.core.formatDate(item.created_at), // formatDate is a utility in ApiClientCore
      }));

      return { ...response, items: itemsWithFormattedDates };
    } catch (error) {
      console.error(`[${requestId}] SNOW: Get history error:`, error);
      throw error;
    }
  }

  async deleteHistory(id: string): Promise<void> {
    const requestId = `snow-history-delete-${Math.random().toString(36).substring(7)}`;
    console.log(`[${requestId}] SNOW: Deleting history item with ID: ${id}`);
    try {
      // Construct the path with the ID using API_ENDPOINTS
      const path = API_ENDPOINTS.snow.historyItem.replace('{id}', id);
      // Pass the constructed base path directly to core.delete
      await this.core.delete(path);
    } catch (error) {
      console.error(`[${requestId}] SNOW: Delete history error:`, error);
      throw error;
    }
  }
}

File: src/api/types.ts
// src/api/types.ts

// Status Types
export type ClassificationStatus = 'all' | 'success' | 'partial' | 'failed';
export type BatchStatus = 'pending' | 'processing' | 'completed' | 'error';
export type ClassificationSourceType = 'user' | 'batch' | 'api' | 'manual' | ''; // Allow empty for 'all'
export type BatchJobStatusFilterType = BatchStatus | 'all';

// API Client Interface
export interface ApiClient {
  // Generic HTTP methods
  get<T = any>(path: string, params?: Record<string, any>, config?: any): Promise<T>;
  post<T = any>(path: string, data?: any, config?: any): Promise<T>;
  put<T = any>(path: string, data?: any, config?: any): Promise<T>;
  delete<T = any>(path: string, config?: any): Promise<T>;

  // Authentication methods
  /**
   * Check if user is currently logged in
   * @returns boolean indicating login status
   */
  isLoggedIn(): boolean;

  /**
   * Check if authentication is enabled
   * @returns boolean indicating whether auth is enabled, or null if not determined yet
   */
  isAuthEnabled(): boolean | null;

  /**
   * Fetch authentication configuration from the server
   */
  fetchAuthConfig(): Promise<void>;

  /**
   * Log in a user
   * @param username - Username
   * @param password - Password
   */
  login(username: string, password: string): Promise<LoginResponse>;

  /**
   * Clear authentication token
   */
  clearToken(): void;

  /**
   * Get the current logged-in user's details
   */
  getCurrentUser(): Promise<User>;

  // --- User Management ---
  /**
   * Get a list of users
   * @param params - Optional parameters for pagination and searching
   */
  getUsers(params?: { limit?: number; offset?: number; search?: string }): Promise<UserListResponse>;
  
  /**
   * Create a new user
   * @param data - User creation data
   */
  createUser(data: CreateUserRequest): Promise<User>;
  
  /**
   * Update an existing user
   * @param id - User ID
   * @param data - User update data
   */
  updateUser(id: number, data: UpdateUserRequest): Promise<User>;
  
  /**
   * Delete a user
   * @param id - User ID
   */
  deleteUser(id: number): Promise<void>;
  
  /**
   * Assign roles to a user
   * @param userId - User ID
   * @param roleNames - Array of role names
   */
  assignRolesToUser(userId: number, roleNames: string[]): Promise<void>;

  // --- Role Management ---
  /**
   * Get a list of roles
   * @param params - Optional parameters for pagination
   */
  getRoles(params?: { limit?: number; offset?: number }): Promise<RoleListResponse>;
  
  /**
   * Create a new role
   * @param data - Role creation data
   */
  createRole(data: CreateRoleRequest): Promise<Role>;
  
  /**
   * Update an existing role
   * @param id - Role ID
   * @param data - Role update data
   */
  updateRole(id: number, data: UpdateRoleRequest): Promise<Role>;
  
  /**
   * Delete a role
   * @param id - Role ID
   */
  deleteRole(id: number): Promise<void>;

  // --- Permission Management ---
  /**
   * Get a list of all available permissions
   */
  getPermissions(): Promise<PermissionListResponse>;

  /** Initialize the API client */
  initialize(): Promise<void>;
  /**
   * Classify a description using AI
   * @param description - Text to classify
   * @param systemCode - Optional classification system code
   * @param additionalContext - Optional context for classification
   * @param modelOverride - Optional LLM model to use for this classification
   */
  classify(
    description: string,
    systemCode?: string,
    additionalContext?: string,
    modelOverride?: string
  ): Promise<ClassificationResult>;

  /**
   * Manually classify a description
   * @param request - Manual classification request
   */
  classifyManually(
    request: ManualClassificationRequest
  ): Promise<ClassificationResult>;

  /**
   * Classify multiple items in batch
   * @param request - Batch classification request
   */
  classifyBatch(
    request: BatchClassificationRequest
  ): Promise<BatchClassificationResult>;

  /**
   * Get status of a batch classification
   * @param batchId - ID of the batch
   */
  getBatchStatus(
    batchId: string
  ): Promise<BatchClassificationResult>;

  /** Get all classification systems */
  getClassificationSystems(): Promise<ClassificationSystem[]>;

  /**
   * Get a specific classification system with its levels
   * @param code - System code
   */
  getClassificationSystem(code: string): Promise<{
    system: ClassificationSystem;
    levels: ClassificationLevel[];
  }>;

  /**
   * Get categories for a system level
   * @param req - System categories request
   */
  getSystemCategories(
    req: SystemCategoriesRequest
  ): Promise<Category[]>;

  /**
   * Get classification history
   * @param req - History request parameters
   */
  getClassificationHistory(
    req: ClassificationHistoryRequest
  ): Promise<ClassificationHistoryPage>;

  /** Get current LLM configuration */
  getConfig(): Promise<LlmConfig>;

  /**
   * Update LLM configuration
   * @param config - New configuration
   */
  updateConfig(config: UpdateConfigRequest): Promise<void>;

  /** rerun classification for a specific history entry
   * @param id - ID of the classification history entry
  */
  rerunClassification(id: string): Promise<ClassificationResult>; // id should likely be string or number, consistent with HistoryTab

  /** delete a classification history entry
   * @param id - ID of the classification history entry
  */
  deleteClassification(id: string): Promise<void>; // id should likely be string or number

  getBatchJobs(params: BatchJobParams): Promise<BatchJobsPage>;
  /** Get a paginated list of RAG information entries */

  getRagInfoList(params: RagInfoRequestParams): Promise<RagInfoPage>;

  /** Create a new RAG information entry */
  createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem>;

  /** Get a specific RAG information entry by ID */
  getRagInfoItem(id: string): Promise<RagInfoItem>; // Added for editing

  /** Update a RAG information entry by ID */
  updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem>;

  /** Delete a RAG information entry by ID */
  deleteRagInfo(id: string): Promise<void>;

  /**
   * Delete a classification history entry
   * @param id - ID of the classification history entry
   */
  deleteClassificationHistory(id: string): Promise<void>;

  // --- RAG Information Management ---
  /**
   * Get a list of RAG information items
   * @param params - Optional parameters for pagination and searching
   */
  // getRagInfoList(params?: RagInfoRequestParams): Promise<RagInfoPage>; // Already declared above

  /**
   * Get a specific RAG information item
   * @param id - RAG information item ID
   */
  getRagInfo(id: string): Promise<RagInfoItem>;

  /**
   * Create a new RAG information item
   * @param data - RAG information creation data
   */
  // createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem>; // Already declared above

  /**
   * Update an existing RAG information item
   * @param id - RAG information item ID
   * @param data - RAG information update data
   */
  // updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem>; // Already declared above

  /**
   * Delete a RAG information item
   * @param id - RAG information item ID
   */
  // deleteRagInfo(id: string): Promise<void>; // Already declared above

  /** Get current configuration */
  // getConfig(): Promise<LlmConfig>; // Already declared above

  /** Update configuration */
  // updateConfig(configUpdate: UpdateConfigRequest): Promise<void>; // Already declared above

   /**
   * Query RAG for context (used by internal services, might not be exposed to UI directly)
   * @param question - The query string
   */
   queryRag(question: string): Promise<any>; // Define 'any' for now, can be more specific if response structure is known

  // Generic HTTP methods that should be implemented by the concrete ApiClient
  // get<T>(url: string, config?: any): Promise<T>;
  // post<T>(url: string, data?: any, config?: any): Promise<T>;
  // put<T>(url: string, data?: any, config?: any): Promise<T>;
  // delete<T>(url: string, config?: any): Promise<T>;
}

// --- RAG Information Types ---

export interface RagInfoItem {
  id: string; // Or number, depending on backend
  key: string;
  description: string;
  createdAt: string; // ISO Date string
  updatedAt: string; // ISO Date string
}

export interface RagInfoPage {
  items: RagInfoItem[];
  totalCount: number;
  totalPages: number;
  currentPage: number;
}

export interface RagInfoRequestParams {
  page?: number;
  limit?: number;
  search?: string; // Filter by key or description
}

export interface CreateRagInfoRequest {
  key: string;
  description: string;
}

export interface UpdateRagInfoRequest {
  key?: string; // Optional: Allow updating key? Decide based on backend
  description?: string;
}

// Authentication Types
export interface LoginResponse {
  token: string;
  user: User;
}

export interface User {
  id: number;
  username: string;
  roles: string[];      // Array of role names
  permissions?: string[]; // Array of permission codes (calculated on backend)
  createdAt?: string;
  updatedAt?: string;
}

// RBAC Types
export interface Role {
  id: number;
  name: string;
  description?: string;
  permissions?: Permission[]; // Permissions associated with the role
}

export interface Permission {
  id: number;
  code: string;          // e.g., 'users:manage', 'classify:item'
  description?: string;
}

// Request/Response for User Management
export interface UserListResponse {
  items: User[];
  totalCount: number;
  // Add pagination if needed
}

export interface CreateUserRequest {
  username: string;
  password?: string; // Required on create
  roles: string[]; // Assign roles by name
}

export interface UpdateUserRequest {
  username?: string; // Optional update
  password?: string; // Optional: For password change
  roles?: string[];  // Optional: For updating roles
}

// Request/Response for Role Management
export interface RoleListResponse {
  items: Role[];
  totalCount: number;
}

export interface CreateRoleRequest {
  name: string;
  description?: string;
  permissions: string[]; // Assign permissions by code
}

export interface UpdateRoleRequest {
  name?: string;
  description?: string;
  permissions?: string[];
}

// Request/Response for Permissions (likely just GET list)
export interface PermissionListResponse {
  items: Permission[];
  totalCount: number;
}

// Configuration Types
export interface LlmConfig {
  server?: {
    host: string;
    port: number;
    requestTimeout: string;
    logLevel: string;
  };  service?: {
    batchSize: number;
    dataPath: string;
    commonDataPath: string;
    excelPattern: string;
    llmEndpoint: string;
    llmApiKey: string;
    llmModel: string;
    llmRetryModels?: string[];
    llmMaxTokens: number;
    llmTemperature: number;
    useTypePrompt: boolean;
    maxSkipLogs: number;
    unspscExcelLoader: {
      filePath: string;
      sheetName: string;
      levelHeaders: Array<{
        dbLevelCode: string;
        codeHeader: string;
        titleHeader: string;
      }>;
    };
    commonExcelLoader: {
      filePath: string;
      sheetName: string;
      level1HeaderName: string;
    };
  };
  database?: {
    host: string;
    port: number;
    user: string;
    password: string;
    name: string;
    dataPath: string;
    ragServiceUrl: string;
    ragEnabled: boolean;
    ragManualInfoCollection: string;
    ragUnspscCollection: string;
    ragCommonCollection: string;
  };
  validation?: {
    maxHistoryLimit: number;
    tokenLimit: number;
    defaultTimeout: string;
  };
  alert?: {
    emailSettings: {
      smtpHost: string;
      smtpPort: number;
      smtpUser: string;
      smtpPassword: string;
      fromEmail: string;
    };
    webhookSettings: {
      url: string;
    };
  };
  
  auth?: {
    enabled: boolean;
    jwtSecret: string;
    jwtExpirationHours: number; 
    initialAdminUser: string;
    initialAdminPassword?: string;
  };
  
  // Keep these for backward compatibility
  llmEndpoint?: string;
  llmApiKey?: string;
  ragEnabled?: boolean;
}

// --- Helper types for config update API ---
// These types provide structure for the update API but don't replace the main LlmConfig interface

export interface UpdateServerConfig {
  logLevel?: string;
  requestTimeout?: string; // e.g., "60s"
}

export interface UpdateServiceConfig {
  llmEndpoint?: string;
  llmApiKey?: string; // Allow sending new key, BEWARE: sent in plain text
  llmModel?: string;
  llmRetryModels?: string[];
  llmMaxTokens?: number;
  llmTemperature?: number;
  useTypePrompt?: boolean;
  maxSkipLogs?: number;
}

export interface UpdateDatabaseConfig {
  ragEnabled?: boolean;
  ragServiceUrl?: string;
  ragManualInfoCollection?: string;
  ragUnspscCollection?: string;
  ragCommonCollection?: string;
}

export interface UpdateValidationConfig {
  maxHistoryLimit?: number;
  tokenLimit?: number;
  defaultTimeout?: string; // e.g., "15s"
}

export interface UpdateEmailSettings {
  smtpHost?: string;
  smtpPort?: number;
  smtpUser?: string;
  smtpPassword?: string; // Allow sending new password, BEWARE: sent in plain text
  fromEmail?: string;
}

export interface UpdateWebhookSettings {
  url?: string;
}

export interface UpdateAlertConfig {
  emailSettings?: UpdateEmailSettings;
  webhookSettings?: UpdateWebhookSettings;
}

export interface UpdateAuthConfig {
  enabled?: boolean;
  jwtExpirationHours?: number;
}

// Main Update Request Payload structure
export interface UpdateConfigRequest {
  server?: UpdateServerConfig;
  service?: UpdateServiceConfig;
  database?: UpdateDatabaseConfig;
  validation?: UpdateValidationConfig;
  alert?: UpdateAlertConfig;
  auth?: UpdateAuthConfig;
}

// --- Ensure LlmConfig Interface is up-to-date ---
export interface ServerConfig {
  host?: string;
  port?: number;
  requestTimeout?: string;
  logLevel?: string;
}

export interface LevelHeaderPair {
  dbLevelCode?: string;
  codeHeader?: string;
  titleHeader?: string;
}

export interface UnspscExcelLoaderConfig {
  filePath?: string;
  sheetName?: string;
  levelHeaders?: LevelHeaderPair[];
}

export interface CommonExcelLoaderConfig {
  filePath?: string;
  sheetName?: string;
  level1HeaderName?: string;
}

export interface ServiceConfig {
  batchSize?: number;
  dataPath?: string;
  commonDataPath?: string;
  excelPattern?: string;
  llmEndpoint?: string;
  llmApiKey?: string; // Expect "[REDACTED]" or similar mask from GET
  llmModel?: string;
  llmRetryModels?: string[];
  llmMaxTokens?: number;
  llmTemperature?: number;
  useTypePrompt?: boolean;
  maxSkipLogs?: number;
  batchRetryLimit?: number;
  unspscExcelLoader?: UnspscExcelLoaderConfig;
  commonExcelLoader?: CommonExcelLoaderConfig;
}

export interface DatabaseConfig {
  host?: string;
  port?: number;
  user?: string;
  password?: string; // Expect "[REDACTED]"
  name?: string;
  dataPath?: string;
  ragServiceUrl?: string;
  ragEnabled?: boolean;
  ragManualInfoCollection?: string;
  ragUnspscCollection?: string;
  ragCommonCollection?: string;
}

export interface ValidationConfig {
  maxHistoryLimit?: number;
  tokenLimit?: number;
  defaultTimeout?: string;
}

export interface EmailSettings {
  smtpHost?: string;
  smtpPort?: number;
  smtpUser?: string;
  smtpPassword?: string; // Expect "[REDACTED]"
  fromEmail?: string;
}

export interface WebhookSettings {
  url?: string;
}

export interface AlertConfig {
  emailSettings?: EmailSettings;
  webhookSettings?: WebhookSettings;
}

export interface AuthConfig {
  enabled?: boolean;
  jwtSecret?: string; // Expect "[REDACTED]"
  jwtExpirationHours?: number;
  initialAdminUser?: string;
  initialAdminPassword?: string; // Expect "[REDACTED]"
}

// Core Domain Types
export interface ClassificationSystem {
  id: number;
  code: string;
  name: string;
  description?: string;
  enabled: boolean;
  createdAt: string;
}

export interface ClassificationLevel {
  id: number;
  systemId: number; 
  levelNumber: number; 
  code: string;
  name: string;
  description?: string;
  validationRegex?: string; 
}

export interface Category {
  id: number;
  systemId: number;
  code: string;
  name: string;
  description?: string;
  levelCode: string; 
  parentCode?: string;
  createdAt: string;
}

export interface CategoryLevel {
  code: string;
  name: string;
  description?: string;
  error?: string;
}

// Classification Types
export interface ClassificationResult {
  system_code: string;
  description: string;
  levels: { [key: string]: CategoryLevel }; // key is level_code
  status: 'success' | 'failed' | 'partial';
  error?: string;
  timestamp: string; // ISO Date string
  ragContextUsed: boolean;
  ragContext?: string;
  levelResponses?: { [key: string]: string }; // Level-specific LLM responses
  firstLevelPrompt?: string; // Renamed from prompt to match backend changes
  allPromptsDetail?: string; // JSON string of all prompts
  modelUsed?: string;
}

export interface ClassificationError {
  message: string;
  code?: string;
  level?: string;
}

// Request Types
export interface ClassificationRequest {
  ItemID?: string; // Changed from item_id to ItemID
  Name?: string;   // Changed from name to Name
  description: string;
  systemCode?: string; // Changed from system_code to systemCode
  additionalContext?: string; // Changed from additional_context to additionalContext
  levels?: { [key: string]: string }; // For manual classification
  IsManual?: boolean; // Changed from is_manual to IsManual
  key?: string; // Unique key identifier for the item
}

export interface ManualClassificationRequest {
  description: string;
  systemCode: string;
  selectedSystem?: string; // Optional based on your backend expectation, usually same as systemCode
  additionalContext?: string;
  modelOverride?: string; // Optional LLM model override for classification
  levels: { [levelCode: string]: string };
}

export interface SystemCategoriesRequest {
  systemCode: string;
  level: string;
  parentCode?: string;
  search?: string;
}

export interface BatchClassificationRequest {
  items: Array<{
    description: string;
    additionalContext?: string;
    key?: string; // Include key field to identify batch items
  }>;
  systemCode?: string; // Changed from system_code to systemCode
  key_column_names?: string[]; 
}

// Response Types
export interface BatchClassificationResult {
  results?: BatchItemResult[]; 
  id: string;
  status: string;
  timestamp: string;
  Results?: BatchItemResult[]; // Kept for backward compatibility if backend sends this casing
  error?: string;
  system_code?: string;  
  updated_at?: string;
  totalItems?: number; 
  processedItems?: number; 
  keyColumnNames?: string[]; 
  systemCode?: string; 
}

export interface BatchItemResult {
  description: string;
  additional_context?: string;
  result?: ClassificationResult;
  error?: string | ClassificationError; 
  key?: string; 
  prompt?: string; // This is likely the first-level prompt used for this item
  allPromptsDetail?: string; // This is the JSON string of all prompts for this item
}

export interface BatchJobParams {
  cursor?: string;
  limit?: number;
  status?: string;
  startDate?: string; 
  endDate?: string;   
}

export interface BatchJobsPage {
  items: BatchClassificationResult[];
  totalCount: number;
  nextCursor?: string;
}

// History Types
export interface ClassificationHistory {
  id: number; 
  description: string;
  systemCode: string;
  additionalContext?: string;
  levels: { [key: string]: CategoryLevel };
  createdAt: string; 
  status: 'success' | 'failed' | 'partial';
  createdBy: string;
  sourceType: 'user' | 'batch' | 'manual' | 'api';
  ragContextUsed: boolean;
  ragContext?: string;
  error?: string;
  levelResponses?: { [key: string]: string }; 
  firstLevelPrompt?: string; // Renamed from prompt
  key?: string; 
  allPromptsDetail?: string; // JSON string of all prompts
  modelUsed?: string; 
}

export interface ClassificationHistoryPage {
  items: ClassificationHistory[];
  totalCount: number;
  nextCursor?: string;
}

// Request parameters for fetching classification history
export interface ClassificationHistoryRequest {
  systemCode?: string;
  limit?: number;
  cursor?: string;
  status?: string;
  startDate?: string;
  endDate?: string;
  search?: string; 
  sourceType?: string;
  createdBy?: string;
}

// Status Types - Defined earlier in this file, don't duplicate them here
// These types are defined at the end of the file

import {
  SnowAnalyzeRequestFE,
  SnowAnalyzeResponseFE,
  SnowHistoryRequestParamsFE,
  SnowHistoryPageFE,
} from '../snow/types/snow.types'; // Path to your new SNOW types

// --- API Client Interface ---
export interface ApiClient {
  // Generic HTTP methods
  get<T = any>(path: string, params?: Record<string, any>, config?: any): Promise<T>;
  post<T = any>(path: string, data?: any, config?: any): Promise<T>;
  put<T = any>(path: string, data?: any, config?: any): Promise<T>;
  delete<T = any>(path: string, config?: any): Promise<T>;

  // Authentication methods
  /**
   * Check if user is currently logged in
   * @returns boolean indicating login status
   */
  isLoggedIn(): boolean;

  /**
   * Check if authentication is enabled
   * @returns boolean indicating whether auth is enabled, or null if not determined yet
   */
  isAuthEnabled(): boolean | null;

  /**
   * Fetch authentication configuration from the server
   */
  fetchAuthConfig(): Promise<void>;

  /**
   * Log in a user
   * @param username - Username
   * @param password - Password
   */
  login(username: string, password: string): Promise<LoginResponse>;

  /**
   * Clear authentication token
   */
  clearToken(): void;

  /**
   * Get the current logged-in user's details
   */
  getCurrentUser(): Promise<User>;

  // --- User Management ---
  /**
   * Get a list of users
   * @param params - Optional parameters for pagination and searching
   */
  getUsers(params?: { limit?: number; offset?: number; search?: string }): Promise<UserListResponse>;
  
  /**
   * Create a new user
   * @param data - User creation data
   */
  createUser(data: CreateUserRequest): Promise<User>;
  
  /**
   * Update an existing user
   * @param id - User ID
   * @param data - User update data
   */
  updateUser(id: number, data: UpdateUserRequest): Promise<User>;
  
  /**
   * Delete a user
   * @param id - User ID
   */
  deleteUser(id: number): Promise<void>;
  
  /**
   * Assign roles to a user
   * @param userId - User ID
   * @param roleNames - Array of role names
   */
  assignRolesToUser(userId: number, roleNames: string[]): Promise<void>;

  // --- Role Management ---
  /**
   * Get a list of roles
   * @param params - Optional parameters for pagination
   */
  getRoles(params?: { limit?: number; offset?: number }): Promise<RoleListResponse>;
  
  /**
   * Create a new role
   * @param data - Role creation data
   */
  createRole(data: CreateRoleRequest): Promise<Role>;
  
  /**
   * Update an existing role
   * @param id - Role ID
   * @param data - Role update data
   */
  updateRole(id: number, data: UpdateRoleRequest): Promise<Role>;
  
  /**
   * Delete a role
   * @param id - Role ID
   */
  deleteRole(id: number): Promise<void>;

  // --- Permission Management ---
  /**
   * Get a list of all available permissions
   */
  getPermissions(): Promise<PermissionListResponse>;

  /** Initialize the API client */
  initialize(): Promise<void>;
  /**
   * Classify a description using AI
   * @param description - Text to classify
   * @param systemCode - Optional classification system code
   * @param additionalContext - Optional context for classification
   * @param modelOverride - Optional LLM model to use for this classification
   */
  classify(
    description: string,
    systemCode?: string,
    additionalContext?: string,
    modelOverride?: string
  ): Promise<ClassificationResult>;

  /**
   * Manually classify a description
   * @param request - Manual classification request
   */
  classifyManually(
    request: ManualClassificationRequest
  ): Promise<ClassificationResult>;

  /**
   * Classify multiple items in batch
   * @param request - Batch classification request
   */
  classifyBatch(
    request: BatchClassificationRequest
  ): Promise<BatchClassificationResult>;

  /**
   * Get status of a batch classification
   * @param batchId - ID of the batch
   */
  getBatchStatus(
    batchId: string
  ): Promise<BatchClassificationResult>;

  /** Get all classification systems */
  getClassificationSystems(): Promise<ClassificationSystem[]>;

  /**
   * Get a specific classification system with its levels
   * @param code - System code
   */
  getClassificationSystem(code: string): Promise<{
    system: ClassificationSystem;
    levels: ClassificationLevel[];
  }>;

  /**
   * Get categories for a system level
   * @param req - System categories request
   */
  getSystemCategories(
    req: SystemCategoriesRequest
  ): Promise<Category[]>;

  /**
   * Get classification history
   * @param req - History request parameters
   */
  getClassificationHistory(
    req: ClassificationHistoryRequest
  ): Promise<ClassificationHistoryPage>;

  /** Get current LLM configuration */
  getConfig(): Promise<LlmConfig>;

  /**
   * Update LLM configuration
   * @param config - New configuration
   */
  updateConfig(config: UpdateConfigRequest): Promise<void>;

  /** rerun classification for a specific history entry
   * @param id - ID of the classification history entry
  */
  rerunClassification(id: string): Promise<ClassificationResult>; // id should likely be string or number, consistent with HistoryTab

  /** delete a classification history entry
   * @param id - ID of the classification history entry
  */
  deleteClassification(id: string): Promise<void>; // id should likely be string or number

  getBatchJobs(params: BatchJobParams): Promise<BatchJobsPage>;
  /** Get a paginated list of RAG information entries */

  getRagInfoList(params: RagInfoRequestParams): Promise<RagInfoPage>;

  /** Create a new RAG information entry */
  createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem>;

  /** Get a specific RAG information entry by ID */
  getRagInfoItem(id: string): Promise<RagInfoItem>; // Added for editing

  /** Update a RAG information entry by ID */
  updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem>;

  /** Delete a RAG information entry by ID */
  deleteRagInfo(id: string): Promise<void>;

  /**
   * Delete a classification history entry
   * @param id - ID of the classification history entry
   */
  deleteClassificationHistory(id: string): Promise<void>;

  // --- RAG Information Management ---
  /**
   * Get a list of RAG information items
   * @param params - Optional parameters for pagination and searching
   */
  // getRagInfoList(params?: RagInfoRequestParams): Promise<RagInfoPage>; // Already declared above

  /**
   * Get a specific RAG information item
   * @param id - RAG information item ID
   */
  getRagInfo(id: string): Promise<RagInfoItem>;

  /**
   * Create a new RAG information item
   * @param data - RAG information creation data
   */
  // createRagInfo(data: CreateRagInfoRequest): Promise<RagInfoItem>; // Already declared above

  /**
   * Update an existing RAG information item
   * @param id - RAG information item ID
   * @param data - RAG information update data
   */
  // updateRagInfo(id: string, data: UpdateRagInfoRequest): Promise<RagInfoItem>; // Already declared above

  /**
   * Delete a RAG information item
   * @param id - RAG information item ID
   */
  // deleteRagInfo(id: string): Promise<void>; // Already declared above

  /** Get current configuration */
  // getConfig(): Promise<LlmConfig>; // Already declared above

  /** Update configuration */
  // updateConfig(configUpdate: UpdateConfigRequest): Promise<void>; // Already declared above

   /**
   * Query RAG for context (used by internal services, might not be exposed to UI directly)
   * @param question - The query string
   */
   queryRag(question: string): Promise<any>; // Define 'any' for now, can be more specific if response structure is known

  // Generic HTTP methods that should be implemented by the concrete ApiClient
  // get<T>(url: string, config?: any): Promise<T>;
  // post<T>(url: string, data?: any, config?: any): Promise<T>;
  // put<T>(url: string, data?: any, config?: any): Promise<T>;
  // delete<T>(url: string, config?: any): Promise<T>;

  // --- ServiceNow (SNOW) Analysis Methods ---
  analyzeSnowTicket(ticketData: SnowAnalyzeRequestFE): Promise<SnowAnalyzeResponseFE>;
  getSnowHistory(params: SnowHistoryRequestParamsFE): Promise<SnowHistoryPageFE>;
  deleteSnowHistory(id: string): Promise<void>;
}

// --- RAG Information Types ---

export interface RagInfoItem {
  id: string; // Or number, depending on backend
  key: string;
  description: string;
  createdAt: string; // ISO Date string
  updatedAt: string; // ISO Date string
}

export interface RagInfoPage {
  items: RagInfoItem[];
  totalCount: number;
  totalPages: number;
  currentPage: number;
}

export interface RagInfoRequestParams {
  page?: number;
  limit?: number;
  search?: string; // Filter by key or description
}

export interface CreateRagInfoRequest {
  key: string;
  description: string;
}

export interface UpdateRagInfoRequest {
  key?: string; // Optional: Allow updating key? Decide based on backend
  description?: string;
}

// Authentication Types
export interface LoginResponse {
  token: string;
  user: User;
}

export interface User {
  id: number;
  username: string;
  roles: string[];      // Array of role names
  permissions?: string[]; // Array of permission codes (calculated on backend)
  createdAt?: string;
  updatedAt?: string;
}

// RBAC Types
export interface Role {
  id: number;
  name: string;
  description?: string;
  permissions?: Permission[]; // Permissions associated with the role
}

export interface Permission {
  id: number;
  code: string;          // e.g., 'users:manage', 'classify:item'
  description?: string;
}

// Request/Response for User Management
export interface UserListResponse {
  items: User[];
  totalCount: number;
  // Add pagination if needed
}

export interface CreateUserRequest {
  username: string;
  password?: string; // Required on create
  roles: string[]; // Assign roles by name
}

export interface UpdateUserRequest {
  username?: string; // Optional update
  password?: string; // Optional: For password change
  roles?: string[];  // Optional: For updating roles
}

// Request/Response for Role Management
export interface RoleListResponse {
  items: Role[];
  totalCount: number;
}

export interface CreateRoleRequest {
  name: string;
  description?: string;
  permissions: string[]; // Assign permissions by code
}

export interface UpdateRoleRequest {
  name?: string;
  description?: string;
  permissions?: string[];
}

// Request/Response for Permissions (likely just GET list)
export interface PermissionListResponse {
  items: Permission[];
  totalCount: number;
}

// Configuration Types
export interface LlmConfig {
  server?: {
    host: string;
    port: number;
    requestTimeout: string;
    logLevel: string;
  };  service?: {
    batchSize: number;
    dataPath: string;
    commonDataPath: string;
    excelPattern: string;
    llmEndpoint: string;
    llmApiKey: string;
    llmModel: string;
    llmRetryModels?: string[];
    llmMaxTokens: number;
    llmTemperature: number;
    useTypePrompt: boolean;
    maxSkipLogs: number;
    unspscExcelLoader: {
      filePath: string;
      sheetName: string;
      levelHeaders: Array<{
        dbLevelCode: string;
        codeHeader: string;
        titleHeader: string;
      }>;
    };
    commonExcelLoader: {
      filePath: string;
      sheetName: string;
      level1HeaderName: string;
    };
  };
  database?: {
    host: string;
    port: number;
    user: string;
    password: string;
    name: string;
    dataPath: string;
    ragServiceUrl: string;
    ragEnabled: boolean;
    ragManualInfoCollection: string;
    ragUnspscCollection: string;
    ragCommonCollection: string;
  };
  validation?: {
    maxHistoryLimit: number;
    tokenLimit: number;
    defaultTimeout: string;
  };
  alert?: {
    emailSettings: {
      smtpHost: string;
      smtpPort: number;
      smtpUser: string;
      smtpPassword: string;
      fromEmail: string;
    };
    webhookSettings: {
      url: string;
    };
  };
  
  auth?: {
    enabled: boolean;
    jwtSecret: string;
    jwtExpirationHours: number; 
    initialAdminUser: string;
    initialAdminPassword?: string;
  };
  
  // Keep these for backward compatibility
  llmEndpoint?: string;
  llmApiKey?: string;
  ragEnabled?: boolean;
}

// --- Helper types for config update API ---
// These types provide structure for the update API but don't replace the main LlmConfig interface

export interface UpdateServerConfig {
  logLevel?: string;
  requestTimeout?: string; // e.g., "60s"
}

export interface UpdateServiceConfig {
  llmEndpoint?: string;
  llmApiKey?: string; // Allow sending new key, BEWARE: sent in plain text
  llmModel?: string;
  llmRetryModels?: string[];
  llmMaxTokens?: number;
  llmTemperature?: number;
  useTypePrompt?: boolean;
  maxSkipLogs?: number;
}

export interface UpdateDatabaseConfig {
  ragEnabled?: boolean;
  ragServiceUrl?: string;
  ragManualInfoCollection?: string;
  ragUnspscCollection?: string;
  ragCommonCollection?: string;
}

export interface UpdateValidationConfig {
  maxHistoryLimit?: number;
  tokenLimit?: number;
  defaultTimeout?: string; // e.g., "15s"
}

export interface UpdateEmailSettings {
  smtpHost?: string;
  smtpPort?: number;
  smtpUser?: string;
  smtpPassword?: string; // Allow sending new password, BEWARE: sent in plain text
  fromEmail?: string;
}

export interface UpdateWebhookSettings {
  url?: string;
}

export interface UpdateAlertConfig {
  emailSettings?: UpdateEmailSettings;
  webhookSettings?: UpdateWebhookSettings;
}

export interface UpdateAuthConfig {
  enabled?: boolean;
  jwtExpirationHours?: number;
}

// Main Update Request Payload structure
export interface UpdateConfigRequest {
  server?: UpdateServerConfig;
  service?: UpdateServiceConfig;
  database?: UpdateDatabaseConfig;
  validation?: UpdateValidationConfig;
  alert?: UpdateAlertConfig;
  auth?: UpdateAuthConfig;
}

// --- Ensure LlmConfig Interface is up-to-date ---
export interface ServerConfig {
  host?: string;
  port?: number;
  requestTimeout?: string;
  logLevel?: string;
}

export interface LevelHeaderPair {
  dbLevelCode?: string;
  codeHeader?: string;
  titleHeader?: string;
}

export interface UnspscExcelLoaderConfig {
  filePath?: string;
  sheetName?: string;
  levelHeaders?: LevelHeaderPair[];
}

export interface CommonExcelLoaderConfig {
  filePath?: string;
  sheetName?: string;
  level1HeaderName?: string;
}

export interface ServiceConfig {
  batchSize?: number;
  dataPath?: string;
  commonDataPath?: string;
  excelPattern?: string;
  llmEndpoint?: string;
  llmApiKey?: string; // Expect "[REDACTED]" or similar mask from GET
  llmModel?: string;
  llmRetryModels?: string[];
  llmMaxTokens?: number;
  llmTemperature?: number;
  useTypePrompt?: boolean;
  maxSkipLogs?: number;
  batchRetryLimit?: number;
  unspscExcelLoader?: UnspscExcelLoaderConfig;
  commonExcelLoader?: CommonExcelLoaderConfig;
}

export interface DatabaseConfig {
  host?: string;
  port?: number;
  user?: string;
  password?: string; // Expect "[REDACTED]"
  name?: string;
  dataPath?: string;
  ragServiceUrl?: string;
  ragEnabled?: boolean;
  ragManualInfoCollection?: string;
  ragUnspscCollection?: string;
  ragCommonCollection?: string;
}

export interface ValidationConfig {
  maxHistoryLimit?: number;
  tokenLimit?: number;
  defaultTimeout?: string;
}

export interface EmailSettings {
  smtpHost?: string;
  smtpPort?: number;
  smtpUser?: string;
  smtpPassword?: string; // Expect "[REDACTED]"
  fromEmail?: string;
}

export interface WebhookSettings {
  url?: string;
}

export interface AlertConfig {
  emailSettings?: EmailSettings;
  webhookSettings?: WebhookSettings;
}

export interface AuthConfig {
  enabled?: boolean;
  jwtSecret?: string; // Expect "[REDACTED]"
  jwtExpirationHours?: number;
  initialAdminUser?: string;
  initialAdminPassword?: string; // Expect "[REDACTED]"
}

// Core Domain Types
export interface ClassificationSystem {
  id: number;
  code: string;
  name: string;
  description?: string;
  enabled: boolean;
  createdAt: string;
}

export interface ClassificationLevel {
  id: number;
  systemId: number; 
  levelNumber: number; 
  code: string;
  name: string;
  description?: string;
  validationRegex?: string; 
}

export interface Category {
  id: number;
  systemId: number;
  code: string;
  name: string;
  description?: string;
  levelCode: string; 
  parentCode?: string;
  createdAt: string;
}

export interface CategoryLevel {
  code: string;
  name: string;
  description?: string;
  error?: string;
}

// Classification Types
export interface ClassificationResult {
  system_code: string;
  description: string;
  levels: { [key: string]: CategoryLevel }; // key is level_code
  status: 'success' | 'failed' | 'partial';
  error?: string;
  timestamp: string; // ISO Date string
  ragContextUsed: boolean;
  ragContext?: string;
  levelResponses?: { [key: string]: string }; // Level-specific LLM responses
  firstLevelPrompt?: string; // Renamed from prompt to match backend changes
  allPromptsDetail?: string; // JSON string of all prompts
  modelUsed?: string;
}

export interface ClassificationError {
  message: string;
  code?: string;
  level?: string;
}

// Request Types
export interface ClassificationRequest {
  ItemID?: string; // Changed from item_id to ItemID
  Name?: string;   // Changed from name to Name
  description: string;
  systemCode?: string; // Changed from system_code to systemCode
  additionalContext?: string; // Changed from additional_context to additionalContext
  levels?: { [key: string]: string }; // For manual classification
  IsManual?: boolean; // Changed from is_manual to IsManual
  key?: string; // Unique key identifier for the item
}

export interface ManualClassificationRequest {
  description: string;
  systemCode: string;
  selectedSystem?: string; // Optional based on your backend expectation, usually same as systemCode
  additionalContext?: string;
  modelOverride?: string; // Optional LLM model override for classification
  levels: { [levelCode: string]: string };
}

export interface SystemCategoriesRequest {
  systemCode: string;
  level: string;
  parentCode?: string;
  search?: string;
}

export interface BatchClassificationRequest {
  items: Array<{
    description: string;
    additionalContext?: string;
    key?: string; // Include key field to identify batch items
  }>;
  systemCode?: string; // Changed from system_code to systemCode
  key_column_names?: string[]; 
}

// Response Types
export interface BatchClassificationResult {
  results?: BatchItemResult[]; 
  id: string;
  status: string;
  timestamp: string;
  Results?: BatchItemResult[]; // Kept for backward compatibility if backend sends this casing
  error?: string;
  system_code?: string;  
  updated_at?: string;
  totalItems?: number; 
  processedItems?: number; 
  keyColumnNames?: string[]; 
  systemCode?: string; 
}

export interface BatchItemResult {
  description: string;
  additional_context?: string;
  result?: ClassificationResult;
  error?: string | ClassificationError; 
  key?: string; 
  prompt?: string; // This is likely the first-level prompt used for this item
  allPromptsDetail?: string; // This is the JSON string of all prompts for this item
}

export interface BatchJobParams {
  cursor?: string;
  limit?: number;
  status?: string;
  startDate?: string; 
  endDate?: string;   
}

export interface BatchJobsPage {
  items: BatchClassificationResult[];
  totalCount: number;
  nextCursor?: string;
}

// History Types
export interface ClassificationHistory {
  id: number; 
  description: string;
  systemCode: string;
  additionalContext?: string;
  levels: { [key: string]: CategoryLevel };
  createdAt: string; 
  status: 'success' | 'failed' | 'partial';
  createdBy: string;
  sourceType: 'user' | 'batch' | 'manual' | 'api';
  ragContextUsed: boolean;
  ragContext?: string;
  error?: string;
  levelResponses?: { [key: string]: string }; 
  firstLevelPrompt?: string; // Renamed from prompt
  key?: string; 
  allPromptsDetail?: string; // JSON string of all prompts
  modelUsed?: string; 
}

export interface ClassificationHistoryPage {
  items: ClassificationHistory[];
  totalCount: number;
  nextCursor?: string;
}

// Request parameters for fetching classification history
export interface ClassificationHistoryRequest {
  systemCode?: string;
  limit?: number;
  cursor?: string;
  status?: string;
  startDate?: string;
  endDate?: string;
  search?: string; 
  sourceType?: string;
  createdBy?: string;
}

// Status Types already defined above - no need to redeclare

File: src/api/user.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore, USER_INFO_KEY } from './core-client';
import { User, UserListResponse, CreateUserRequest, UpdateUserRequest } from './types';

export class UserService {
    constructor(private core: ApiClientCore) {}

    async getUsers(params?: { limit?: number; offset?: number; search?: string }): Promise<UserListResponse> {
        const urlParams = new URLSearchParams();
        if (params?.limit) urlParams.append('limit', params.limit.toString());
        if (params?.offset) urlParams.append('offset', params.offset.toString());
        if (params?.search) urlParams.append('search', params.search);
        const url = `${formatEndpoint('/users')}${urlParams.toString() ? '?' + urlParams.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to get users");
            }
            return await response.json();
        } catch (error) {
            console.error(`Get users error:`, error);
            throw error;
        }
    }

    async createUser(data: CreateUserRequest): Promise<User> {
        const url = formatEndpoint('/users');
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to create user");
            }
            return await response.json();
        } catch (error) {
            console.error(`Create user error:`, error);
            throw error;
        }
    }

    async updateUser(id: number, data: UpdateUserRequest): Promise<User> {
        const url = formatEndpoint(`/users/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to update user");
            }
            const result = await response.json();
            const currentUser = this.core.getCurrentUserInfo();
            if (currentUser && currentUser.id === id) {
                localStorage.setItem(USER_INFO_KEY, JSON.stringify(result));
            }
            return result;
        } catch (error) {
            console.error(`Update user error:`, error);
            throw error;
        }
    }

    async deleteUser(id: number): Promise<void> {
        const url = formatEndpoint(`/users/${id}`);
        try {
            const response = await this.core.fetchWithTimeout(url, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to delete user");
            }
        } catch (error) {
            console.error(`Delete user error:`, error);
            throw error;
        }
    }

    async assignRolesToUser(userId: number, roleNames: string[]): Promise<void> {
        const url = formatEndpoint(`/users/${userId}/roles`);
        try {
            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ roles: roleNames }),
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || "Failed to assign roles to user");
            }
        } catch (error) {
            console.error(`Assign roles error:`, error);
            throw error;
        }
    }
}

File: src/api/system.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { 
  ClassificationSystem, 
  ClassificationLevel,
  Category,
  SystemCategoriesRequest
} from './types';

export class SystemService {
    constructor(private core: ApiClientCore) {}

    async getClassificationSystems(): Promise<ClassificationSystem[]> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const response = await this.core.fetchWithTimeout(formatEndpoint('/systems'));
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get classification systems');
            }
            const data = await response.json();
            const systems = Array.isArray(data.systems) ? data.systems : [];
            return systems.map((system: any) => ({
                id: system.id,
                code: system.code,
                name: system.name,
                description: system.description,
                enabled: system.enabled,
                createdAt: this.core.formatDate(system.created_at)
            }));
        } catch (error) {
            console.error(`[${requestId}] Get classification systems error:`, error);
            throw error;
        }
    }

    async getClassificationSystem(code: string): Promise<{ system: ClassificationSystem; levels: ClassificationLevel[] }> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const response = await this.core.fetchWithTimeout(formatEndpoint(`/systems/${code}`));
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get classification system');
            }
            const data = await response.json();
            const system: ClassificationSystem = {
                id: data.system.id,
                code: data.system.code,
                name: data.system.name,
                description: data.system.description,
                enabled: data.system.enabled,
                createdAt: this.core.formatDate(data.system.created_at)
            };
            const levels = (data.levels || []).map((level: any) => ({
                id: level.id,
                systemId: level.system_id,
                levelNumber: level.level_number,
                code: level.code,
                name: level.name,
                description: level.description,
                validationRegex: level.validation_regex
            }));
            return { system, levels };
        } catch (error) {
            console.error(`[${requestId}] Get classification system error:`, error);
            throw error;
        }
    }

    async getSystemCategories(req: SystemCategoriesRequest): Promise<Category[]> {
        const requestId = Math.random().toString(36).substring(7);
        const params = new URLSearchParams();
        if (req.level) params.append('level', req.level);
        if (req.parentCode) params.append('parent_code', req.parentCode);
        const url = `${formatEndpoint(`/systems/${req.systemCode}/categories`)}${params.toString() ? '?' + params.toString() : ''}`;
        try {
            const response = await this.core.fetchWithTimeout(url);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get system categories');
            }
            const data = await response.json();
            const categories = Array.isArray(data.categories) ? data.categories : [];
            return categories.map((cat: any) => ({
                id: cat.id,
                systemId: cat.system_id,
                code: cat.code,
                name: cat.name,
                description: cat.description,
                levelCode: cat.level_code,
                parentCode: cat.parent_code,
                createdAt: this.core.formatDate(cat.created_at)
            }));
        } catch (error) {
            console.error(`[${requestId}] Get system categories error:`, error);
            throw error;
        }
    }
}

File: src/api/config.service.ts
import { formatEndpoint } from '../config/api';
import { ApiClientCore } from './core-client';
import { LlmConfig, UpdateConfigRequest } from './types'; // Import UpdateConfigRequest

export class ConfigService {
    constructor(private core: ApiClientCore) {}

    async getConfig(): Promise<LlmConfig & { ragEnabled?: boolean }> {
        const requestId = Math.random().toString(36).substring(7);
        try {
            const response = await this.core.fetchWithTimeout(formatEndpoint('/settings/config'));
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Failed to get configuration');
            }
            const data = await response.json();

            // Simplified transformation logic (adjust if complex cases needed)
            const transformObject = (obj: any): any => {
                if (!obj || typeof obj !== 'object') return obj;
                if (Array.isArray(obj)) return obj.map(transformObject);
                const result: any = {};
                Object.entries(obj).forEach(([key, value]) => {
                    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
                    result[camelKey] = typeof value === 'object' ? transformObject(value) : value;
                });
                return result;
            };

            const config: LlmConfig = {
                server: transformObject(data.server),
                service: transformObject(data.service),
                database: transformObject(data.database),
                validation: transformObject(data.validation),
                alert: transformObject(data.alert),
                llmEndpoint: data.service?.llm_endpoint || '',
                llmApiKey: data.service?.llm_api_key || '',
                ragEnabled: !!(data.database?.rag_enabled ?? data.ragEnabled ?? false), // Simplified check
            };
            console.log(`[${requestId}] Transformed config (API Key Redacted):`, { ...config, llmApiKey: '[REDACTED]', service: { ...config.service, llmApiKey: '[REDACTED]' } });
            return config;
        } catch (error) {
            console.error(`[${requestId}] Get config error:`, error);
            return { llmEndpoint: '', llmApiKey: '', ragEnabled: false }; // Default on error
        }
    }

    async updateConfig(configUpdate: UpdateConfigRequest): Promise<void> {
        const requestId = Math.random().toString(36).substring(7);
        const url = formatEndpoint('/settings/config'); // Ensure endpoint is correct (usually same as GET)
        try {
            // Log the update payload *without* sensitive fields if possible
             const safePayload = JSON.parse(JSON.stringify(configUpdate)); // Deep copy
             if (safePayload.service?.llmApiKey) safePayload.service.llmApiKey = '[REDACTED]';
             if (safePayload.alert?.emailSettings?.smtpPassword) safePayload.alert.emailSettings.smtpPassword = '[REDACTED]';
             console.log(`[${requestId}] Sending config update request to ${url}`, safePayload);

            const response = await this.core.fetchWithTimeout(url, {
                method: 'PUT', // Use PUT for updating the entire config resource (or PATCH for partial)
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(configUpdate), // Send the update payload
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                console.error(`[${requestId}] Update config error response:`, error);
                throw new Error(error.error || 'Failed to update configuration');
            }
            console.log(`[${requestId}] Configuration updated successfully.`);
        } catch (error) {
            console.error(`[${requestId}] Update config error:`, error);
            throw error; // Re-throw error
        }
    }
}

File: src/assets/icons/logout.svg
<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none"><path fill="currentColor" stroke="currentColor" stroke-width=".4" d="M8.598 7.2h2.828a.8.8 0 1 0 0-.4H8.598v-2h1a.6.6 0 0 0 .6-.6V2.4c0-.11.09-.2.2-.2h1.028a.8.8 0 1 0 0-.4h-1.028a.6.6 0 0 0-.6.6v1.8a.2.2 0 0 1-.2.2h-1V2.6C8.598 1.688 6.965 1 4.8 1S1 1.688 1 2.6v8.8c0 .912 1.633 1.6 3.8 1.6 2.165 0 3.798-.688 3.798-1.6v-1h1c.11 0 .2.09.2.2v1.2a.6.6 0 0 0 .6.6h1.028a.8.8 0 1 0 0-.4h-1.028a.2.2 0 0 1-.2-.2v-1.2a.6.6 0 0 0-.6-.6h-1V7.2Zm3.6-.6a.4.4 0 1 1-.001.8.4.4 0 0 1 0-.8Zm0-5a.4.4 0 1 1-.001.8.4.4 0 0 1 0-.8Zm0 10.2a.4.4 0 1 1-.001.8.4.4 0 0 1 0-.8ZM4.798 1.4c2.003 0 3.4.632 3.4 1.2s-1.397 1.2-3.4 1.2-3.4-.632-3.4-1.2 1.397-1.2 3.4-1.2ZM1.4 3.335c.612.522 1.872.865 3.4.865 1.528 0 2.788-.343 3.4-.865V5.6c0 .568-1.397 1.2-3.4 1.2s-3.4-.632-3.4-1.2V3.335ZM4.8 12.6c-2.003 0-3.4-.632-3.4-1.2V9.135c.612.522 1.872.865 3.4.865 1.528 0 2.788-.343 3.4-.865V11.4c0 .568-1.397 1.2-3.4 1.2Zm0-3c-2.003 0-3.4-.632-3.4-1.2V6.335c.612.522 1.872.865 3.4.865 1.528 0 2.788-.343 3.4-.865V8.4c0 .568-1.397 1.2-3.4 1.2Z"/><path fill="currentColor" stroke="currentColor" stroke-width=".4" d="M11.998 1.8h.4v.4h-.4v-.4ZM11.998 6.8h.4v.4h-.4v-.4ZM11.998 12h.4v.4h-.4V12Z"/></svg>

File: src/assets/icons/dashboard.svg
<svg width="50" height="51" viewBox="0 0 50 51" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_967_10531)">
<path d="M48.5352 50.5H1.46484C0.655859 50.5 0 49.8441 0 49.0351V21.4961C0 21.0603 0.193945 20.6471 0.529395 20.3688L24.0646 0.837573C24.607 0.387476 25.3931 0.387476 25.9354 0.837573L49.4706 20.3688C49.8061 20.6471 50 21.0603 50 21.4961V49.0351C50 49.8441 49.3441 50.5 48.5352 50.5Z" fill="#FFCD14"/>
<path d="M49.4706 20.3688L25.9355 0.837598C25.6643 0.6125 25.3321 0.5 25 0.5V50.5H48.5352C49.3441 50.5 50 49.8441 50 49.0352V21.4961C50 21.0604 49.8061 20.6472 49.4706 20.3688Z" fill="#FFB400"/>
<path d="M41.6016 37.6094H8.39844C7.58945 37.6094 6.93359 36.9535 6.93359 36.1445V7.82422C6.93359 7.01523 7.58945 6.35938 8.39844 6.35938H41.6016C42.4105 6.35938 43.0664 7.01523 43.0664 7.82422V36.1445C43.0664 36.9535 42.4105 37.6094 41.6016 37.6094Z" fill="#DCF5FA"/>
<path d="M41.6016 6.35938H25V37.6094H41.6016C42.4105 37.6094 43.0664 36.9535 43.0664 36.1445V7.82422C43.0664 7.01523 42.4105 6.35938 41.6016 6.35938Z" fill="#BEDCE6"/>
<path d="M33.9471 18.3581C33.9444 18.3479 33.9415 18.3378 33.9384 18.3277C33.2148 15.9302 31.596 13.9671 29.3799 12.8C27.1642 11.6331 24.6289 11.4092 22.2407 12.1693C19.9777 12.8896 18.0951 14.4426 16.9396 16.5422C15.7837 18.6423 15.4798 21.0635 16.0837 23.36C16.6067 25.349 17.7362 27.0649 19.3501 28.3222C20.9038 29.5328 22.8392 30.2293 24.7997 30.2835C24.809 30.2838 24.818 30.2839 24.8271 30.2839C25.354 30.2839 25.7882 29.8642 25.8028 29.3342C25.8176 28.7951 25.3927 28.346 24.8536 28.3311C21.6253 28.2419 18.7957 25.9934 17.9724 22.8632C16.9811 19.0934 19.1161 15.2135 22.833 14.0303C24.7187 13.43 26.7206 13.6068 28.4696 14.528C30.2144 15.4469 31.4905 16.9911 32.064 18.8768C32.4271 20.25 32.3079 21.5258 31.6662 23.1391C31.4901 23.5818 30.9444 24.6114 29.6821 24.6114C29.4443 24.6114 29.2608 24.4626 29.1724 24.3739C28.962 24.1623 28.8372 23.8507 28.8387 23.54L28.8508 21.094C28.8528 21.0271 28.8549 20.9603 28.8549 20.8927C28.8549 20.8504 28.8532 20.8088 28.8525 20.7668L28.8749 16.2586C28.8775 15.7193 28.4424 15.2799 27.9032 15.2772C27.9014 15.2772 27.9 15.2772 27.8982 15.2772C27.3612 15.2772 26.9244 15.7113 26.9217 16.249L26.9201 16.5856C26.282 16.1261 25.5167 15.8676 24.6698 15.8676C22.4825 15.8676 20.2199 17.7568 20.2199 20.9182C20.2199 23.8005 22.1765 26.1453 24.5815 26.1453C25.6007 26.1453 26.5252 25.7268 27.252 25.0206C27.3936 25.2887 27.5736 25.536 27.7882 25.7515C28.3098 26.2758 28.9825 26.5645 29.6823 26.5645C31.6906 26.5645 32.9615 25.1678 33.4812 23.8609C34.2818 21.8478 34.4256 20.1506 33.9471 18.3581ZM24.5814 24.1924C23.4231 24.1924 22.1729 22.9407 22.1729 20.9184C22.1729 18.9796 23.4424 17.821 24.6697 17.821C25.9481 17.821 26.851 19.0164 26.8995 20.7463L26.8978 21.0803C26.8292 22.8128 25.8166 24.1924 24.5814 24.1924Z" fill="#696969"/>
<path d="M25.8029 29.3346C25.8164 28.8454 25.4675 28.4315 25 28.3477V30.2681C25.4457 30.1881 25.7898 29.8052 25.8029 29.3346Z" fill="#555555"/>
<path d="M33.9386 18.3273C33.2149 15.9299 31.5961 13.9667 29.38 12.7996C28.0059 12.0759 26.5088 11.7153 25 11.7268V13.681C26.1952 13.6699 27.3814 13.9546 28.4697 14.5277C30.2146 15.4467 31.4906 16.9908 32.0642 18.8765C32.4272 20.2497 32.308 21.5255 31.6663 23.1388C31.4902 23.5815 30.9445 24.6111 29.6822 24.6111C29.4444 24.6111 29.2609 24.4623 29.1726 24.3736C28.9621 24.162 28.8373 23.8504 28.8389 23.5397L28.851 21.0937C28.8529 21.0268 28.855 20.96 28.855 20.8925C28.855 20.8501 28.8533 20.8085 28.8526 20.7665L28.875 16.2583C28.8776 15.719 28.4426 15.2796 27.9033 15.2769C27.9016 15.2769 27.9001 15.2769 27.8983 15.2769C27.3613 15.2769 26.9245 15.711 26.9219 16.2487L26.9202 16.5853C26.3662 16.1864 25.7161 15.9392 25.0001 15.881V17.8487C26.1013 18.037 26.8555 19.1692 26.8996 20.7459L26.8979 21.08C26.8373 22.6119 26.0383 23.8672 25.0001 24.1374V26.1205C25.8534 26.0226 26.6262 25.6287 27.2521 25.0205C27.3937 25.2886 27.5736 25.5359 27.7882 25.7514C28.3099 26.2758 28.9825 26.5644 29.6823 26.5644C31.6906 26.5644 32.9615 25.1677 33.4812 23.8608C34.2819 21.8475 34.4257 20.1503 33.9473 18.3578C33.9445 18.3475 33.9417 18.3375 33.9386 18.3273Z" fill="#555555"/>
<path d="M48.5352 50.5H1.46484C0.655859 50.5 0 49.8442 0 49.0352V21.4961C0 20.9641 0.288477 20.4739 0.753516 20.2155C1.21855 19.9572 1.78711 19.9713 2.23887 20.2525L25 34.4192L47.7611 20.2525C48.2127 19.9713 48.7812 19.9572 49.2465 20.2155C49.7115 20.4739 50 20.9641 50 21.4961V49.0352C50 49.8442 49.3441 50.5 48.5352 50.5Z" fill="#FFF037"/>
<path d="M49.2465 20.2155C48.7812 19.9572 48.2127 19.9713 47.7611 20.2525L25 34.4192V50.5H48.5352C49.3441 50.5 50 49.8442 50 49.0352V21.4961C50 20.9641 49.7115 20.4739 49.2465 20.2155Z" fill="#FFCD14"/>
</g>
<defs>
<clipPath id="clip0_967_10531">
<rect width="50" height="50" fill="white" transform="translate(0 0.5)"/>
</clipPath>
</defs>
</svg>


File: src/assets/icons/settings.svg
<svg viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2439_39034)">
<mask id="mask0_2439_39034" style="mask-type:luminance" maskUnits="userSpaceOnUse" x="5" y="5" width="30" height="30">
<path d="M5 5H35V35H5V5Z" fill="white"/>
</mask>
<g mask="url(#mask0_2439_39034)">
<path d="M30.9725 20.1537C30.8505 20.1535 30.7297 20.1773 30.617 20.2239C30.5043 20.2704 30.4019 20.3388 30.3157 20.425C30.2294 20.5113 30.1611 20.6137 30.1145 20.7264C30.068 20.8391 30.0441 20.9599 30.0444 21.0819V29.4256C30.0446 29.7909 29.9729 30.1527 29.8332 30.4903C29.6936 30.8279 29.4888 31.1346 29.2306 31.393C28.9724 31.6514 28.6658 31.8564 28.3283 31.9963C27.9908 32.1361 27.6291 32.2081 27.2637 32.2081H10.5744C10.2089 32.2084 9.84697 32.1366 9.50927 31.9968C9.17157 31.8571 8.86473 31.6521 8.6063 31.3937C8.34787 31.1353 8.14292 30.8284 8.00318 30.4907C7.86343 30.153 7.79163 29.7911 7.79188 29.4256V12.7381C7.79188 12.0002 8.08503 11.2924 8.60685 10.7706C9.12867 10.2488 9.83641 9.95562 10.5744 9.95562H18.9181C19.1643 9.95562 19.4004 9.85783 19.5744 9.68377C19.7485 9.50972 19.8462 9.27364 19.8462 9.02749C19.8462 8.78134 19.7485 8.54526 19.5744 8.37121C19.4004 8.19715 19.1643 8.09937 18.9181 8.09937H10.5744C9.96529 8.09937 9.36218 8.21936 8.79949 8.45251C8.23679 8.68565 7.72554 9.02736 7.29495 9.45814C6.86435 9.88891 6.52284 10.4003 6.28992 10.9631C6.05701 11.5259 5.93725 12.129 5.9375 12.7381V29.4275C5.938 30.6569 6.42674 31.8359 7.29627 32.705C8.1658 33.5742 9.34492 34.0625 10.5744 34.0625H27.2619C28.4916 34.0625 29.6711 33.574 30.5406 32.7044C31.4102 31.8348 31.8987 30.6554 31.8987 29.4256V21.0819C31.899 20.9601 31.8752 20.8394 31.8288 20.7268C31.7823 20.6142 31.7142 20.5119 31.6281 20.4257C31.5421 20.3395 31.4399 20.2711 31.3274 20.2244C31.2149 20.1778 31.0943 20.1537 30.9725 20.1537Z" fill="currentColor" stroke="currentColor" stroke-width="0.0875"/>
<path d="M24.7906 8.25501H30.11L17.0131 21.3406C16.8763 21.4755 16.7752 21.6422 16.7188 21.8258C16.6624 22.0094 16.6526 22.2041 16.6902 22.3925C16.7277 22.5808 16.8115 22.7569 16.934 22.9049C17.0565 23.0528 17.2138 23.168 17.3919 23.24C17.6044 23.3285 17.8384 23.3517 18.0642 23.3066C18.2899 23.2615 18.4971 23.1502 18.6594 22.9869L31.745 9.90126V15.2094C31.745 15.5167 31.8671 15.8114 32.0844 16.0287C32.3017 16.2461 32.5964 16.3681 32.9037 16.3681C33.211 16.3681 33.5058 16.2461 33.7231 16.0287C33.9404 15.8114 34.0625 15.5167 34.0625 15.2094V7.09626C34.0636 6.78799 33.9422 6.49191 33.725 6.27314C33.6168 6.16599 33.4887 6.0812 33.3477 6.02362C33.2068 5.96603 33.056 5.93677 32.9037 5.93751H24.7906C24.4833 5.93751 24.1886 6.0596 23.9712 6.2769C23.7539 6.49421 23.6319 6.78894 23.6319 7.09626C23.6319 7.40358 23.7539 7.69832 23.9712 7.91562C24.1886 8.13293 24.4833 8.25501 24.7906 8.25501Z" fill="currentColor" stroke="currentColor" stroke-width="0.0875"/>
</g>
</g>
<defs>
<clipPath id="clip0_2439_39034">
<rect width="30" height="30" fill="white" transform="translate(5 5)"/>
</clipPath>
</defs>
</svg>

File: config/config.yaml
# config.yaml
server:
  host: ""
  port: 8081
  requestTimeout: 6000s
  logLevel: "debug"

service:
  batchSize: 100
  dataPath: "../data/unspsc"
  commonDataPath: "../data/common"
  excelPattern: "[Uu][Nn][Ss][Pp][Ss][Cc]*.xlsx"
  llmEndpoint: "https://openrouter.ai/api/v1/chat/completions"  
  llmApiKey: "${OPENROUTER_API_KEY}"
  llmResponseFormat: "json_only"  # New option: "text_with_reasoning" or "json_only"
  llmModel: "qwen/qwen3-235b-a22b"
  llmMaxTokens: 4096
  llmTemperature: 0.2
  useTypePrompt: false # Use type prompt for good or service
  maxSkipLogs: 5 # Maximum number of skip load excel rows logs to display
  batchRetryLimit: 3 # Number of times to retry batch processing in case of partial matching

  # UNSPSC Loader Config
  unspscExcelLoader:
    filePath: "unspsc-english-v260801.xlsx"
    sheetName: ""
    levelHeaders:
      - dbLevelCode: "segment"
        codeHeader: "Segment"
        titleHeader: "Segment Title"
      - dbLevelCode: "family"
        codeHeader: "Family"
        titleHeader: "Family Title"
      - dbLevelCode: "class"
        codeHeader: "Class"
        titleHeader: "Class Title"
      - dbLevelCode: "commodity"
        codeHeader: "Commodity"
        titleHeader: "Commodity Title"

  # Common Categories Loader Config
  commonExcelLoader:
    filePath: "Common_Categories_07MAR25.xlsx"
    sheetName: "Common Categories -Sub Category"
    level1HeaderName: "Common Category with BPA Issued"

database:
  host: "localhost"
  port: 5433
  user: "unspsc"
  password: "unspsc"
  name: "unspsc"
  dataPath: "../data/db"
  ragServiceUrl: "http://localhost:8090"
  ragEnabled: true
  # ADDED RAG Collection Names
  ragManualInfoCollection: "rag_manual_info"      # Name for manual RAG entries
  ragUnspscCollection: "unspsc_categories"        # Name for UNSPSC system data
  ragCommonCollection: "common_categories"        # Name for Common Categories system data

validation:
  maxHistoryLimit: 100
  tokenLimit: 4096
  defaultTimeout: 15s

alert:
  emailSettings:
    smtpHost: ""
    smtpPort: 587
    smtpUser: ""
    smtpPassword: ""
    fromEmail: ""
  webhookSettings:
    url: ""
    
auth: # New section for authentication
  enabled: false               # Set to true to enable authentication
  jwtSecret: "REPLACE_THIS_WITH_A_VERY_STRONG_RANDOM_SECRET_KEY_32_CHARS_OR_MORE" # Use env var in prod!
  jwtExpirationHours: 72      # Token validity duration
  initialAdminUser: "admin"
  initialAdminPassword: "REPLACE_THIS_WITH_A_STRONG_PASSWORD" # Will be hashed

File: tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [
    { "path": "./tsconfig.node.json" }
  ]
}

File: vite.config.ts
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

const JAT_CATEGORIZATIONS_TARGET = 'http://localhost:8081'; // Default Go backend
const JAT_SNOW_TARGET = 'http://localhost:8082';             // Snow service backend
const PYTHON_LANGGRAPH_BACKEND_TARGET = 'http://localhost:8090';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      // Rule for /api/v1/lg-vis/ws path - WebSocket (existing, unchanged)
      '/api/v1/lg-vis/ws': { 
        target: PYTHON_LANGGRAPH_BACKEND_TARGET,
        ws: true,
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, ''), // Remove /api prefix
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS-WS] Error:', err.message);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS-WS] Sending WS Request to Python:', req.method, proxyReq.path, 'Original path:', req.url);
          });
          proxy.on('proxyReqWs', (proxyReq, req, socket, options, head) => {
            console.log('[PROXY PYTHON V1-LG-VIS-WS] Proxying WS request to Python:', req.url, 'â†’', proxyReq.path);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS-WS] Received Response from Python:', proxyRes.statusCode, req.url);
          });
        }
      },

      // Rule for /api/v1/lg-vis/... path (Python HTTP) (existing, unchanged)
      '/api/v1/lg-vis': { 
        target: PYTHON_LANGGRAPH_BACKEND_TARGET,
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, ''), // Remove /api prefix
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS-HTTP] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS-HTTP] Sending Request to Python:', req.method, proxyReq.path, 'Original path:', req.url);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('[PROXY PYTHON V1-LG-VIS-HTTP] Received Response from Python:', proxyRes.statusCode, req.url);
          });
        },
      },
      // Proxy for JAT Snow Service (Go) - MORE SPECIFIC
      // This rule must come BEFORE the general /api/v1 rule for jat-categorizations
      '/api/v1/snow': {
        target: JAT_SNOW_TARGET,
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, ''), // /api/v1/snow/* -> /v1/snow/*
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY JAT-SNOW V1-HTTP] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY JAT-SNOW V1-HTTP] Sending Request to JAT-SNOW:', req.method, proxyReq.path, 'Original path:', req.url);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('[PROXY JAT-SNOW V1-HTTP] Received Response from JAT-SNOW:', proxyRes.statusCode, req.url);
          });
        },
      },
      // Proxy for general JAT Categorizations API (Go) - General fallback for /api/v1/*
      '/api/v1': {
        target: JAT_CATEGORIZATIONS_TARGET, // Changed from GO_BACKEND_TARGET to be specific
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, ''), // /api/v1/* -> /v1/*
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('[PROXY JAT-CATEGORIZATIONS V1-HTTP] Error:', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('[PROXY JAT-CATEGORIZATIONS V1-HTTP] Sending Request to JAT-CATEGORIZATIONS:', req.method, proxyReq.path, 'Original path:', req.url);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('[PROXY JAT-CATEGORIZATIONS V1-HTTP] Received Response from JAT-CATEGORIZATIONS:', proxyRes.statusCode, req.url);
          });
        },
      },
    },
    port: 5173,
    host: true,
  },
});

File: package.json
{
  "name": "GovIlm-classifier",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@ai-sdk/react": "^1.2.12",
    "@ant-design/icons": "^6.0.0",
    "@headlessui/react": "^2.2.2",
    "@heroicons/react": "^2.0.18",
    "@monaco-editor/react": "^4.7.0",
    "@tailwindcss/postcss": "^4.1.5",
    "antd": "^5.24.2",
    "axios": "^1.8.4",
    "classnames": "^2.5.1",
    "dagre": "^0.8.5",
    "dayjs": "^1.11.13",
    "file-saver": "^2.0.5",
    "GovIlm-classifier": "file:",
    "lodash": "^4.17.21",
    "monaco-editor": "^0.52.2",
    "papaparse": "^5.5.2",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-dropzone": "^14.3.8",
    "react-i18next": "15.5.1",
    "react-markdown": "^10.1.0",
    "react-router-dom": "7.5.3",
    "react-select": "^5.7.3",
    "reactflow": "^11.11.4",
    "unspsc-classifier": "file:",
    "xlsx": "https://cdn.sheetjs.com/xlsx-0.20.3/xlsx-0.20.3.tgz"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@types/dagre": "^0.7.52",
    "@types/file-saver": "^2.0.7",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.14.195",
    "@types/node": "22.15.12",
    "@types/papaparse": "^5.3.15",
    "@types/react": "19.1.3",
    "@types/react-dom": "19.1.3",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.14",
    "babel-jest": "^29.7.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "postcss": "^8.4.26",
    "postcss-import": "^16.0.0",
    "postcss-nesting": "^13.0.1",
    "tailwindcss": "3.4.17",
    "ts-jest": "^29.3.2",
    "typescript": "^5.1.6",
    "vite": "^6.3.5",
    "vite-plugin-monaco-editor": "^1.1.0"
  },
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "clean": "rm -rf node_modules pnpm-lock.yaml"
  }
}


File: start-web.bat
@echo off
setlocal EnableDelayedExpansion

REM Constants
set "CONFIG_FILE=config\config.yaml"
set "SCRIPT_NAME=%~nx0"
set "REQUIRED_NODE_VERSION=16"

REM Initialize error handling
set "EXIT_SUCCESS=0"
set "EXIT_CONFIG_ERROR=1"
set "EXIT_PNPM_ERROR=2"
set "EXIT_NODE_ERROR=3"
set "EXIT_PORT_ERROR=4"

REM Prevent OpenSSL from looking for config
set "OPENSSL_CONF="
set "NODE_OPTIONS=--no-node-snapshot"

REM Parse parameters
set "USE_LOG_FILE="
if "%~1"=="-log" set "USE_LOG_FILE=1"

:main
    call :init
    if errorlevel 1 exit /b %errorlevel%
    
    call :check_prerequisites
    if errorlevel 1 exit /b %errorlevel%
    
    call :setup_dependencies
    if errorlevel 1 exit /b %errorlevel%
    
    call :start_web
    exit /b %errorlevel%

:init
    echo [%date% %time%] Starting %SCRIPT_NAME%...
    
    REM Check config file
    if not exist "%CONFIG_FILE%" (
        echo ERROR: %CONFIG_FILE% file not found
        exit /b %EXIT_CONFIG_ERROR%
    )
    
    REM Extract port from config.yaml
    for /f "tokens=2 delims=:" %%a in ('findstr /C:"port: " "%CONFIG_FILE%"') do (
        set "SERVER_PORT=%%a"
        set "SERVER_PORT=!SERVER_PORT: =!"
    )
    
    if not defined SERVER_PORT (
        echo ERROR: Unable to find port in %CONFIG_FILE%
        exit /b %EXIT_CONFIG_ERROR%
    )
    exit /b %EXIT_SUCCESS%

:check_prerequisites
    REM Check Node.js installation
    where node >nul 2>&1
    if %errorlevel% neq 0 (
        echo ERROR: Node.js is not installed
        exit /b %EXIT_NODE_ERROR%
    )

    REM Check Node.js version
    for /f "tokens=1 delims=." %%a in ('node -v') do (
        set "NODE_VERSION=%%a"
        set "NODE_VERSION=!NODE_VERSION:v=!"
        if !NODE_VERSION! lss %REQUIRED_NODE_VERSION% (
            echo ERROR: Node.js version %REQUIRED_NODE_VERSION% or higher required
            exit /b %EXIT_NODE_ERROR%
        )
    )

    REM Check pnpm installation
    where pnpm >nul 2>&1
    if %errorlevel% neq 0 (
        echo ERROR: pnpm is not installed
        echo Install it with: npm install -g pnpm
        exit /b %EXIT_PNPM_ERROR%
    )
    exit /b %EXIT_SUCCESS%

:setup_dependencies
    REM Check and install dependencies using pnpm
    if not exist "node_modules" (
        echo Installing dependencies...
        call pnpm install
        if !errorlevel! neq 0 (
            echo ERROR: Failed to install dependencies
            exit /b %EXIT_PNPM_ERROR%
        )
    )
    exit /b %EXIT_SUCCESS%

:check_port
    set "port_in_use="
    for /f "tokens=5" %%a in ('netstat -ano ^| findstr /R ":%SERVER_PORT%\>"') do (
        if not defined port_in_use (
            set "port_in_use=%%a"
        )
    )
    
    if defined port_in_use (
        echo Port %SERVER_PORT% is being used by process ID !port_in_use!
        choice /C YN /M "Do you want to terminate this process?"
        if !errorlevel!==1 (
            REM Check administrative privileges only when needed
            net session >nul 2>&1
            if %errorlevel% neq 0 (
                echo ERROR: Administrative privileges required to terminate process
                echo Please run 'taskkill /PID !port_in_use! /F' in an elevated command prompt
                exit /b %EXIT_PORT_ERROR%
            )
            
            taskkill /PID !port_in_use! /F
            if !errorlevel! neq 0 (
                echo ERROR: Failed to terminate process !port_in_use!
                echo Please manually terminate the process using: taskkill /PID !port_in_use! /F
                exit /b %EXIT_PORT_ERROR%
            )
            echo Process !port_in_use! terminated
            timeout /t 2 /nobreak >nul
        ) else (
            echo Please free up port %SERVER_PORT% and try again
            exit /b %EXIT_PORT_ERROR%
        )
    )
    exit /b %EXIT_SUCCESS%

:start_web
    call :check_port
    if errorlevel 1 exit /b %errorlevel%

    echo Starting development server on port %SERVER_PORT%...
    
    REM Start development server with appropriate logging
    if defined USE_LOG_FILE (
        pnpm run dev > "logs\web.log" 2>&1
    ) else (
        pnpm run dev
    )
    
    if errorlevel 1 (
        if defined USE_LOG_FILE (
            echo ERROR: Failed to start web server. Check logs\web.log for details
        ) else (
            echo ERROR: Failed to start web server
        )
        exit /b %errorlevel%
    )
    exit /b %EXIT_SUCCESS%

:end
endlocal


File: index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GovIlm</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

File: postcss.config.js
module.exports = {
  plugins: {
    'postcss-import': {},
    'postcss-nesting': {}, // Add explicit postcss-nesting plugin
    tailwindcss: {},
    autoprefixer: {},
  }
}


File: tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
        },
        secondary: {
          50: '#f8fafc',
          100: '#f1f5f9',
          200: '#e2e8f0',
          300: '#cbd5e1',
          400: '#94a3b8',
          500: '#64748b',
          600: '#475569',
          700: '#334155',
          800: '#1e293b',
          900: '#0f172a',
        },
      },
      borderRadius: {
        'card': '0.5rem',
      },
      boxShadow: {
        'card': '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
        'card-hover': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
      },
    },
  },
  plugins: [],
}

File: README.md
# Frontend Components (`src/components`)

This directory contains the reusable React components that make up the user interface of the GovIlm Classifier application. Components are organized by feature area where applicable.

> **Status Types Documentation**: This project contains multiple systems with different status types. For details about the status types used in both the Categorization and ServiceNow systems, see [docs/STATUS_TYPES.md](./docs/STATUS_TYPES.md).

## Core Layout & Navigation

*   **`Layout/PageLayout.tsx`**: The main application shell. It renders the fixed header, the collapsible `LeftSidebar`, and the main content area (`<Outlet />`). It manages the sidebar's collapsed/expanded state.
*   **`Layout/Breadcrumb.tsx`**: (Currently seems unused by `PageLayout`) An Ant Design Breadcrumb component intended to show the user's current location within the app based on the route path.
*   **`Sidebar/LeftSidebar.component.tsx`**: The main navigation sidebar. It dynamically renders menu items based on application configuration (e.g., RAG enabled) and user permissions. Handles collapsing/expanding on hover and logout confirmation.
*   **`Sidebar/LeftSidebarItem.component.tsx`**: Renders a single item within the `LeftSidebar`, handling navigation links or actions like logout.

## Authentication

*   **`LoginForm.tsx`**: A form component for users to enter their username and password. It interacts with the `AuthService` via the `apiClient` prop to perform login and handles success/error states.

## Classification (Single Item)

*   **`ClassificationForm.tsx`**: Provides the primary interface for classifying a single item. Includes fields for description, context, system selection, handles API calls for classification, displays results, and allows triggering manual classification edits.
*   **`ManualClassificationModal.tsx`**: A modal component used for manually setting or overriding classification codes for different levels of a selected system. It features searchable dropdowns for selecting categories.
*   **`ClassificationDetailsModal.tsx`**: A modal component used within the `HistoryTab` to display the full details of a past classification, including levels, RAG context (if used), and LLM reasoning (if available), organized into tabs.
*   **`RerunStatusModal.tsx`**: A simple modal indicating that a classification rerun is in progress.

## Batch Classification (`BatchTab`)

*   **`BatchTab/BatchTab.tsx`**: The main component orchestrating the batch classification process. It integrates file upload, column selection, preview, progress display, and result summary.
*   **`BatchTab/FileUpload.tsx`**: Handles drag-and-drop or browse file uploads (CSV/Excel). Includes logic to detect multiple Excel sheets and prompt the user for selection.
*   **`BatchTab/ColumnSelector.tsx`**: Allows users to map columns from their uploaded file to specific roles (Source Description, Context, Key Columns) and select the classification system.
*   **`BatchTab/PreviewTable.tsx`**: Displays a preview of the uploaded data, highlighting the selected columns and showing processing status/results for previewed rows.
*   **`BatchTab/BatchProgress.tsx`**: Shows the progress of an ongoing batch classification job (items processed / total).
*   **`BatchTab/BatchSummary.tsx`**: Displays a summary of a completed batch job (success/partial/fail counts) and provides a button to download the results as a CSV.

## Batch Jobs (`BatchJobsTab`)

*   **`BatchJobsTab/BatchJobsTab.tsx`**: The main component for viewing and managing past and ongoing batch classification jobs. It uses hooks for data fetching, filtering, and polling.
*   **`BatchJobsTab/components/BatchJobsFilters.tsx`**: Provides UI elements (dropdowns, date pickers) for filtering the list of batch jobs.
*   **`BatchJobsTab/components/BatchJobsTable.tsx`**: Displays the list of batch jobs with details like status, progress, and actions (View, Download).
*   **`BatchJobsTab/components/BatchJobsPagination.tsx`**: Handles pagination for the batch jobs list (currently seems unused/replaced by Antd pagination in `BatchJobsTab`).
*   **`BatchJobsTab/components/JobStatusDisplay.tsx`**: A helper component rendering status badges, progress bars, and summary counts within the `BatchJobsTable`.
*   **`BatchJobsTab/components/BatchSummary.tsx`**: (Potentially duplicated/misplaced - similar functionality exists in `src/components/BatchTab`) Displays a summary of batch results, likely intended for within the details modal or job row.
*   **`BatchJobsTab/BatchJobDetailsModal.tsx`**: A modal showing detailed results for each item within a specific batch job.

## History (`HistoryTab`)

*   **`HistoryTab.tsx`**: Displays a paginated and filterable table of past classification records (both single and batch items). Allows viewing details, manual reclassification, rerunning, and deleting history entries based on user permissions.

## RAG Information Management (`RagInfoTab`)

*   **`RagInfoTab/RagInfoTab.tsx`**: The main component for managing custom information used for Retrieval-Augmented Generation (RAG). Orchestrates fetching, creating, updating, deleting, filtering, and pagination of RAG items. Includes CSV import/export functionality.
*   **`RagInfoTab/components/RagInfoFilters.tsx`**: Provides a search input for filtering RAG items.
*   **`RagInfoTab/components/RagInfoTable.tsx`**: Displays the list of RAG items with their keys, descriptions, and actions.
*   **`RagInfoTab/components/RagInfoPagination.tsx`**: Handles pagination for the RAG items list.
*   **`RagInfoTab/components/RagInfoFormModal.tsx`**: A modal form used for creating new RAG items or editing existing ones.

## Settings

*   **`Settings/SettingsTab.tsx`**: The main interactive component for the Settings page. It displays configuration values fetched from the API, organized into tabs. It allows users with appropriate permissions to edit configuration values using various input types (text, password, number, switch, select). Handles saving changes via the `apiClient`.
*   **`ConfigValue.tsx`**: A reusable component used by `SettingsTab` (and potentially `Settings.tsx`) to display individual configuration values. It handles different data types, masks sensitive values (like API keys, passwords), and provides specific styling for boolean values.
*   **`Settings.tsx`**: (Seems to be an older/view-only version) Displays system configuration in a read-only, collapsible format. Uses `ConfigValue` for rendering. *Note: `SettingsTab.tsx` appears to be the primary component used in `SettingsPage.tsx`.*

## User Management (`UserManagementTab`)

*   **`UserManagementTab/UserManagementTab.tsx`**: Orchestrates the User Management UI, using the `useUsers` hook for data and logic. Integrates the table and modal form.
*   **`UserManagementTab/components/UserTable.tsx`**: Displays the list of users with their roles and provides actions (Edit, Delete) based on permissions. Includes sorting and pagination.
*   **`UserManagementTab/components/UserFormModal.tsx`**: A modal form for creating new users or editing existing ones, including password handling and role assignment via a multi-select dropdown.
*   **`UserManagementComponent.tsx`**: (Seems superseded by `UserManagementTab`) Older component structure containing table and modal logic directly.

## Role Management (`RoleManagementTab`)

*   **`RoleManagementTab/RoleManagementTab.tsx`**: Orchestrates the Role Management UI, using the `useRoles` hook. Integrates the table and modal form.
*   **`RoleManagementTab/components/RoleTable.tsx`**: Displays the list of roles, their descriptions, assigned permissions, and actions (Edit, Delete - excluding core roles).
*   **`RoleManagementTab/components/RoleFormModal.tsx`**: A modal form for creating new roles or editing existing ones (name, description, permissions). Handles permission selection via checkboxes grouped by category. Restricts modification of core roles.
*   **`RoleManagementTab/components/PermissionAssignmentModal.tsx`**: (Seems unused/superseded by `RoleFormModal`) A modal specifically for assigning permissions to a role, likely replaced by the integrated permission selection in `RoleFormModal`.
*   **`RoleManagementComponent.tsx`**: (Seems superseded by `RoleManagementTab`) Older component structure containing table and modal logic directly.

## Associated Hooks

Helper hooks encapsulate data fetching, state management, and logic for specific features:

*   **`UserManagement/hooks/useUsers.ts`**: Manages fetching, creating, updating, deleting users, and fetching available roles.
*   **`RoleManagement/hooks/useRoles.ts`**: Manages fetching, creating, updating, deleting roles, and fetching available permissions.
*   **`RagInfoTab/hooks/useRagInfo.ts`**: Manages fetching, creating, updating, deleting, filtering, and paginating RAG info items. Includes logic for CSV export fetching.
*   **`BatchJobsTab/hooks/useBatchJobs.ts`**: Manages fetching, filtering, paginating, and polling batch job statuses.

## Testing

*   Tests are implemented using React Testing Library (`@testing-library/react`) and Jest.
*   Example: `__tests__/ConfigValue.test.tsx` covers various scenarios for the `ConfigValue` component, including different data types, masking, and styling.

## Documentation & Helper Components

*   **`StatusTypeGuide.tsx`**: A documentation component that explains the different status types used in the Categorization and ServiceNow systems.
*   **`StatusTypeTooltip.tsx`**: A simple tooltip component that can be integrated into any UI to provide quick information about the status types.

## Development Notes

*   Components generally follow a pattern of having a main "Tab" or "Page" component that uses hooks for logic and integrates sub-components for display (Table, Filters, Modals).
*   Permissions (fetched via `useAuth`) are checked within components to enable/disable actions or show/hide UI elements.
*   Styling leverages Tailwind CSS utility classes (defined in `src/index.css`) and component-specific CSS files (e.g., `left-sidebar.css`). Ant Design (`antd`) components are used for tables, modals, forms, etc., providing a consistent look and feel.
*   Status types are consistently handled using utility functions in `src/utils/statusUtils.ts`.

.